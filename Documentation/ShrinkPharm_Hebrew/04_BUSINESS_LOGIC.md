# ShrinkPharm - לוגיקה עסקית

**מזהה מסמך:** DOC-SHRINK-001
**תאריך יצירה:** 2026-02-03
**מקור:** source_code/ShrinkPharm/ (574 שורות מקור מאומתות)

---

## מטרה עסקית

על פי כותרת הקובץ ב-`ShrinkPharm.c:7-10`:

> "מקבילה ל-ShrinkDoctor מבוססת ODBC לשימוש באפליקציית בית המרקחת MS-SQL"

נראה כי ShrinkPharm הוא כלי תחזוקת מסד נתונים ש:
- מוחק נתונים היסטוריים ממסד הנתונים של בית המרקחת MS-SQL
- אוכף מדיניות שמירת נתונים
- מתחזק ביצועי מסד נתונים על ידי הסרת רשומות ישנות

---

## אלגוריתם מחיקה

### זרימה ברמה גבוהה

על בסיס ניתוח קוד של `ShrinkPharm.c`:

```
1. קריאת תצורה מטבלת הבקרה shrinkpharm
2. לכל טבלת יעד מופעלת:
   א. חישוב תאריך חיתוך שמירה
   ב. זיהוי שורות ישנות מחיתוך
   ג. מחיקת שורות ישנות באצוות
   ד. תיעוד סטטיסטיקות ביצוע
3. רישום סיכומים ויציאה
```

### אלגוריתם מפורט

#### שלב 1: חישוב תאריך

על פי הקוד ב-`ShrinkPharm.c:189`:

```c
MinDateToRetain = IncrementDate(SysDate, 0 - days_to_retain);
```

חיתוך השמירה מחושב על ידי הפחתת `days_to_retain` מהתאריך הנוכחי.

**דוגמה:**
- אם SysDate = 20260203 (3 בפברואר 2026)
- ו-days_to_retain = 365
- אז MinDateToRetain = 20250203 (3 בפברואר 2025)
- כל השורות עם תאריכים לפני 20250203 יימחקו

#### שלב 2: בחירת שורות

שני מצבי בחירה נתמכים, נשלטים על ידי `use_where_clause`:

**מצב 1: פסוקית WHERE ב-SQL (use_where_clause != 0)**

על פי הקוד ב-`ShrinkPharm.c:193-206`:

```sql
SELECT <date_column> FROM <table> WHERE <date_column> < <MinDateToRetain>
```

מצב זה:
- משתמש באינדקס מסד נתונים (אם זמין) לסינון יעיל
- מחזה כמות עם שאילתת COUNT תחילה
- נראה כמצב המועדף

**מצב 2: סינון בקוד (use_where_clause == 0)**

על פי הקוד ב-`ShrinkPharm.c:208-213` ו-`ShrinkPharm.c:253-257`:

```sql
SELECT <date_column> FROM <table>
```

ואז בקוד:
```c
if ((!use_where_clause) && (DateOfRow >= MinDateToRetain)) {
    continue;  // דלג על שורה זו
}
```

מצב זה:
- סורק טבלה שלמה
- מסנן שורות בקוד אפליקציה
- משמש כאשר לטבלה אין אינדקס מתאים
- הערה בשורות 176-182 מסבירה שזה תואם להתנהגות "ShrinkDoctor הישן"

#### שלב 3: מחיקת שורות

על פי הקוד ב-`ShrinkPharm.c:215-216` ו-`ShrinkPharm.c:266`:

```sql
DELETE FROM <table> WHERE CURRENT OF ShrinkPharmSelCur
```

שורות נמחקות אחת בכל פעם באמצעות מחיקה ממוקמת (WHERE CURRENT OF cursor).

#### שלב 4: Commit באצווה

על פי הקוד ב-`ShrinkPharm.c:286-291`:

```c
if (RowsDeletedSinceCommit >= commit_count) {
    CommitAllWork();
    RowsDeletedSinceCommit = 0;
}
```

Commit-ים מתרחשים כל `commit_count` מחיקות, ניתן להגדרה לכל טבלה.

#### שלב 5: תיעוד סטטיסטיקות

על פי הקוד ב-`ShrinkPharm.c:303-307`:

לאחר עיבוד כל טבלה, התוכנית מעדכנת את שורת הבקרה:
- last_run_date
- last_run_time
- last_run_num_purged

---

## מודל תצורה

### סכמת טבלת בקרה (מסקנה)

על בסיס `MacODBC_MyOperators.c:91-99` ו-`ShrinkPharm.c:52-57`:

| עמודה | סוג | מטרה |
|-------|-----|------|
| table_name | char(30) | שם טבלה למחיקה |
| date_column_name | char(30) | שם עמודת תאריך להשוואה |
| days_to_retain | int | מספר ימי נתונים לשמור |
| use_where_clause | short | 0=סריקת כל השורות, אחרת=שימוש בפסוקית WHERE |
| commit_count | int | מספר מחיקות בין commit-ים |
| purge_enabled | (מסנן) | שונה מאפס מפעיל מחיקה לשורה זו |
| last_run_date | int | תאריך ביצוע אחרון (פלט) |
| last_run_time | int | שעת ביצוע אחרונה (פלט) |
| last_run_num_purged | int | שורות שנמחקו בריצה אחרונה (פלט) |

### דוגמת תצורה

שורת תצורה היפותטית:

| עמודה | ערך | משמעות |
|-------|-----|--------|
| table_name | (טבלת יעד) | טבלה שתימחק |
| date_column_name | (עמודת תאריך) | עמודת תאריך לבדיקה |
| days_to_retain | 365 | שמירת שנה של נתונים |
| use_where_clause | 1 | שימוש בסינון מבוסס אינדקס |
| commit_count | 1000 | Commit כל 1000 מחיקות |
| purge_enabled | 1 | הפעלת מחיקה |

---

## התנהגות תפעולית

### עדיפות ותחרות

על פי הקוד ב-`ShrinkPharm.c:121-125`:

```c
// עבור ShrinkPharm, אנחנו רוצים זמן קצוב ארוך יחסית (כך שנהיה די
// סבלניים) ועדיפות deadlock מתחת לרגיל (מכיוון שאנחנו רוצים
// להעדיף פעולות אפליקציה בזמן-אמת על פני תחזוקה).
LOCK_TIMEOUT        = 1000;  // מילישניות.
DEADLOCK_PRIORITY   = -2;    // 0 = רגיל, -10 עד 10 = נמוך עד גבוה.
```

ShrinkPharm מתוכנן ל:
- המתנה סבלנית לנעילות (זמן קצוב שנייה אחת)
- ויתור לפעולות זמן-אמת במצבי deadlock
- הימנעות משיבוש פעולות מסד נתונים רגילות

### זיהוי ייצור לעומת בדיקה

על פי הקוד ב-`ShrinkPharm.c:79-89`:

התוכנית מזהה סביבות בדיקה לפי שם מארח:
- linux01-test
- linux01-qa
- pharmlinux-test
- pharmlinux-qa

אם רץ על מארח בדיקה, `TikrotProductionMode` מוגדר ל-0.

---

## רישום וניטור

### מיקום קובץ יומן

על פי הקוד ב-`ShrinkPharm.c:72-73`:

- ספרייה: משתנה סביבה `MAC_LOG`
- שם קובץ: "ShrinkPharm_log"

### הודעות יומן

| אירוע | מיקום הודעה | תוכן |
|-------|-------------|------|
| התחלה | שורה 75-77 | "ShrinkPharm.exe started [date] at [time]" |
| התחלת טבלה | שורה 191 | "Purge from [table] where [column] < [date]..." |
| ספירה מחושבת | שורה 201 | "[N] rows to delete, SQLCODE = [code]" |
| סיום טבלה | שורה 315-316 | "Purged [N] rows with [column] < [date] from [table]" |
| סיום ריצה | שורות 354-356 | סה"כ שורות, משך, קצב |

### סטטיסטיקות מחושבות

על פי הקוד ב-`ShrinkPharm.c:330-351`:

| מדד | חישוב |
|-----|-------|
| RunLenMinutes | EndTime - StartTime (עם טיפול בחצות) |
| DeletionsPerMinute | (RowsDeletedFullRun * 60) / RunLenSeconds |

---

## תרחישי שגיאה

### כשל חיבור למסד נתונים

על פי הקוד ב-`ShrinkPharm.c:128-137`:

- ניסיון חוזר כל 10 שניות עד לחיבור
- רישום ניסיונות חוזרים

### שגיאות SQL במהלך עיבוד

על פי הקוד ב-`ShrinkPharm.c:152-155, 168-171`:

- שגיאה גורמת ליציאה מלולאת עיבוד נוכחית
- עבודה חלקית עוברת commit לפני שגיאה (מודל אצוות)

### הפסקה על ידי אות

על פי הקוד ב-`ShrinkPharm.c:370-430`:

| אות | תגובה |
|-----|-------|
| SIGFPE | Rollback, יומן, יציאה |
| SIGSEGV | Rollback, יומן, יציאה |
| SIGTERM | יומן, יציאה (ללא rollback) |

---

## הקשר מערכת בריאות

### קשר לרכיבים אחרים

על בסיס הקשר מחקר:

| רכיב | קשר |
|------|-----|
| FatherProcess | שניהם משתמשים באותו דפוס SQLMD_connect() עם ניסיונות חוזרים; לא מפקח על ShrinkPharm |
| SqlServer | הערות מציינות ShrinkPharm כמתאים ל-ODBC_PRESERVE_CURSORS |
| PharmTcpServer | נראה משתמש באותו מסד נתונים יעד |

### עצמאות תפעולית

נראה כי ShrinkPharm:
- רץ עצמאית מעץ הפיקוח של FatherProcess
- מתחבר ישירות למסד נתונים במקום דרך SqlServer
- מתוזמן חיצונית (cron, מתזמן, או הפעלה ידנית)

---

## סיכום כללי עסקי

על בסיס ניתוח קוד:

1. **מדיניות שמירה:** נתונים ישנים מ-`days_to_retain` ימים נמחקים
2. **מסנן מופעל:** רק שורות שבהן `purge_enabled <> 0` מעובדות
3. **עיבוד באצוות:** Commit-ים מתרחשים כל `commit_count` מחיקות
4. **עדיפות נמוכה:** תחזוקה מוותרת לפעולות זמן-אמת
5. **מעקב סטטיסטיקות:** כל ריצה מתעדת תאריך, שעה וספירה

---

## מגבלות תיעוד

### מה לא ניתן לקבוע מהקוד:

- הטבלאות הספציפיות המוגדרות למחיקה בייצור
- תקופות השמירה וספירות ה-commit בשימוש
- כיצד ומתי הכלי מתוזמן לרוץ
- הצדקה עסקית למדיניות שמירה ספציפית
- קשר עם "ShrinkDoctor" המקורי המוזכר בהערות

### מה ידוע מהקוד:

- האלגוריתם למחיקת שורות מבוססת תאריך
- מודל התצורה (מבנה טבלת בקרה)
- התנהגות Commit באצוות ותיעוד סטטיסטיקות
- הגדרות עדיפות לתחרות במסד נתונים

---

*מסמך נוצר על ידי סוכן המתעד של CIDRA*
*מזהה משימה: DOC-SHRINK-001*
