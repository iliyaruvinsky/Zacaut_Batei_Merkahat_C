# FatherProcess - ניתוח טכני

**רכיב**: FatherProcess
**מזהה משימה**: DOC-FATHER-001
**תאריך יצירה**: 2026-02-02

---

## ניתוח פונקציות

### 1. main() - שורות 146-1469 (1323 שורות)

**מורכבות**: גבוהה מאוד

הפונקציה `main()` היא נקודת הכניסה ומכילה את כל לוגיקת התוכנית. על פי הקוד, ניתן לחלק אותה לחלקים לוגיים:

#### חלק א': אתחול (שורות 146-351)
- הצהרת משתנים מקומיים (שורות 148-208)
- הגדרת דגלי מתארי קבצים דרך `fcntl()` (שורות 219-224)
- הפיכה למנהיג סשן דרך `setsid()` (שורה 227)
- אתחול סביבה דרך `InitEnv()` ו-`HashEnv()` (שורות 230-233)
- התקנת מטפל SIGTERM דרך `sigaction()` (שורות 246-253)
- חיבור למסד נתונים עם לולאת ניסיונות (שורות 262-271)
- טעינת פרמטרים דרך `SqlGetParamsByName()` (שורה 277)
- נעילת דפי זיכרון (אופציונלי) (שורות 281-291)
- הורדת הרשאות דרך `setuid()` (שורות 294-297)
- יצירת נקודת קצה IPC דרך `GetCurrNamedPipe()` ו-`ListenSocketNamed()` (שורות 300-301)
- יצירת סמפור מערכת (שורה 304)
- אתחול זיכרון משותף (שורה 307)
- יצירת טבלאות זיכרון משותף בלולאה (שורות 312-334)
- רישום עצמי בטבלת תהליכים (שורה 351)

#### חלק ב': הגדרת סטטיסטיקות (שורות 352-406)
- יצירת שורת סטטיסטיקות בית מרקחת (`TSTT_DATA`) בזיכרון משותף (שורות 356-381)
- יצירת שורת סטטיסטיקות רופאים (`DSTT_DATA`) בזיכרון משותף (שורות 384-405)
- על פי ההערה בשורה 354, תכונה זו "כבר לא בשימוש אמיתי"

#### חלק ג': הפעלת מערכת (שורות 408-448)
- קריאת משתנה סביבה `MAC_SYS` (שורה 409)
- בניית מפת סיביות `running_system` (שורות 418-436)
- קריאה ל-`run_system()` להפעלת תהליכי בן (שורה 445)

#### חלק ד': לולאת שמירה (שורות 453-1321)
- לולאת ניטור ראשית בשורה 471: `for (shut_down = MAC_FALS; ...)`
- **ניטור סטטוס מערכת** (שורות 496-660):
  - קבלת ספירת בנים דרך `GetSonsCount()` (שורה 499)
  - קבלת סטטוס מערכת דרך `get_sys_status()` (שורה 503)
  - מכונת מצבים למערכת כולה (שורות 509-569)
  - ספירת תהליכי בית מרקחת/רופאים (שורות 575-597)
  - מכונת מצבים לתת-מערכות (שורות 603-660)

- **זיהוי תהליכי בן מתים** (שורות 662-1102):
  - שימוש ב-`waitpid(WNOHANG)` בשורה 673
  - נסיגה ל-`dipr_tablep` אם waitpid מחזיר 0 (שורות 680-698)
  - בדיקת תהליכים יתומים דרך `getpgid()` (שורות 706-754)
  - עיבוד סטטוס יציאה עם switch מפורט (שורות 856-965)
  - הפעלה מחדש של בן דרך `Run_server()` אם התנאים מתקיימים (שורות 1006-1063)

- **טיפול בהודעות IPC** (שורות 1104-1198):
  - קבלת הודעות דרך `GetSocketMessage()` (שורה 1123)
  - טיפול בפקודות בקרה בהצהרת switch (שורות 1127-1197)

- **בקרת מרובי מופעים** (שורות 1200-1320):
  - ניטור מערך `InstanceControl[]`
  - הפעלת מופעים חדשים כאשר הספירה הזמינה יורדת מתחת למינימום

#### חלק ה': כיבוי (שורות 1322-1469)
- איטרציה דרך `proc_tablep` (שורות 1346-1426)
- שליחת SIGTERM לסוגי תהליכים ספציפיים, Signal 9 לאחרים (שורות 1365-1379)
- ניתוק מסד נתונים, סגירת סוקטים, הסרת זיכרון משותף (שורות 1441-1453)
- יציאה עם `MAC_OK` (שורה 1464)

---

### 2. sql_dbparam_into_shm() - שורות 1481-1597 (116 שורות)

**מורכבות**: בינונית

**מטרה**: טעינת פרמטרים מטבלת `setup_new` במסד הנתונים לטבלת הפרמטרים בזיכרון המשותף.

**פעולות מרכזיות**:
1. מחיקת תוכן טבלה קיים בטעינה מחדש (אופציונלי) (שורה 1498)
2. הצהרת סמן `FP_setup_cur` לשימוש ראשון (שורות 1503-1508)
3. פתיחת סמן ושליפת שורות בלולאה (שורות 1516-1560)
4. בניית מפתח פרמטר כ-`program_name.param_name` (שורה 1546)
5. הוספת כל שורה לזיכרון משותף דרך `AddItem()` (שורה 1550)
6. הוספת UID, שם משתמש, סיסמה ושם DB לזיכרון משותף (שורות 1576-1590)
7. הגדלת מספר גרסת הפרמטרים ב-`stat_tablep` (שורה 1593)

**לוגיקת ניסיונות חוזרים**: על פי שורות 1512-1567, כולל לולאת ניסיונות עם השהיית `ACCESS_CONFLICT_SLEEP_TIME` בקונפליקט SQL.

---

### 3. SqlGetParamsByName() - שורות 1608-1757 (149 שורות)

**מורכבות**: בינונית

**מטרה**: אחזור פרמטרים ממסד הנתונים לפי שם תוכנית ומילוי מערך `InstanceControl[]`.

**פעולות מרכזיות**:
1. הצהרת סמן `FP_params_cur` (שורות 1623-1624)
2. איפוס דגלי "touched" לכל הפרמטרים (שורות 1627-1630)
3. פתיחת סמן ושליפת שורות (שורות 1638-1720)
4. לסוגי תוכניות תקינים, מילוי `InstanceControl[]` (שורות 1668-1683)
5. התאמת פרמטרים למערך `prog_params` (שורות 1686-1718)
6. המרת ערכים על בסיס סוג: `PAR_INT`, `PAR_LONG`, `PAR_DOUBLE`, `PAR_CHAR` (שורות 1692-1708)
7. אימות שכל הפרמטרים הנדרשים נמצאו (שורות 1742-1752)

---

### 4. run_system() - שורות 1766-1884 (118 שורות)

**מורכבות**: בינונית

**מטרה**: הפעלת תהליכי בן על בסיס פרמטרים בזיכרון משותף.

**פעולות מרכזיות**:
1. פתיחת `PARM_TABLE` (שורה 1789)
2. לולאה דרך פרמטרים לחיפוש רשומות "Program..." (שורה 1794)
3. לכל תוכנית:
   - קבלת פרמטר "system" שלה (שורה 1804)
   - בדיקה אם מתאימה לתת-מערכת המבוקשת (שורות 1816-1819)
   - מציאת רשומת `InstanceControl[]` מתאימה (שורות 1830-1838)
   - הפעלת `startup_instances` עותקים דרך `Run_server()` (שורות 1851-1877)
4. סגירת טבלה וחזרה (שורה 1881)

---

### 5. GetProgParm() - שורות 1893-1926 (33 שורות)

**מורכבות**: נמוכה

**מטרה**: חיפוש ערך פרמטר בודד לתוכנית מהזיכרון המשותף.

**פעולות מרכזיות**:
1. פתיחת `PARM_TABLE` (שורה 1902)
2. בניית מפתח חיפוש כ-`prog_name.param_name` (שורה 1904)
3. לולאה דרך הטבלה באמצעות `ActItems()` (שורה 1908)
4. החזרת `par_val` מתאים (שורה 1918)
5. סגירת טבלה (שורה 1923)

---

### 6. TerminateHandler() - שורות 1937-1972 (35 שורות)

**מורכבות**: נמוכה

**מטרה**: מטפל אותות עבור אותות סיום (SIGTERM, SIGFPE, SIGSEGV).

**פעולות מרכזיות**:
1. איפוס טיפול באותות דרך `sigaction()` (שורה 1943)
2. הגדרת משתנה גלובלי `caught_signal` (שורה 1948)
3. הפקת הודעת יומן תיאורית על בסיס סוג האות (שורות 1951-1968)
4. רישום הודעת כיבוי דרך `GerrLogMini()` (שורות 1970-1971)

---

## מבני נתונים

### מבנים מקומיים בשימוש (מ-Global.h)

| מבנה | משמש ב | מטרה |
|------|--------|------|
| TABLE_DATA | שורה 192 | מטאדטה של טבלת זיכרון משותף |
| PROC_DATA | שורה 193 | שורת רישום תהליכים |
| DIPR_DATA | שורה 194 | שורת תהליך שמת |
| STAT_DATA | שורה 195 | שורת סטטוס מערכת |
| TSTT_DATA | שורה 196 | שורת סטטיסטיקות בית מרקחת |
| DSTT_DATA | שורה 197 | שורת סטטיסטיקות רופאים |
| UPDT_DATA | שורה 198 | שורת חותמת זמן עדכון טבלה |
| TInstanceControl | שורה 199 | בקרת מרובי מופעים |

### מערך TInstanceControl

על פי שורה 122 ושימוש לאורך הקוד:
```c
TInstanceControl InstanceControl [MAX_PROC_TYPE_USED + 1];
```

שדות (מ-Global.h):
- `ProgramName` - שם קובץ ההרצה
- `program_type` - קבוע סוג תהליך
- `program_system` - PHARM_SYS או DOCTOR_SYS
- `instance_control` - דגל: האם מרובי מופעים מופעל
- `startup_instances` - כמה להפעיל בהתחלה
- `max_instances` - מקסימום מופעים מותר
- `min_free_instances` - מינימום מופעים זמינים
- `instances_running` - ספירה נוכחית

---

## זרימת בקרה

### מבנה לולאת השמירה הראשית

```c
for (shut_down = MAC_FALS; (shut_down == MAC_FALS) && (!caught_signal); )
{
    // 1. קבלת סטטוס מערכת
    GetSonsCount (&sons);
    get_sys_status (&stat_data);

    // 2. טיפול במכונת מצבים של מערכת כולה
    switch (stat_data.status) { ... }

    // 3. ספירת תהליכי תת-מערכות
    // 4. טיפול במכונות מצבים של תת-מערכות

    // 5. בדיקת תהליכי בן מתים
    son_pid = waitpid ((pid_t) -1, &status, WNOHANG);
    if (son_pid > 0) {
        // עיבוד מוות, אולי הפעלה מחדש
    }

    // 6. בדיקת הודעות IPC
    state = GetSocketMessage (...);
    if ((state == MAC_OK) && (len > 0)) {
        switch (ListNMatch (buf, PcMessages)) { ... }
    }

    // 7. ניהול תוכניות מרובות מופעים
    for (ProgramType = 0; ProgramType <= MAX_PROC_TYPE_USED; ProgramType++) {
        // בדיקה אם צריך יותר מופעים
    }
}
```

### דפוס ניסיונות חוזרים למסד נתונים

על פי שורות 1512-1567 (`sql_dbparam_into_shm`) ושורות 1633-1732 (`SqlGetParamsByName`):

```c
for (restart = MAC_TRUE, tries = 0;
     (tries < SQL_UPDATE_RETRIES) && (restart == MAC_TRUE);
     tries++)
{
    restart = MAC_FALS;

    do {
        OpenCursor (...);
        Conflict_Test_Cur (restart);  // מגדיר restart=TRUE בקונפליקט
        BREAK_ON_ERR (...);

        while (1) {
            FetchCursor (...);
            Conflict_Test (restart);
            BREAK_ON_TRUE (SQLERR_code_cmp (SQLERR_end_of_fetch));
            // עיבוד שורה
        }

        CloseCursor (...);
    } while (0);

    if (restart == MAC_TRUE) {
        sleep (ACCESS_CONFLICT_SLEEP_TIME);
    }
}
```

---

## טיפול בשגיאות

### מאקרואים לטיפול בשגיאות

על פי דפוסי הקוד שנצפו:

| מאקרו | התנהגות |
|-------|---------|
| ABORT_ON_ERR | מסיים תוכנית בשגיאה |
| BREAK_ON_ERR | יוצא מלולאה בשגיאה |
| RETURN_ON_ERR | חוזר מפונקציה בשגיאה |
| BREAK_ON_TRUE | יוצא אם תנאי אמת |
| ERR_STATE | בודק אם מצב מציין שגיאה |

### רישום יומן

רישום שגיאות משתמש ב-`GerrLogMini()` לאורך הקוד, עם הדפוס:
```c
GerrLogMini (GerrId, "הודעה עם %s מחזיקי מקום", ערכים);
```

דוגמאות:
- שורה 223: `"fcntl failed " GerrErr, GerrStr`
- שורה 268: `"Retrying %s ODBC connect.", MAIN_DB->Name`
- שורה 567: `"FatherProcess: unknown system state %d.", stat_data.status`

---

## קריאות פונקציות חיצוניות

### מ-GenLib

| פונקציה | מיקום | מטרה |
|---------|-------|------|
| InitEnv | 230 | אתחול מאגרי סביבה |
| HashEnv | 233 | גיבוב משתני סביבה |
| GetCurrProgName | 236 | קבלת שם תוכנית קצר |
| GetCurrNamedPipe | 300 | בניית נתיב named pipe |
| ListenSocketNamed | 301 | יצירת סוקט האזנה |
| CreateSemaphore | 304 | יצירת סמפור מערכת |
| InitFirstExtent | 307 | אתחול זיכרון משותף |
| CreateTable | 315 | יצירת טבלת זיכרון משותף |
| AddItem | 327, 345, 381, 405, 550, 578 | הוספת שורה לטבלה |
| DeleteItem | 690, 798 | מחיקת שורה מטבלה |
| ActItems | 577, 680, 729, 791 וכו' | איטרציה דרך טבלה |
| RewindTable | 575, 727, 1235, 1346 | איפוס איטרציה בטבלה |
| OpenTable | 789, 902 | פתיחת טבלת זיכרון משותף |
| CloseTable | 881, 923 | סגירת טבלת זיכרון משותף |
| GetSonsCount | 499, 1335 | קבלת ספירת תהליכי בן |
| AddToSonsCount | 787, 948 | התאמת ספירת בנים |
| Run_server | 1041, 1300, 1858 | הפעלת תהליך בן |
| AddCurrProc | 351 | רישום בטבלת תהליכים |
| DisposeSockets | 1444 | סגירת סוקטים |
| KillAllExtents | 1447 | הסרת זיכרון משותף |
| DeleteSemaphore | 1453 | מחיקת סמפור |
| GetSocketMessage | 1123 | קבלת הודעת IPC |
| GerrLogMini | רבים | רישום הודעה ביומן |

### מ-GenSql

| פונקציה | מיקום | מטרה |
|---------|-------|------|
| SQLMD_connect | 264 | חיבור למסד נתונים |
| SQLMD_disconnect | 1441 | ניתוק ממסד נתונים |
| DeclareCursor | 1623 | הצהרת סמן SQL |
| DeclareCursorInto | 1505 | הצהרת סמן עם INTO |
| OpenCursor | 1518, 1638 | פתיחת סמן |
| FetchCursor | 1527 | שליפת שורה |
| FetchCursorInto | 1649 | שליפת שורה למשתנים |
| CloseCursor | 1553, 1723 | סגירת סמן |
| SQLERR_code_cmp | 1533, 1657 | השוואת קוד שגיאה |
| SQLERR_error_test | 1522, 1534, 1660 | בדיקת שגיאת SQL |

### מהמערכת

| פונקציה | מיקום | מטרה |
|---------|-------|------|
| fcntl | 219-221 | הגדרת דגלי מתאר קבצים |
| setsid | 227 | הפיכה למנהיג סשן |
| sigaction | 250, 1943 | התקנת מטפל אותות |
| sleep | 267, 1564, 1729 | השהיית ביצוע |
| mlockall/plock | 284-286 | נעילת דפי זיכרון |
| setuid | 294 | שינוי מזהה משתמש |
| time | 358, 781 וכו' | קבלת זמן נוכחי |
| localtime | 782 | המרת זמן |
| waitpid | 673 | בדיקת תהליכי בן שהסתיימו |
| getpgid | 742 | קבלת מזהה קבוצת תהליכים |
| kill | 1379 | שליחת אות לתהליך |
| access | 801, 1382 | בדיקת קיום קובץ |
| unlink | 803, 1384 | הסרת קובץ |
| getenv | 409 | קבלת משתנה סביבה |
| usleep | 1452 | שינה במיקרו-שניות |
| exit/_exit | 1464-1467 | סיום תוכנית |

---

## שיקולי ביצועים

### תזמון לולאת השמירה

על פי ההערה בשורות 1111-1121, קריאת `GetSocketMessage()` משתמשת בהשהייה של 500000 מיקרו-שניות (0.5 שניה), שקובעת את קצב איטרציית הלולאה הראשית:

```c
state = GetSocketMessage (500000, buf, sizeof (buf), &len, CLOSE_SOCKET);
```

ההערה מציינת שזה שונה מערך `SelectWait` המקורי (200000 = 0.2 שניות) כדי להפחית עומס CPU.

### ניטור מרובי מופעים

בשורות 1213-1320, הלולאה בודקת כל סוג תוכנית בכל איטרציה של לולאת השמירה. עבור תוכניות עם `instance_control` מופעל, היא:
1. סורקת את כל `proc_tablep` לספירת מופעים פועלים/זמינים
2. מפעילה מופעים חדשים אם מתחת למינימום

נראה כי זו פעולת O(n*m) כאשר n = מספר סוגי תוכניות ו-m = מספר תהליכים פועלים.

---

*נוצר על ידי סוכן המתעד של CIDRA - DOC-FATHER-001*
