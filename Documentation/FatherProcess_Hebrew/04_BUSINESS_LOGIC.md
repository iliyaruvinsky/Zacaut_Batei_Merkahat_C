# FatherProcess - לוגיקה עסקית

**רכיב**: FatherProcess
**מזהה משימה**: DOC-FATHER-001
**תאריך יצירה**: 2026-02-02

---

## פיקוח על תהליכים

על פי ניתוח הקוד, נראה כי FatherProcess מיישם מודל פיקוח על תהליכים שבו הוא:

### 1. הפעלת תהליכי בן

בשורה 445, מתבצעת קריאה ל-`run_system()` להפעלת כל תהליכי הבן המוגדרים:
```c
run_system ( PHARM_SYS | DOCTOR_SYS | DOCTOR_SYS_TCP );
```

הפונקציה `run_system()` (שורות 1766-1884):
1. פותחת את טבלת הפרמטרים בזיכרון המשותף (שורה 1789)
2. עוברת על רשומות "Program..." (שורה 1797)
3. בודקת אם התוכנית שייכת לתת-המערכת המבוקשת (שורות 1816-1819)
4. מפעילה את מספר המופעים המוגדר דרך `Run_server()` (שורות 1851-1877)

### 2. ניטור תהליכי בן

לולאת השמירה (שורות 471-1321) מנטרת באופן רציף תהליכי בן באמצעות:

**שיטה ראשית - waitpid()** (שורה 673):
```c
son_pid = waitpid ((pid_t) -1, &status, WNOHANG);
```

**שיטת גיבוי - טבלת תהליכים שמתו** (שורות 680-698):
אם `waitpid()` מחזיר 0, הקוד בודק את `dipr_tablep` עבור הודעות על מוות של תהליכים שייתכן שהגיעו בדרכים אחרות.

**זיהוי תהליכים יתומים** (שורות 706-754):
במהלך כיבוי, משתמש ב-`getpgid()` לזיהוי תהליכים שהסתיימו אך לא נתפסו על ידי `waitpid()`:
```c
if (getpgid (proc_data.pid) == -1)
```

### 3. הפעלה מחדש של תהליכים שנכשלו

על פי שורות 1006-1063, כאשר תהליך בן מת והתנאים מאפשרים:

**תנאים להפעלה מחדש** (שורות 1017-1021):
- התהליך נמצא בטבלת התהליכים (`proc_found == MAC_OK`)
- דגל הפעלה מחדש אמת (`restart == MAC_TRUE`)
- סטטוס המערכת הוא UP (`stat_data.status == SYSTEM_UP`)
- סטטוס תת-המערכת הרלוונטית הוא UP (`relevant_status == SYSTEM_UP`)
- התהליך אינו X.25 worker (ישן, שורה 1021)

**לוגיקת מגבלת ניסיונות** (שורות 1023-1037):
- אם עבר מספיק זמן מאז ההפעלה האחרונה (על בסיס פרמטר `interval`), ספירת הניסיונות מתאפסת
- אם הניסיונות עולים על מגבלת `ProcRetrys`, התהליך לא מופעל מחדש

**פעולת הפעלה מחדש** (שורות 1039-1055):
```c
state = Run_server (&proc_data);
```

---

## מצבי מערכת

על פי שורות 509-569 ו-603-660, המערכת מתחזקת מכונת מצבים עם ארבעה מצבים:

### הגדרות מצבים

| מצב | קבוע | ערך | תיאור |
|-----|------|-----|-------|
| עולה | GOING_UP | 0 | המערכת מאתחלת |
| פועלת | SYSTEM_UP | 1 | המערכת פעילה לחלוטין |
| יורדת | GOING_DOWN | 2 | המערכת נכבית |
| כבויה | SYSTEM_DOWN | 3 | המערכת כבויה לחלוטין |

### לוגיקת מצב מערכת כוללת

**GOING_UP -> SYSTEM_UP** (שורות 511-529):
המעבר מתרחש כאשר `sons > 0` (לפחות תהליך בן אחד פועל):
```c
case GOING_UP:
    if (sons > 0)
    {
        set_sys_status (SYSTEM_UP, 0, 0);
    }
    break;
```

**GOING_DOWN -> SYSTEM_DOWN** (שורות 536-550):
המעבר מתרחש כאשר `sons < 1` (אין תהליכי בן פועלים):
```c
case GOING_DOWN:
    if (sons < 1)
    {
        set_sys_status (SYSTEM_DOWN, 0, 0);
    }
    break;
```

**SYSTEM_DOWN -> יציאה** (שורות 553-562):
כאשר ספירת הבנים מגיעה לאפס, לולאת השמירה מסתיימת:
```c
case SYSTEM_DOWN:
    if (sons < 1)
    {
        shut_down = MAC_TRUE;
        continue;
    }
    break;
```

### לוגיקת מצב לכל תת-מערכת

על פי שורות 603-660, לכל תת-מערכת (בית מרקחת, רופאים) יש מעקב מצבים עצמאי:

**מערכת בית מרקחת** (`stat_data.pharm_status`):
- נספרת דרך `pharm_proc_count` בשורות 575-597
- GOING_UP -> SYSTEM_UP כאשר `pharm_proc_count > 0` (שורות 605-611)
- GOING_DOWN -> SYSTEM_DOWN כאשר `pharm_proc_count < 1` (שורות 613-619)

**מערכת רופאים** (`stat_data.doctor_status`):
- נספרת דרך `doc_proc_count` בשורות 575-597
- GOING_UP -> SYSTEM_UP כאשר `doc_proc_count > 0` (שורות 635-641)
- GOING_DOWN -> SYSTEM_DOWN כאשר `doc_proc_count < 1` (שורות 643-649)

---

## לוגיקת הפעלה מחדש

### טיפול בקודי יציאה

על פי הצהרת switch בשורות 858-965, קודי יציאה שונים מפעילים התנהגויות שונות:

| קוד יציאה | קבוע | הפעלה מחדש | פעולה |
|-----------|------|------------|-------|
| רגיל | MAC_SERV_SHUT_DOWN | לא | ללא רישום |
| כיבוי מערכת | MAC_SYST_SHUT_DOWN | לא | הגדרת מערכת ל-GOING_DOWN |
| שגיאת זיכרון | MAC_EXIT_NO_MEM | כן | רישום והפעלה מחדש |
| שגיאת SQL | MAC_EXIT_SQL_ERR | כן | רישום והפעלה מחדש |
| שגיאת חיבור SQL | MAC_EXIT_SQL_CONNECT | כן | רישום והפעלה מחדש |
| שגיאת מערכת | MAC_EXIT_SELECT | כן | רישום והפעלה מחדש |
| שגיאת רשת | MAC_EXIT_TCP | כן | רישום והפעלה מחדש |
| אות נלכד | MAC_EXIT_SIGNAL | כן | הפחתת ניסיונות, רישום והפעלה מחדש |
| לא הופעל | MAC_CHILD_NOT_STARTED | לא | הגדלת ספירת בנים |
| איפוס שרת | MAC_SERV_RESET | כן | הפחתת ניסיונות, רישום והפעלה מחדש |

### סיום מבוסס אות

**נעצר על ידי אות** (שורות 971-975):
```c
if (WIFSTOPPED (status))
{
    restart = MAC_FALS;  // לא להפעיל מחדש
}
```

**נהרג על ידי אות** (שורות 977-992):
```c
if (WIFSIGNALED (status))
{
    proc_data.retrys--;
    restart = MAC_TRUE;  // כן להפעיל מחדש
}
```

### איפוס מרווח ניסיונות

על פי שורות 1023-1031, אם תהליך פעל זמן ארוך יותר מפרמטר `interval`, ספירת הניסיונות שלו מתאפסת:
```c
if ((cur_time - proc_data.start_time) > interval)
{
    proc_data.retrys = 0;
}
```

---

## הקשר מערכת בריאות

### זיהוי תת-מערכות

על בסיס הקוד בשורות 409-436:

| מערכת | קבוע | מטרה |
|-------|------|------|
| PHARM_SYS | ביט 0 | תת-מערכת בית מרקחת |
| DOCTOR_SYS | ביט 1 | תת-מערכת רופאים |
| DOCTOR_SYS_TCP | ביט 2 | תת-מערכת TCP רופאים |

### משתנה סביבה: MAC_SYS

על פי שורות 409-436, משתנה הסביבה `MAC_SYS` קובע אילו תת-מערכות להפעיל:

```c
system_env = getenv ("MAC_SYS");

running_system = (strstr( system_env, "pharm"       ) ? PHARM_SYS       : 0 ) |
                 (strstr( system_env, "doctor"      ) ? DOCTOR_SYS      : 0 ) |
                 (strstr( system_env, "doc_tcp_only") ? DOCTOR_SYS_TCP  : 0 );
```

**התנהגות ברירת מחדל** (שורות 418-427):
אם `MAC_SYS` לא מוגדר או ריק, ברירת המחדל היא `PHARM_SYS | DOCTOR_SYS` (שתי המערכות).

### סוגי תהליכים

על פי הקוד בשורות 1365-1377, סוגי תהליכים שונים מקבלים אותות כיבוי שונים:

**SIGTERM (הריגה רכה)** - שורות 1367-1373:
- SQLPROC_TYPE (SqlServer.exe)
- AS400TOUNIX_TYPE (As400UnixServer.exe)
- DOCSQLPROC_TYPE (DocSqlServer.exe)
- PURCHASE_HIST_TYPE (PurchaseHistoryServer)

**Signal 9 (הריגה קשה)** - שורה 1375:
- כל שאר סוגי התהליכים

### רישום

בשורה 351, FatherProcess רושם את עצמו בטבלת התהליכים בזיכרון המשותף:
```c
ABORT_ON_ERR (AddCurrProc (0, FATHERPROC_TYPE, 0, PHARM_SYS | DOCTOR_SYS));
```

זה מציין ש-FatherProcess שייך לשתי תת-מערכות בית מרקחת ורופאים.

---

## ניהול מרובי מופעים

על פי שורות 1200-1320, FatherProcess תומך בהפעלת מופעים מרובים של תוכניות מסוימות:

### מקור תצורה

פרמטרי בקרת מופעים נטענים ממסד הנתונים בשורות 1668-1683:
- `program_type` - קבוע סוג תהליך
- `instance_control` - דגל הפעלה (0 = מבוטל)
- `startup_instances` - ספירה התחלתית להפעלה
- `max_instances` - מקסימום מותר
- `min_free_instances` - מינימום זמינים (לא עסוקים)

### ניטור בזמן ריצה

לולאת השמירה (שורות 1213-1320) מנטרת תוכניות מרובות מופעים:

1. **בדיקת תנאים** (שורות 1225-1232):
   - אלמנט מערך אותחל
   - בקרת מופעים מופעלת
   - מוגדרים מספר מופעים
   - מינימום מופעים חופשיים מוגדר
   - תת-מערכת רלוונטית UP

2. **ספירת מופעים** (שורות 1235-1248):
   - סריקת `proc_tablep` עבור `proc_type` מתאים
   - ספירת סה"כ פועלים ומופעים לא עסוקים

3. **הפעלת מופעים חדשים אם צריך** (שורות 1262-1318):
   - אם `nonbusy_count < min_free_instances` וגם `running_count < max_instances`
   - חישוב `NewInstancesToOpen`
   - קריאה ל-`Run_server()` עבור כל מופע חדש

---

## טעינת פרמטרים

### ממסד נתונים לזיכרון משותף

הפונקציה `sql_dbparam_into_shm()` (שורות 1481-1597) טוענת את כל הפרמטרים:

1. משתמשת בסמן `FP_setup_cur` ל-SELECT מטבלת `setup_new`
2. בונה מפתח כ-`program_name.param_name` (שורה 1546)
3. מאחסנת בזיכרון משותף דרך `AddItem()` (שורה 1550)
4. בנוסף מאחסנת הרשאות (שורות 1576-1590):
   - `All.mac_uid`
   - `All.mac_user`
   - `All.mac_pass`
   - `All.mac_db`

### פרמטרים ספציפיים לתוכנית

הפונקציה `SqlGetParamsByName()` (שורות 1608-1757) טוענת פרמטרים עבור FatherProcess ספציפית:

1. משתמשת בסמן `FP_params_cur` ל-SELECT לפי `program_name`
2. מתאימה למערך `prog_params`
3. ממירה ערכים על בסיס סוג (שורות 1692-1708):
   - `PAR_INT` -> `atoi()`
   - `PAR_LONG` -> `atol()`
   - `PAR_DOUBLE` -> `atof()`
   - `PAR_CHAR` -> `strcpy()`

---

## עיבוד פקודות IPC

על פי שורות 1127-1197, פקודות הבקרה הבאות מעובדות:

### LOAD_PAR (שורה 1133)
טוען מחדש פרמטרים ממסד הנתונים:
```c
BREAK_ON_ERR (SqlGetParamsByName (FatherParams, PAR_RELOAD));
BREAK_ON_ERR (sql_dbparam_into_shm (parm_tablep, stat_tablep, PAR_RELOAD));
```

### STRT_PH_ONLY / STRT_DC_ONLY (שורות 1139-1163)
מפעיל תת-מערכת ספציפית:
- בודק אם תת-מערכת כרגע DOWN
- קורא ל-`run_system()` עם הדגל המתאים
- מגדיר סטטוס תת-מערכת ל-GOING_UP

### STDN_PH_ONLY / STDN_DC_ONLY (שורות 1165-1174)
מתחיל כיבוי מסודר של תת-מערכת ספציפית:
- מגדיר סטטוס תת-מערכת ל-GOING_DOWN

### SHUT_DWN (שורות 1176-1184)
מתחיל כיבוי מערכת מלא מסודר:
- מגדיר סטטוס מערכת כוללת ל-GOING_DOWN

### STDN_IMM (שורות 1186-1196)
מתחיל כיבוי מערכת מלא מיידי:
- מגדיר סטטוס מערכת כוללת ל-SYSTEM_DOWN
- מגדיר `shut_down = MAC_TRUE` ליציאה מלולאת השמירה

---

## איסוף סטטיסטיקות

על פי שורות 352-405, FatherProcess יוצר שורות סטטיסטיקות בזיכרון משותף:

### סטטיסטיקות בית מרקחת (TSTT_DATA)

נוצר בשורות 356-381:
- `start_time` - חותמת זמן תחילת מערכת
- `last_time[][]` - חותמות זמן לכל הודעה עבור מרווחים שונים
- `time_count[][]` - מוני הודעות

**הערה**: על פי ההערה בשורות 354-370, תכונה זו "כבר לא בשימוש אמיתי" ורשימת `PharmMessages` לא מעודכנת.

### סטטיסטיקות רופאים (DSTT_DATA)

נוצר בשורות 384-405:
- מבנה זהה לסטטיסטיקות בית מרקחת
- משתמש במערך `DoctorMessages`

---

## שיקולי אבטחה

### הורדת הרשאות

על פי שורות 294-297, התהליך יורד למשתמש ללא הרשאות לאחר אתחול:
```c
if (setuid (atoi (MacUid)))
{
    GerrLogMini (GerrId, "Can't setuid to %d - error (%d) %s.", atoi (MacUid), GerrStr);
}
```

### אחסון הרשאות

על פי שורות 1576-1590, הרשאות מסד נתונים מאוחסנות בזיכרון משותף:
- `All.mac_uid` - מזהה משתמש
- `All.mac_user` - שם משתמש
- `All.mac_pass` - סיסמה (מאוחסנת בזיכרון משותף - ראה הערות אבטחה ב-RESEARCH/)
- `All.mac_db` - שם מסד נתונים

**הערת אבטחה**: כמתועד ב-`RESEARCH/context_summary.md`, קיימים ערכים סודיים מקודדים קשיחות ב-`TikrotRPC.h` ו-`global_1.h`. מיקומים אלה מתועדים אך הערכים אינם מועתקים.

---

*נוצר על ידי סוכן המתעד של CIDRA - DOC-FATHER-001*
