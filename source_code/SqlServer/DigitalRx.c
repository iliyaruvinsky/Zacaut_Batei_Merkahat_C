/*=======================================================================
||																		||
||				DigitalRx.c												||
||																		||
||======================================================================||
||																		||
||  PURPOSE:															||
||																		||
||  Digital-Prescription-related functions, split off from 				||
||  ElectronicPr.ec to shorten the file.								||
||																		||
||----------------------------------------------------------------------||
|| PROJECT:	SqlServer. (for macabi)										||
||----------------------------------------------------------------------||
 =======================================================================*/


// Include files.
//#include "GenSql.h";
#include <MacODBC.h>
#include "MsgHndlr.h"
#include "PharmacyErrors.h"
#include "MessageFuncs.h"		// DonR 26Aug2003: Function prototypes.
#include "TikrotRPC.h"
#include "As400UnixMediator.h"


static char *GerrSource = __FILE__;

extern TDrugsBuf	v_DrugsBuf;				// DonR 16Feb2006 - made drugs-in-blood global.
extern short		Form29gMessagesEnabled;	// DonR 21Oct2015 TEMPORARY (sort of).
extern int			MinimumNormalMemberTZ;	// DonR 29Jun2020 CR #28453.

/*=======================================================================
||			    Local declarations										||
 =======================================================================*/

// DonR 03Jul2022: Do not call SQLERR_error_test() unless we're on at least
// the third attempt to perform a transaction; there's no point in writing
// excessive data-conflict messages to the log, and that's the only thing
// SQLERR_error_test() does here. (Remember that for the first attempt,
// tries = 0; so "tries > 1" means "at least the third attempt".)
#define Conflict_Test(r)									\
if (SQLERR_code_cmp (SQLERR_access_conflict) == MAC_TRUE)	\
{															\
	if (tries > 1)											\
		SQLERR_error_test ();								\
	r = MAC_TRUE;											\
	break;													\
}

// DonR 20Apr2023 User Story #432608: Change criteria for pharmacy types, and add a new
// pharmacy type for "Maccabi (Hishtatfut) Type". The changes are as follows:
// 1) Maccabi_pharmacy is now based on "owner == 0" instead of Permission Type - so it
//    includes only "genuine" Maccabi pharmacies.
// 2) Private_pharmacy is now based on "owner != 0" instead of Permission Type.
// 3) As a result of these two changes, non-hesder pharmacies are now "officially"
//    private as opposed to Maccabi - but this should be irrelevant, since these pharmacies
//    are allowed to sell stuff only via x005-spooled transactions, with no calculation of
//    participation or all the other normal logic.
// 4) There is a new ConsignmentPharmacy flag that's read directly from the database.
// 5) There is a new MaccabiPtnPharmacy flag that's set based on "permission == 1"; it's
//    basically the same as maccabi_pharmacy used to be, but it will include the "consignatzia"
//    pharmacies which will also have permission == 1. This flag will be used for "hishtatfut"
//    and anything else where we're interested in the "hishtatfut" and related calculations,
//    rather than the legal/administrative differences between Maccabi and private pharmacies.
#define MACCABI_PHARMACY		(Phrm_info.maccabi_pharmacy)	    
#define PRIVATE_PHARMACY		(Phrm_info.private_pharmacy)	    
#define PRATI_PLUS_PHARMACY		(Phrm_info.prati_plus_pharmacy)
#define MACCABI_PTN_PHARMACY	(Phrm_info.MaccabiPtnPharmacy)									// DonR 23Apr2023 User Story #432608.
#define CONSIGNMENT_PHARMACY	(Phrm_info.ConsignmentPharmacy)									// DonR 23Apr2023 User Story #432608.
#define	CAN_SELL_FUTURE_RX		(Phrm_info.can_sell_future_rx)
#define HESDER_MACCABI			(Phrm_info.has_hesder_maccabi)
#define PHARM_LEGAL_FOR_TRN		(Phrm_info.found_and_legal)
#define PHARM_NOHAL_ENABLED		(Phrm_info.PharmNohalEnabled)									// DonR 23Apr2023 User Story #432608.
#define MACCABICARE_PHARM		(Phrm_info.maccabicare_pharm)									// DonR 23Apr2023 User Story #432608.
#define CONSIGNMENT_ITEM		8																// DonR 23Apr2023 User Story #432608 - Check that 8 is correct!
#define CONSIGNMENT_SALE(DRUG)	(Phrm_info.ConsignmentPharmacy && (DRUG.ConsignmentItem == 8))	// DonR 23Apr2023 User Story #432608 - Check that 8 is correct!
#define CANNABIS_PHARMACY		(Phrm_info.can_sell_cannabis)									// DonR 29Jan2024 User Story #540234.

#define DARKONAI	9

// DonR 15Jan2014: New conditions for calling "Meishar" for private pharmacies: we now use
// a per-pharmacy flag rather than the more general "prati plus" flag, and we enable calling
// Meishar from a private pharmacy only if the member has used his/her magnetic card.
// Note that the global "PPlusMeisharEnabled" flag (from sysparams/enablepplusmeishar) must
// also be set to enable private-pharmacy transactions to call Meishar.
// DonR 07Sep2015: Per Iris Shaya, removed the member-passed-card and Maccabi Doctor prescription criteria.
//#define	MEISHAR_PHARMACY	(Phrm_info.maccabi_pharmacy || (Phrm_info.meishar_enabled	&&	\
//															PPlusMeisharEnabled			&&	\
//															(v_MoveCard > 0)			&&	\
//															(v_MoveCard < 9999)			&&	\
//															(SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR)))
#define	MEISHAR_PHARMACY	(Phrm_info.maccabi_pharmacy || (Phrm_info.meishar_enabled && PPlusMeisharEnabled))



// DonR 09Jan2012: To replace some repetitive code, set up a macro to indicate a non-discounted sale.
// Note that this logic recognizes that the "Meishar" application can assign a fixed price of zero.
// DonR 12Jun2012: Added a further macro, adding a condition that an AS/400 ishur is *not* being used.
// This new macro, FULL_PRICE_NO_ISHUR_ETC, is used to decide whether to send various discount-available
// warnings. (Note that in Trn. 2003 we still have to test for no-error, since discount-available
// warnings are lower-priority than most other warnings.)
#define FULL_PRICE_SALE(i)	((SPres[i].RetPartCode				== 1)					&&	\
							 (SPres[i].PriceSwap				== 0)					&&	\
							 (SPres[i].ret_part_source.table	!= FROM_GADGET_APP))

// DonR 09Aug2021 User Story #163882: Another condition for *not* giving "discount possible" messages is where
// the person buying drugs is a "darkonai-plus" who is not subject to any discounts other than "shovarim"
// provided by his/her insurance company. The relevant flag is Member.force_100_percent_ptn.
// DonR 17Oct2021 User Story #196891: Add per-drug blocking as a reason *not* to give "discount possible" messages.
#define FULL_PRICE_NO_ISHUR_ETC(i)	((SPres[i].RetPartCode				== 1)							&&	\
									 (SPres[i].PriceSwap				== 0)							&&	\
									 (SPres[i].ret_part_source.table	!= FROM_GADGET_APP)				&&	\
									 (SPres[i].ret_part_source.table	!= FROM_SPEC_PRESCS_TBL)		&&	\
									 (SPres[i].DFatalErr				== 0)							&&	\
									 (v_IdentificationCode				!= 3) /* Not Kishon diver */	&&	\
									 (Member.force_100_percent_ptn		== 0) /* Not a Darkonai+  */	&&	\
									 (SPres[i].LargoBlockedForMember	== 0) /* Item not blocked */	&&	\
									 (SPres[i].PrescSource				!= RECIP_SRC_NO_PRESC)			&&	\
									 (SPres[i].PrescSource				!= RECIP_SRC_EMERGENCY_NO_RX))


// DonR 10Apr2013: Macro to tell us if member used a magnetic card - "real" or temporary.
// DonR 05Jul2020 CR #32984: 9998 is *not* a real card date!
#define MEMBER_USED_MAG_CARD	((v_MoveCard > 0) && (v_MoveCard < 9998))

// DonR 05Apr2017 CR #11541: Macro to tell us if member used a *current* magnetic card - "real" or temporary.
// DonR 05Jul2020 CR #32984: 9998 is *not* a real card date!
#define MEMBER_USED_CURRENT_MAG_CARD	((v_MoveCard > 0) && (v_MoveCard < 9998) && (!SetErrorVarExists (ERR_CARD_EXPIRED, 0)) && (!SetErrorVarExists (WARN_CARD_EXPIRED, 0)))


// DonR 04Dec2014: Macro to identify members entitled to 100% discount - either for all
// drugs, or based on a match between member and drug illness bitmaps.
// DonR 30Dec2014: Serious illnesses now require Code 7 or 17 to give 100% discounts; if there are no
// serious-illness codes, the discount applies across the board.
//#define GETS_100PCT_DISCOUNT(DRUG)	(((Member.maccabi_code == 7)	|| (Member.maccabi_code == 17)) &&	\
//									 ((!Member.illness_bitmap)		|| (Member.illness_bitmap & DRUG.illness_bitmap)))

// DonR 02Oct2018 CR #13262: Add new macros to identify member-disease matches that do and do not
// require a specific diagnosis code to grant discounts.
// DonR 13May2020 CR #31591: Add "IllnessDiscounts" flag to these two macros, so discounts will be given
// only for those Largo Types specified in Sysparams/sick_disc_4_types.
#define GETS_100PCT_DISCOUNT_WITHOUT_DIAGNOSIS(DRUG)	((( Member.maccabi_code == 7)	|| (Member.maccabi_code == 17))								&&	\
														 (	DRUG.IllnessDiscounts	)																&&	\
														 ((!Member.illness_bitmap)																||		\
														  ( Member.illness_bitmap & DRUG.illness_bitmap & DiseasesWithoutDiagnosesBitmap)		||		\
														  ((Member.illness_bitmap & DRUG.illness_bitmap)	 && (!DRUG.has_diagnoses))))

#define GETS_100PCT_DISCOUNT_WITH_DIAGNOSIS(DRUG)	(((	Member.maccabi_code == 7)	|| (Member.maccabi_code == 17))								&&	\
													 (	DRUG.IllnessDiscounts	)																&&	\
													 (	DRUG.has_diagnoses		)																&&	\
													 (	Member.illness_bitmap & DRUG.illness_bitmap & DiseasesWithDiagnosesBitmap)	)



// DonR 01Dec2016: Under the new Bakara Kamutit logic, some purchase limits can exclude members who
// have illnesses relevant to the drug being bought from limit checking. This applies only to
// actual diseases, not to accidents.
// DonR 29Jul2025 User Story #435969: Add new conditions for people in home-hospice care.
// For these members, don't bother looking at Maccabi Code.
#define EXEMPT_FROM_LIMIT	(																						\
								(	((Member.maccabi_code == 7)	|| (Member.maccabi_code == 17))					&&	\
									(SPres[i].PurchaseLimitExemptDisease > 0)									&&	\
									(Member.illness_bitmap & SPres[i].DL.illness_bitmap & ActualDiseaseBitmap)		\
								)																					\
								||																					\
								(																					\
									(SPres[i].PurchaseLimitExemptDisease == 2)									&&	\
									((Member.dangerous_drug_status == 1) || (Member.dangerous_drug_status == 2))	\
								)																					\
							)

// DonR 29Dec2014: Macro to identify members who have some form of discount - either  100% or
// some other percentage across-the-board, or else one or more specific illnesses for which
// they get a full discount on relevant drugs.
// DonR 30Dec2014: Serious-illness codes are no longer an independent source of discounts - they
// function only as an (optional) qualifier to the effect of Codes 7 and 17.
// DonR 13May2020 CR #31591: Add new VentilatorDiscount flag as a new way member can get a discount.
// Marianna 24Mar2022 Epic 232192: add darkonai type and mem_id_extension to give Harel Foreign workers discounts.
//#define MEMBER_GETS_DISCOUNTS		((Member.maccabi_code == 7) || (Member.maccabi_code == 17) || (Member.discount_percent > 0) || (Member.VentilatorDiscount))
#define MEMBER_GETS_DISCOUNTS		(	((Member.darkonai_type		==  2) && (Member.mem_id_extension == DARKONAI))	||	\
										( Member.maccabi_code		==  7)												||	\
										( Member.maccabi_code		== 17)												||	\
										( Member.discount_percent	>   0)												||	\
										( Member.VentilatorDiscount)															)

// DonR 28Mar2016: Macro to identify situations where discounts can be granted even if the drug in question is not in the
// health basket. The relevant illness codes are set up in the new illness_codes table.
// DonR 02Jun2016: We want to ignore the Health Basket requirement only for drugs that have at least one
// "nohal automati" (either a regular drug_extension rule or a specialist rule from spclty_largo_prcnt)
// that uses supplemental health insurance - regardless of whether the rule in question applies to the
// member buying drugs.
#define IGNORE_HEALTH_BASKET(DRUG)	((Member.illness_bitmap & DRUG.illness_bitmap & BypassHealthBasketBitmap) && (DRUG.has_shaban_rules))


// DonR 10Feb2015: Macros to test whether a particular prescription source exists in a Trn. 6003 sale request.
#define RX_SOURCE_IN_REQUEST(SourceTest)	(rx_source_found (&SPres[0], v_NumOfDrugLinesRecs, SourceTest, -9999, 1))

#define RX_SOURCE_OTHER_THAN(SourceTest)	(rx_source_found (&SPres[0], v_NumOfDrugLinesRecs, SourceTest, -9999, 2))

#define EITHER_RX_SOURCE_IN_REQUEST(SourceTest1,SourceTest2)	(rx_source_found (&SPres[0], v_NumOfDrugLinesRecs, SourceTest1, SourceTest2, 1))

#define RX_SOURCE_OTHER_THAN_EITHER(SourceTest1,SourceTest2)	(rx_source_found (&SPres[0], v_NumOfDrugLinesRecs, SourceTest1, SourceTest2, 2))



char *PosInBuff;
static int  nOut;


#define	NO_MAX_LARGO	9999999

// DonR 09Sep2009: Added global SQL variables for identifying "visible" drugs.
static short	drug_deleted		= DRUG_DELETED;
static short	pharmacy_assuta		= PHARMACY_ASSUTA;
static short	assuta_drug_active	= ASSUTA_DRUG_ACTIVE;
static short	assuta_drug_past	= ASSUTA_DRUG_PAST;

extern int		ExpensiveDrugMacDocRx;			// DonR 23Jun2024 User Story #318200. Value comes from sysparams/ExpensiveDrugMacDocRx.
extern int		ExpensiveDrugNotMacDocRx;		// DonR 23Jun2024 User Story #318200. Value comes from sysparams/ExpensiveDrugNotMacDocRx.
extern short	min_refill_days;				// DonR 17Jan2006. Values come from sysparams table, read by SqlServer.c.
extern int		OverseasMaxSaleAmt;				// DonR 12Mar2012 - also from sysparams.
extern short	SaleOK_EarlyDays;				// DonR 01Nov2017 - also from sysparams.
extern short	SaleOK_LateDays;				// DonR 25Feb2015 - also from sysparams.
extern short	NihulTikrotLargoLen;			// DonR 30Jul2024 User Story #338533.
extern short	MaxShortDurationDays;			// DonR 25Nov2024 User Story #366220.
extern short	MaxShortDurationOverlapDays;	// DonR 25Nov2024 User Story #366220.
extern short	MaxLongDurationOverlapDays;		// DonR 25Nov2024 User Story #366220.

// DonR 23Aug2011: Factor to calculate prices for VAT-exempt (Eilat) pharmacies.
extern double no_vat_multiplier;


#define	NO_ERROR 				   0
#define	ERR_DATABASE_ERROR 		3010


int	process_spools					(void);
int	init_package_size_array			(void);
int	SALE_compare					(const void *data1, const void *data2);
int	DRUG_compare					(const void *data1, const void *data2);


#define GADGET_NONE		0
#define GADGET_RIGHT	1
#define GADGET_LEFT		2


static short	pkg_size [100000];
static int		pkg_size_asof_date	= 0;
static int		pkg_size_asof_time	= 0;


// Electronic Prescription functions.

// These need to be replaced with configuration-table entries!
#define PRESCR_VALID_DAYS			75	// WORKINGPOINT: CHANGE TO 90-ISH!!!
#define SELECT_PRESC_EARLY_DAYS		75
#define OPEN_PACKAGE_BELOW			1.0		// DonR 29APR2003 - was 0.8 before.



/*=======================================================================
||																		||
||			 HandlerToMsg_6001_6101										||
||	Message handler for message 6001/6101:								||
||			 Digital Prescription Request								||
||			 (including "Chanut Virtualit")								||
||																		||
 =======================================================================*/

int HandlerToMsg_6001_6101 (	int			TransactionID_in,
								char		*IBuffer,
								int			TotalInputLen,
								cJSON		*JSON_MaccabiRequest,
								char		*OBuffer,
								int			*p_outputWritten,
								int			*output_type_flg,
								SSMD_DATA	*ssmd_data_ptr,
								int			*NumProcessed_out	)
{
	// Local declarations.
	int				reStart;
	int				i;
	int				ThisRx;
	int				flg;
	int				err;
	bool			JSON_Mode				= 0;		// DonR 14Apr2021 - Add JSON support.
	bool			OnlineOrder				= 0;		// DonR 03Nov2020 - Added default (BUG FIX!).
	bool			FirstRow				= 1;
	short			FindPref_err			= 0;		// DonR 16Sep2012 - so we don't overwrite v_ErrorCode.
	short			GoodFetch = 0;
	short			DispenseAsWritten;
	short			CurrentVisitSubscript;
	short			DrugAlreadyInList;
	short			SameDrugSameDoctor;
	short			GroupAlreadyInList;
	short			NumDoctorVisits			= 0;
	short			NumInstrLines			= 0;
	short			DigitalStatus			= 0;
	short			ForceCardExpiredErr		= 0;
	short			NumRequestedValid		= 0;
	short			NumRequestedExpired		= 0;
	short			SubtractFromAuditCount	= 0;
	int				LatestVisitDate			= 0;
	char			LatestMemberPhone		[10 + 1];
	char			*DiagBufferOffset;
	char			fileName[256];
	FILE			*outFP;
	ISOLATION_VAR;


	// SQL variables.
	int						TrnID = TransactionID_in;

	// Arrays to hold drugs prescribed data.
	T6001_Drugs				SPres		[MAX_TRN6001_DRUGS];
	T6001_LastRelevantSale	PriorSales	[MAX_TRN6001_DRUGS];
	int						ExtraDrugs	[MAX_TRN6001_DRUGS];

	// DonR 10Dec2025 User Story #441076: Include list of ishur Largo Codes.
	int						IshurLargos				[500];
	int						NumIshurLargos			= 0;

	// Input Message fields.
	cJSON					*JSON_ExtraLargosArray	= NULL;
	cJSON					*JSON_ExtraLargo		= NULL;
	int						v_PharmNum				= 0;
	short					v_InstituteCode			= 0;	// Although in real life it's always 2!
	short					v_TerminalNum			= 0;
	int						Technical_ID			= 0;
	int						v_MemberIdentification	= 0;
	short					v_IdentificationCode	= 0;
	short					v_IdentificationCode_s	= 0;
	short					MemberCardDate			= 0;
	short					PIN_Code				= 0;
	short					RequestType				= 0;
	short					RequestTypeValid		= 1;
	short					ExcludeFullySoldRx		= 0;
	short					SelectEnabled			= 1;
	short					HistoryEnabled			= 1;
	int						v_DoctorPrescID			= 0;
	int						MinDocPrID				= 0;
	int						MaxDocPrID				= 0;
	long					VisitOrOnlineOrderNum	= 0L;
	long					VisitNumber				= 0L;
	long					VisitNumberToAdjust		= 0L;
	char					ReservedInput	[30 + 1];

	// Remote order variables.
	long			online_order_num	= 0L;
	int				OO_member_id;
	short			OO_member_id_code;
	int				OO_made_date;
	int				OO_made_time;
	int				OO_start_work_date;
	int				OO_start_work_time;
	int				OO_min_made_date;
	int				OO_min_work_date;
	int				OO_min_work_time;

	// Drug lines are pulled from DB, not from incoming message.
	short					NumRxFromDB			= 0;
	short					NumExtraLargos		= 0;
	short					NumPriorSales		= 0;
	short					DrugCount			= 0;
	short					FetchComplete		= 0;
	short					ExtraDrugSubscript	= 0;
	int						v_DrugCode;
	int						LargoToDispense;
	int						LargoPrescribed;
	TDrugListRow			GenericDrugRow;
	TDrugListRow			*DL;	// Drug to be sold.
	TDrugListRow			*DP;	// Drug originally prescribed.
	TDoctorPrescRow			*Rx;
	T6001_Drugs				*PL;
	TPrevPurchaseData		PrevPurchase;
	TPrevPurchaseData		*PPD;
	int						UnitsPrescribed;
	int						UnitsToSell;
	int						UnitsAlreadySold;

	// Member, Doctor, Pharmacy, and other response fields.
	PHARMACY_INFO			Phrm_info;
	char					v_MemberFamilyName		[14 + 1];
	char					v_MemberFirstName		[ 8 + 1];
	int						MemberZipCode;
	char					MemberDefaultPhone		[10 + 1];
	char					MemberStreet			[12 + 1];
	char					MemberHouseNum			[ 4 + 1];
	char					MemberCity				[20 + 1];
	char					MemberAddress			[60 + 1];	// 50 should really be enough.
	short					v_SpecPresc;
	short					v_MemberGender;
	int						illness_bitmap;
	int					   	v_TempMembIdentification;
	short					v_TempIdentifCode;
	int						v_TempMemValidUntil;
	int						LastDocID			= -999;			// Initialize to bogus value so zero counts as something new.
	long					LastVisitNumber		= -999L;		// Initialize to bogus value so zero counts as something new.
	int						v_DoctorLicense;					// DonR 07Apr2020 CR#32518 - Coronavirus narcotics enhancement.
	char					v_DocContactPhone		[40 + 1];	// DonR 07Apr2020 CR#32518 - Coronavirus narcotics enhancement.
	char					v_DoctorFamilyName		[14 + 1];
	char					v_DoctorFirstName		[ 8 + 1];
	char					DoctorName				[22 + 1];	// For "Chanut Virtualit".
	char					DoctorPhone				[10 + 1];
	short					DoctorProfCodeToPharmacy;
	char					DoctorProfDescription	[25 + 1];
	short					v_ErrorCode;
	int						MaxLargoVisible;
	short					PriceCode;
	int						ReducedPrice			= 0;
	int						Yarpa_Price;
	int						Maccabi_Price;
	int						Supplier_Price;	// Read from price_list table, but not used for anything here.
	int						IshurPharm;
	short					PermissionType;
	int						IshurLargo;
	short					IshurEP_seq;
	short					IshurHealthBasket;
	cJSON					*JSON_OutputObject		= NULL;
	cJSON					*JSON_OutputHeader		= NULL;
	cJSON					*JSON_OutputData		= NULL;
	cJSON					*JSON_OutputVisitsArray	= NULL;
	cJSON					*JSON_OutputVisit		= NULL;
	cJSON					*JSON_OutputRxArray		= NULL;
	cJSON					*JSON_OutputRx			= NULL;
	cJSON					*JSON_PriorSalesArray	= NULL;
	cJSON					*JSON_PriorSale			= NULL;
	cJSON					*JSON_PaperPrescArray	= NULL;
	cJSON					*JSON_PaperPrescription	= NULL;
	cJSON					*JSON_IshurLargoArray	= NULL;
	int						HTTP_response_status	= 200;	// Default to standard HTTP "OK".
	int						TranslateTechIdHttpStatus;
	int						mac_status_code			= 0;
	bool					FirstDoctorVisit		= 1;
	bool					FullPriceSaleForbidden	= 0;

	// Member fields that aren't used in this transaction - added so we can
	// use a common read-member ODBC operation.
	short					v_CreditYesNo;
	int						max_drug_date;
	short					v_insurance_status;
	int						v_FamilyHeadTZ;
	short					v_FamilyHeadTZCode;
	short					v_in_hospital;

	// General SQL variables.
	int						SysDate;
	int						SysTime;
	int						MaxFromDate;
	int						CannabisMaxFromDate;		// Marianna 06Feb2024 User Story #540234 -variable to compute new cannabis date 
	int						MaxFromDateToCompare;		// Marianna 07Feb2024 User Story #540234
	int						MinUntilDate;
	int						MinVisitDate		= 0;
	int						MinPurchaseDate;
	int						MinValidFromDate	= 0;
	int						AdjustDate			= 0;
	int						RowsFound;
	int						DrugNum;
	int						PriorSaleSubscript;
	int						LastPriorLargo;
	int						LastFourMonths;
	int						economypri_group;
	int						parent_group_code;
	int						MatchingDiagnosis;
	int						RxSelectQueryUsed	= 0;	// DonR 07Jan2021.
	short					DummyCheckInteractions;
	bool					TestingAlternatePackageSizeGenerics	= FALSE;	// DonR 24Aug2023 User Story #473527
	bool					DefaultDrugIsPreferable				= FALSE;	// DonR 12Nov2023 User Story #473527
	int						AlternatePreferredLargo				= 0;		// DonR 24Aug2023 User Story #473527
	T6001_Drugs				DefaultRx;										// DonR 28Aug2023 User Story #473527


	// Body of function
 
	// Initialize variables.
	REMEMBER_ISOLATION;
	PosInBuff				= IBuffer;
	v_ErrorCode				= NO_ERROR;
	reStart					= MAC_FALS;
	JSON_Mode				= (JSON_MaccabiRequest != NULL);
	SysDate					= GetDate ();
	SysTime					= GetTime ();
	LastFourMonths			= AddDays (SysDate, (0 - 121));

	// Dates for deciding whether prescriptions are eligible to be filled.
	MaxFromDate				= AddDays (SysDate,			SaleOK_EarlyDays);			// DonR 01Nov2017: Fixed to use previously NIU (but correct) sysparams field.
	CannabisMaxFromDate		= AddDays (SysDate,			CannabisSaleEarlyDays);		// Marianna 06Feb2024 User Story #540234 -compute new cannabis date 
//	MinUntilDate			= AddDays (SysDate, (0 -	SaleOK_LateDays));
	MinValidFromDate		= AddDays (SysDate, -81);						// DonR 07Jan2021: So we don't SELECT a bunch of long-expired long-duration prescriptions.

	v_DoctorLicense			= 0;
	ExcludeFullySoldRx		= 0;	// Redundant re-initialization - by default, this query *does* include fully-sold prescriptions.
	v_MemberFamilyName	[0]	= 0;
	v_MemberFirstName	[0]	= 0;
	v_DoctorFamilyName	[0]	= 0;
	v_DoctorFirstName	[0]	= 0;
	DoctorPhone			[0]	= 0;
	v_DocContactPhone	[0] = 0;
	LatestMemberPhone	[0]	= 0;

	memset ((char *)SPres,		0, sizeof(SPres));
	memset ((char *)PriorSales,	0, sizeof(PriorSales));

	// Read message fields data into variables.
	if (JSON_Mode)
	{
		int	err_Tech_ID;
		int	err_Member_ID;
		int	err_Member_ID_Code;

		glbErrorCode = 0;	// Start off assuming no errors.

		v_InstituteCode	= 0;								// Already defaulted - just being paranoid. (It should really always be = 2; we
															// read it from the pharmacy table later on, in IS_PHARMACY_OPEN().)

		err_Tech_ID			=	cJSON_GetIntByName		(JSON_MaccabiRequest, "technical_id",			OPTIONAL,	&Technical_ID);				CHECK_JSON_ERROR ();
		err_Member_ID		=	cJSON_GetIntByName		(JSON_MaccabiRequest, "member_id",				OPTIONAL,	&v_MemberIdentification);	CHECK_JSON_ERROR ();
		err_Member_ID_Code	=	cJSON_GetShortByName	(JSON_MaccabiRequest, "member_id_code",			OPTIONAL,	&v_IdentificationCode);		CHECK_JSON_ERROR ();
								cJSON_GetIntByName		(JSON_MaccabiRequest, "pharmacy_id",			MANDATORY,	&v_PharmNum);				CHECK_JSON_ERROR ();
								cJSON_GetShortByName	(JSON_MaccabiRequest, "institute_code",			OPTIONAL,	&v_InstituteCode);			CHECK_JSON_ERROR ();

		// If the member's Technical ID was sent and the member's TZ number was *not* sent,
		// translate the Technical ID to TZ/TZ Code.
		if ((!err_Tech_ID) && (err_Member_ID))
		{
			err = TranslateTechnicalID (Technical_ID, &v_MemberIdentification, &v_IdentificationCode, NULL, &TranslateTechIdHttpStatus);

			if (err)
			{
				GerrLogMini (GerrId, "Could not translate Technical ID %d to Member TZ/Code; TranslateTechnicalID() returned %d/HTTP response %d.",
							 Technical_ID, err, TranslateTechIdHttpStatus);

				v_MemberIdentification = 0;	// Should be redundant! This function will throw an error for TZ = 0,
											// which is what we want in this case.
			}
		}	// Need to translate Technical ID into Member TZ/Member TZ Code.
//		else
//		{
//			// If neither Technical ID *nor* Member TZ Number was supplied, throw a "missing input data" error.
//			if ((!err_Tech_ID) && (!err_Member_ID))
//			{
//				mac_status_code = -98;
//			}
//		}


		if (TransactionID_in == 6101)
		{	// Supply "missing" values for Transaction 6101.
			RequestType				= 0;		// = standard request, so we don't check for an Online Order Number.
			OnlineOrder				= 1;		// Turns of member card-date validation.
			ExcludeFullySoldRx		= 1;		// Chanut Virtualit does *not* get fully-sold prescriptions.
			VisitOrOnlineOrderNum	= 0;		// Paranoid redundant initialization.
			NumExtraLargos			= 0;		// More paranoid redundant initialization.
		}
		else
		{
			cJSON_GetShortByName	(JSON_MaccabiRequest, "TerminalNum",			MANDATORY,	&v_TerminalNum);			CHECK_JSON_ERROR ();
			cJSON_GetShortByName	(JSON_MaccabiRequest, "MemberCardDate",			OPTIONAL,	&MemberCardDate);			CHECK_JSON_ERROR ();	// Optional for online orders.
			cJSON_GetShortByName	(JSON_MaccabiRequest, "PIN_Code",				OPTIONAL,	&PIN_Code);					CHECK_JSON_ERROR ();	// NIU as of April 2021, so make it optional.
			cJSON_GetIntByName		(JSON_MaccabiRequest, "DoctorPrescID",			OPTIONAL,	&v_DoctorPrescID);			CHECK_JSON_ERROR ();	// Optional request parameter.
			cJSON_GetLongByName		(JSON_MaccabiRequest, "VisitOrOnlineOrderNum",	OPTIONAL,	&VisitOrOnlineOrderNum);	CHECK_JSON_ERROR ();	// Optional request parameter.
			cJSON_GetShortByName	(JSON_MaccabiRequest, "VersionNumber",			MANDATORY,	&VersionNumber);			CHECK_JSON_ERROR ();
			cJSON_GetShortByName	(JSON_MaccabiRequest, "RequestType",			MANDATORY,	&RequestType);				CHECK_JSON_ERROR ();

			// NumExtraLargos will be derived from the actual array passed (if there is one), *not* a
			// separate variable sent by the pharmacy. This is, apparently, normal JSON style for arrays.
			cJSON_GetArrayByName	(JSON_MaccabiRequest, "ExtraLargos",			OPTIONAL,	&JSON_ExtraLargosArray);	CHECK_JSON_ERROR ();

			NumExtraLargos = 0;	// Probably redundant, but let's be safe.

			if (JSON_ExtraLargosArray != NULL)
			{
				cJSON_ArrayForEach (JSON_ExtraLargo, JSON_ExtraLargosArray)
				{
					cJSON_GetIntByName (JSON_ExtraLargo, "ExtraLargoCode", MANDATORY, &ExtraDrugs[NumExtraLargos++]); CHECK_JSON_ERROR ();
				}
			}
//			cJSON_GetShortByName	(JSON_MaccabiRequest, "NumExtraLargos",			OPTIONAL,	&NumExtraLargos);			CHECK_JSON_ERROR ();	// Optional feature, usually not used.
		}	// Get input values for Transaction 6001 that aren't supplied for Trn. 6101.

		CHECK_ERROR ();	// If we hit a severe JSON error, give up now.
	}	// JSON mode - read input values from parsed JSON request structure.

	else
	{	// Non-JSON mode - read fixed-position input values from request string.
		v_PharmNum				= GetInt	(&PosInBuff,  7					); CHECK_ERROR ();	// 10,  7
		v_InstituteCode			= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 17,  2
		v_TerminalNum			= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 19,  2
		v_MemberIdentification	= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	// 21,  9
		v_IdentificationCode	= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 30,  1
		MemberCardDate			= GetShort	(&PosInBuff,  4					); CHECK_ERROR ();	// 31,  4
		PIN_Code				= GetShort	(&PosInBuff,  4					); CHECK_ERROR ();	// 35,  4
		v_DoctorPrescID			= GetInt	(&PosInBuff,  6					); CHECK_ERROR ();	// 39,  6
		VisitOrOnlineOrderNum	= GetLong	(&PosInBuff, 11					); CHECK_ERROR ();	// 45, 11
		VersionNumber			= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 56,  2 Currently on Version 6 - 4 and 5 got skipped.
		RequestType				= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 58,  1
		GetString							(&PosInBuff,  ReservedInput, 16	); CHECK_ERROR ();	// 59, 16
		NumExtraLargos			= GetShort	(&PosInBuff,  3					); CHECK_ERROR ();	// 75,  3

		// Read "extra" Largo Codes into array; we will check "hishtatfut" for these drugs without any
		// connection to doctors or doctor prescriptions.
		for (i = 0; i < NumExtraLargos; i++)
		{
			ExtraDrugs[i]		= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();
		}
	}	// Non-JSON mode - read fixed-position input values from request string.

	// Copy relevant fields to SSMD structure.
	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
	ssmd_data_ptr->member_id		= Member.ID			= v_MemberIdentification;
	ssmd_data_ptr->member_id_ext	= Member.ID_code	= v_IdentificationCode_s	= v_IdentificationCode;
	Member.TechnicalID = Technical_ID;

	// DonR 03May2015: Switching to file output, as we're overflowing the in-memory buffer.
	sprintf (fileName,
			 "%s/Trn6001_%0*d_%0*d.snd",
			 MsgDir,
			 7, v_PharmNum,
			 2, v_TerminalNum);


	// DonR 28Jun2020: Moved the top of the "tries" loop here, so if there's any problem
	// with the prescription-retrieval curser becoming un-prepared, it'll automatically
	// be re-prepared with minimal fuss.
	// SQL Retry Loop.
	reStart = MAC_TRUE;

	// DonR 19Apr2005: Avoid unnecessary lock errors by downgrading "isolation"
	// for this transaction.
	SET_ISOLATION_DIRTY;

	for (tries = 0; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		reStart = MAC_FALS;

		// Create new file for response message.
		outFP = fopen (fileName, "w");

		if (outFP == NULL)
		{
			int	err = errno;

			GerrLogReturn (GerrId,
						   "\tCannot open output file '%s'\n\tError (%d) %s\n",
						   fileName,
						   err,
						   strerror(err));

			RESTORE_ISOLATION;
			return (ERR_UNABLE_OPEN_OUTPUT_FILE);
		}

		// Test pharmacy data.
		err = IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);
		if (err != MAC_OK)
		{
			SetErrorVar (&v_ErrorCode, err);

//			if (err == ERR_PHARMACY_NOT_FOUND)
//				mac_status_code = -98;
//
			break;
		}

		// DonR 09May2021 "Chanut Virtualit": Use the Institute Code we read from the pharmacy table.
		// For Trn. 6001, this should always be the same as what the pharmacy sent; but for Chanut
		// Virtualit, there will be no value sent by the pharmacy so we need to fill it in here.
		// (Note that at least in this transaction, Institute Code isn't really used for anything.)
		v_InstituteCode = Phrm_info.institute_code;


		// DonR 30Jan2019 CR #27234: If the requesting pharmacy does not have "hesder Maccabi", force
		// the transaction to be just a simple request for outstanding member prescriptions - no
		// online orders, no fancy queries. (Note that v_DoctorPrescID and VisitNumber will be
		// converted to -9999 below, to disable those SELECT options.) DISABLED - SEE BELOW.
		// 
		// DonR 17Nov2022 User Story 356642: Instead of converting all non-hesder pharmacy requests
		// to RequestType zero, permit these pharmacies to send both Type 0 (ordinary request for
		// fillable prescriptions) and Type 1 (request for past prescriptions by Doctor Prescription
		// ID or Visit Number).
//		if (!HESDER_MACCABI)
//		{
//			RequestType				=
//			OnlineOrder				=
//			VisitOrOnlineOrderNum	=
//			online_order_num		=
//			VisitNumber				=
//			v_DoctorPrescID			=
//			NumExtraLargos			= 0;
//		}

		// If a non-hesder pharmacy sends a Request Type other than 0 or 1, force a
		// BAD_REQUEST_TYPE_FOR_PHARM error.
		if ((!HESDER_MACCABI) && (RequestType > 1))
		{
			GerrLogMini (GerrId, "Trn. 6001: Non-hesder pharmacy %d sent invalid Request Type %d - rejecting.",
						 v_PharmNum, RequestType);

			RequestType = -1;	// Assign a value we know is not valid.
		}
		// DonR 17Nov2022 User Story 356642 end.


		// Request Types:
		//
		// 0: Standard request for current (and future) prescriptions. Pharmacy can optionally include
		//    a Doctor Prescripton ID and/or a Visit Number; in this case, matching prescriptions will
		//    be sent *as well as* all current/future prescriptions.
		//
		// 1: Pharmacy requests prescriptions matching a Doctor Prescription ID and/or Visit Number.
		//    Only matching data will be sent - other current/future prescriptions are excluded.
		//
		// 2: No SELECT from doctor_presc at all - the only thing the transaction will do is check
		//    participation for any "extra" prescriptions sent by the pharmacy.
		//
		// 3: Online order/inquiry - works the same as Request Type 0, except that the member's card
		//    date is not checked (since no card was used), and pharmacy sends Online Order Number if
		//    this is a request for prescriptions to be used to fill an order. (If Request Type = 3
		//    and Online Order Number is zero, this is a request from the website - the equivalent,
		//    more or less, of the Chanut Virtualit Transaction 6101.)
		//
		// 4: Member/card validation only - no prescriptions will be returned.
		//
		// Request-Type-related defaults:
		RequestTypeValid	= 1;						// Already defaulted, but paranoia is a good thing.
		SelectEnabled		= 1;						// Already defaulted, but paranoia is a good thing.
		HistoryEnabled		= 1;						// Already defaulted, but paranoia is a good thing.
		VisitNumber			= VisitOrOnlineOrderNum;	// Whatever is in this slot is either zero or a Visit Number to SELECT by.
		online_order_num	= 0;						// Assume we are NOT working with online orders.

		// DonR 09Sep2020: Request Type validation.
		// Only pharmacies that are authorized to work with home deliveries are
		// allowed to send Request Type 3.
		// Prepare input for the SELECT statement conditionally based on the criteria supplied by
		// the pharmacy. Note that if the pharmacy sends a Doctor Prescription ID and/or a Visit
		// Number (it should be one or the other, but let's be ready to get both!), we send the
		// relevant doctor_presc rows regardless of their date; but we will also send other prescriptions
		// where the valid-from date is anything more recent than 32 days before today.
		switch (RequestType)
		{
			case 0:		// Standard request - current prescriptions PLUS any that match Prescription ID/Visit Number.
						break;

			case 1:		// Select ONLY what matches Prescription ID/Visit Number.

						// DonR 20Nov2022 User Story #356642: Perform some validations for Request Type 1.
						// First, make sure the pharmacy has actually sent a Doctor Prescription Id or
						// a Visit Number. If not, force in nonsense values so nothing will be selected.
						// (NOTE: At least for now, "first" == "only"! The second test is disabled.)
						if ((v_DoctorPrescID == 0) && (VisitNumber == 0))
						{
							v_DoctorPrescID = VisitNumber = -9999;
							SetErrorVar (&v_ErrorCode, DOC_RX_OR_VISIT_NUMBER_NOT_SUPPLIED);
						}

						// DonR 21Nov2022: According to Iris Shaya, we do *not* want to perform the "history
						// test" for Request Type 1 - pharmacies can legitimately query the system for Doctor
						// Prescription IDs or Visit Numbers that they have never sold. Rather than delete
						// the code entirely, I'm disabling it with an #ifdef - just in case Iris changes her
						// mind about this.
#if 0
						else
						{
							// Second, make sure that this pharmacy has some previous involvement with the
							// Doctor Prescription ID / Visit Number requested. Pharmacies are supposed to
							// request this data only for prescriptions/visits that they've previously sold.
							// QUESTION: Does this apply to all pharmacies? I've asked Iris and I'm waiting
							// for an answer.
							ExecSQL (	MAIN_DB, TR6001_validate_req_type_1,
										&RowsFound,
										&Member.ID,				&Member.ID_code,
										&v_DoctorPrescID,		&v_DoctorPrescID,
										&VisitNumber,			&VisitNumber,
										&v_PharmNum,			END_OF_ARG_LIST		);

							if ((SQLCODE == 0) && (RowsFound < 1))
							{
								v_DoctorPrescID = VisitNumber = -9999;	// Force SELECT to return nothing.
								SetErrorVar (&v_ErrorCode, PHARMACY_DID_NOT_SELL_THIS_RX);
							}
							else
							{
								// We really shouldn't see DB errors here, but just in case...
								if (SQLERR_error_test ())
								{
									SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								}
							}
						}	// Pharmacy *did* supply a Doctor Prescription ID or a Visit Number.
#endif
						// DonR 20Nov2022 User Story #356642 end.

						break;

			case 2:		// No database SELECT - check "extra" pharmacy-supplied prescriptions only.
						SelectEnabled = 0;
						break;

			case 3:		// Query for online-orders - gets current prescriptions as well as those matching
						// the Prescription ID if the pharmacy has sent one.
						if ((Phrm_info.order_fulfiller == 0) && (Phrm_info.order_originator == 0))
						{
							SetErrorVar (&v_ErrorCode, BAD_REQUEST_TYPE_FOR_PHARM);
							RequestTypeValid = 0;
						}

						if ((Phrm_info.order_originator == 0) && (VisitOrOnlineOrderNum < 1))
						{
							SetErrorVar (&v_ErrorCode, ORDER_NUMBER_MISSING);
							RequestTypeValid = 0;
						}

						// For online-order processing, the pharmacy sends an Order Number *instead*
						// of a (potential) Visit Number.
						OnlineOrder			= 1;
						online_order_num	= VisitOrOnlineOrderNum;
						VisitNumber			= 0;

						break;

			case 4:		// Member validation ONLY - no prescription processing at all.
						NumExtraLargos	= 0;
						SelectEnabled	= 0;
						HistoryEnabled	= 0;

						// For this request type, we'll generate an error below (after we read
						// the members table) if the person isn't a Maccabi member, using the
						// normal member-validation logic.

						// Is Request Type 4 valid for private pharmacies?

						break;

			default:	// Urecognized Request Type - send an error!
						SetErrorVar (&v_ErrorCode, BAD_REQUEST_TYPE_FOR_PHARM);
						RequestTypeValid = 0;
						break;
		}	// Switch on Request Type.

		// If there was a problem with the Request Type, break out now.
		if (!RequestTypeValid)
			break;


		// Drugs with Largo Code >= 90000 are visible only to Maccabi pharmacies.
		// DonR 15Jan2020 Bug fix (CR #29937): Since we're sending prescriptions for items
		// with Largo Code >= 90000 anyway, we should be looking up the drugs as well.
		MaxLargoVisible = NO_MAX_LARGO;


		// Test Member validity.

		// Member ID must be non-zero.
		if (v_MemberIdentification == 0)
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			break;
		}

		// Test temporary members.
		// DonR 05Apr2017 CR #11541: If there's a temporary card but it's expired, we should
		// return ERR_CARD_EXPIRED rather than ERR_MEMBER_ID_CODE_WRONG (= not found).
		if (v_IdentificationCode == 7)
		{
			ExecSQL (	MAIN_DB, READ_tempmemb,
						&v_TempIdentifCode, &v_TempMembIdentification, &v_TempMemValidUntil, &v_MemberIdentification, END_OF_ARG_LIST	);

			Conflict_Test (reStart);

			if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
				break;
			}

			if (SQLERR_error_test ())
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				break;
			}

			// If we get here, we managed to read the temporary card.
			// DonR 05Apr2017 CR #11541: Assign the member ID/Code even if the temporary
			// card has expired - but force a "card expired" error.
			v_IdentificationCode	= v_TempIdentifCode;
			v_MemberIdentification	= v_TempMembIdentification;
			ForceCardExpiredErr		= (v_TempMemValidUntil < SysDate);
		}	// Temporary Member test.


		// After Temporary Member stuff, Member ID must be 58 or greater.
		// DonR 05Jan2026 User Story #475507: Do *not* check for TZ Number < 58
		// for Request Type 2. (Any such members are already blocked in Transaction
		// 6003, but they are sometimes used in 6001 just to check on the status of
		// a drug without connection to any particular member.)
		if ((v_MemberIdentification < 58) && (RequestType != 2))
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			break;
		}

		// Try to read Member row.
		// DonR 13May2020 CR #31591: Add new Member-on-Ventilator flag. This is
		// currently stored in the old column "asaf_code" (which was sent from
		// AS/400 but never used for anything); when we switch to MS-SQL, the
		// column should be renamed.
		ExecSQL (	MAIN_DB, READ_members_full,
					&v_MemberFamilyName,		&v_MemberFirstName,				&Member.date_of_bearth,
					&Member.maccabi_code,		&v_SpecPresc,					&Member.maccabi_until,
					&Member.payer_tz,			&Member.payer_tz_code,			&v_MemberGender,
					&MemberDefaultPhone,		&MemberHouseNum,				&MemberStreet,
					&MemberCity,				&MemberZipCode,					&Member.insurance_type,

					&Member.keren_mac_code,		&Member.keren_mac_from,			&Member.keren_mac_until,
					&Member.mac_magen_code,		&Member.mac_magen_from,			&Member.mac_magen_until,
					&Member.yahalom_code,		&Member.yahalom_from,			&Member.yahalom_until,
					&Member.carry_over_vetek,	&Member.keren_wait_flag,		&illness_bitmap,
					&Member.card_date,			&Member.update_date,			&Member.update_time,

					&Member.authorizealways,	&Member.updated_by,				&Member.check_od_interact,
					&v_CreditYesNo,				&max_drug_date,					&Member.discount_percent,
					&v_insurance_status,		&v_FamilyHeadTZ,				&v_FamilyHeadTZCode,
					&Member.has_tikra,			&Member.has_coupon,				&v_in_hospital,
					&Member.VentilatorDiscount,	&Member.darkonai_type,			&Member.force_100_percent_ptn,

					&Member.darkonai_no_card,	&Member.has_blocked_drugs,		&Member.died_in_hospital,
					&Member.mahoz,				&Member.dangerous_drug_status,

					&v_MemberIdentification,	&v_IdentificationCode,			END_OF_ARG_LIST					);

		Conflict_Test (reStart);

		// DonR 04Dec2022 User Story #408077: Use a new function to set some Member flags and values.
		SetMemberFlags (SQLCODE);
			
		if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			break;
		}
			
		if (SQLERR_error_test ())
		{
			SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
			break;
		}
		else
		{
			// TEMPORARY FOR SUPERPHARM TESTING!
			// If the member's Card Date from the database is 5555, act as if
			// the pharmacy sent that date as well.
			// DonR 29May2022: Add a testing-system-only criterion to the "if".
			if ((Member.card_date == 5555) && (!TikrotProductionMode))
				MemberCardDate = 5555;


			// See if this member has an all-drug vacation limit-multiplier ishur.
			// DonR 28Jun2020: Checking for an all-drug vacation ishur should be contingent
			// on the member's spec_presc flag - there's no point in doing the (NON-STICKY!)
			// lookup if we already know the member doesn't have any ishurim!
			if (v_SpecPresc)
			{
				int		IshurLargo	= 0;	// DonR 10Dec2025 User Story #441076.

				ExecSQL (	MAIN_DB, TR6001_READ_CheckFor99997Ishur, Largo_99997_ishur_standard_WHERE,
							&Member.Has_PL_99997_Ishur,
							&v_MemberIdentification,		&v_IdentificationCode,
							&SysDate,						&SysDate,
							END_OF_ARG_LIST																	);

				if (SQLCODE != 0)
					Member.Has_PL_99997_Ishur = 0;

				
				NumIshurLargos = 0;	// Redundant, paranoid re-initialization.

				// DonR 10Dec2025 User Story #441076: Read member's ishurim into an array.
				if (VersionNumber > 5)
				{

					DeclareAndOpenCursorInto (	MAIN_DB, TR6001_READ_ishur_list,
												&IshurLargo,
												&Member.ID,			&SysDate,
												&SysDate,			&Member.ID_code,
												END_OF_ARG_LIST							);

					SQLERR_error_test ();

					do
					{
						FetchCursor (	MAIN_DB, TR6001_READ_ishur_list	);

						Conflict_Test (reStart);

						if (NumIshurLargos > 499)
						{
							GerrLogMini (GerrId, "Trn. 6001: More than 500 active ishurim for Member %d!", Member.ID);
							break;
						}

						if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
						{
							break;
						}

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}

						IshurLargos [NumIshurLargos++] = IshurLargo;
					}
					while (1);

					CloseCursor (	MAIN_DB, TR6001_READ_ishur_list);

				}	// Version Number is >= 4, so we need to get a list of ishur Largo Codes for the member.

			}	// Member has at least one AS/400 ishur.
			else
			{
				Member.Has_PL_99997_Ishur	= 0;
				NumIshurLargos				= 0;	// Redundant re-initialization.
			}


			// Set up member's address as a single string.
			strip_spaces (MemberStreet);
			strip_spaces (MemberHouseNum);
			strip_spaces (MemberCity);
			sprintf (MemberAddress, "%s %s, %s %d", MemberStreet, MemberHouseNum, MemberCity, MemberZipCode);

			// For convenience, store some member stuff in a structure - this makes some function
			// arguments simpler.
			Member.ID				= v_MemberIdentification;
			Member.ID_code			= v_IdentificationCode;
			Member.sex				= v_MemberGender;
			Member.illness_bitmap	= illness_bitmap;
			Member.in_hospital		= 0;	// Hospitalization status is not relevant for this transaction.

			// DonR 03Jun2018 order-for-delivery (SuperPharm) enhancement: If this is an online order,
			// we want to operate as if member has passed a valid magnetic card even though no card
			// was in fact used. The easiest way to do this is simply to copy the card-date value from
			// the members table to the card-date value that the pharmacy ordinarily sends.
			// DonR 27Aug2018: For online orders, force Digital Status TRUE even if the Card Date
			// value from the database is zero.
			// BUT: If the pharmacy *did* send a non-zero Card Date, we need to deal with it the way
			// we do in ordinary circumstances.
			// DonR 09Aug2021 User Story #163882: Darkonaim who are flagged as always getting service
			// without a magnetic card don't need any further checks - just copy their date, the same
			// as for online orders.
			if (((OnlineOrder) && (MemberCardDate <= 0))	||
				(Member.darkonai_no_card))
			{
				MemberCardDate	= Member.card_date;
				DigitalStatus	= (Member.darkonai_no_card) ? 2 : 1;
// GerrLogMini (GerrId, "TZ %d has darkonai_no_card = %d; setting MemberCardDate = %d, DigitalStatus = %d.", v_MemberIdentification, Member.darkonai_no_card, MemberCardDate, DigitalStatus);
			}
			else
			{
				// NOT an online order, OR it's an online order and pharmacy sent a Card Date.
				// If pharmacy did send a non-zero Card Date, we start off with the
				// assumption that it's valid and we can send digital prescriptions; we'll validate
				// the date below. If the pharmacy sent zero for the Card Date, and we're not
				// processing an online order, check for service without card.
				// DonR 30Jan2019 CR #27234: Service Without Card is not available at non-hesder-Maccabi pharmacies.
				// DonR 15Sep2019 CR #29694: Service Without Card *is* available at non-hesder-Maccabi pharmacies.
				// DonR 05Jul2020 CR #32984: DigitalStatus is *not* automatically TRUE for MemberCardDate > 9997.
				DigitalStatus = ((MemberCardDate > 0) && (MemberCardDate < 9998))	? 1 : CheckForServiceWithoutCard (&Member, Phrm_info);

				// DonR 11Feb2019 CR #27234: For non-hesder pharmacies, passing a member's magnetic
				// card is mandatory - so give an error if MemberCardDate is zero.
				// DonR 15Sep2019 CR #29694: Service Without Card *is* available at non-hesder-Maccabi pharmacies.
				// DonR 23Sep2019: ...But if the member *didn't* request service without card, the card is still mandatory!
				// DonR 07Nov2022 BUG 275924 FIX: MEMBER_CARD_MANDATORY_NON_HESDER should be returned *only* for the
				// standard request for valid prescriptions - RequestType == 0.
				// DonR 08Nov2022: It turns out that the latest change doesn't really do anything, because up above
				// we force RequestType to be zero for non-Hesder pharmacies. There was a discussion in early July 2020
				// about allowing these pharmacies to send Request Type 1, but a change request never materialized.
				// DonR 20Nov2022: The change request to enable non-Hesder pharmacies to sent Request Type 1 is
				// User Story #356642.
//				if ((MemberCardDate < 1) && (!HESDER_MACCABI) && (!DigitalStatus))
				if ((MemberCardDate < 1) && (!HESDER_MACCABI) && (!DigitalStatus) && (RequestType == 0))
				{
					SetErrorVar (&v_ErrorCode, MEMBER_CARD_MANDATORY_NON_HESDER);
				}

				// DonR 03Nov2020: For Request Type 4 (card validation only), if DigitalStatus is FALSE then
				// we need to send an error to the pharmacy.
				if ((RequestType == 4) && (!DigitalStatus))
				{
					SetErrorVar (&v_ErrorCode, NO_SERVICE_WITHOUT_CARD);
				}
			}


			// Validate date of member's magnetic card. If it wasn't valid, we won't read
			// prescriptions from the database.
			if ((v_IdentificationCode_s		!= 7						)	&&	// Don't check temp. members
				(CheckCardDate											)	&&	// DonR 05Apr2017 CR #11541: Global tokef-checking parameter.
				(MemberCardDate				>  0						)	&&	// 10Jan2005: 1 is a valid card date!
				(MemberCardDate				<  9999						)	&&	// CR #32984: 9998 should never be sent in Trn. 6001 - so give error ERR_CARD_EXPIRED.
				((MemberCardDate != 9997) || (Member.MemberTzahal == 0)	)	&&	// 10Oct2011: Special card for soldiers.
				(MemberCardDate				!= Member.card_date			)	&&	// Date on card doesn't match DB version.
				(Member.card_date			>  0						)	&&  // Yulia 20030213: DB date is "for real".
				(v_MemberIdentification		!= 59						)	&&	// Special case - exempt real members...
				(v_MemberIdentification		!= 83						))		// ...whose ID's have been used for testing.
			{
				// DonR 30Jul2013: Because a lot of new Maccabi Sheli cards were sent out by mail - and members'
				// data was updated with the new card dates before those cards had arrived - a new table,
				// membercard, has been added to list additional/alternative valid card dates for any given
				// member. Accordingly, check this table before sending a "card expired" error.
				ExecSQL (	MAIN_DB, READ_MemberCard,
							&Member.card_date,
							&v_MemberIdentification,	&v_IdentificationCode,
							&MemberCardDate,			END_OF_ARG_LIST				);

				if (SQLCODE != 0)
				{
					// Pharmacy did send a non-zero value, but it doesn't check out as a valid card date.
					// In this case, set an error code, disable reading prescriptions from the database,
					// *and* disregard any "extra" Largo Codes - so we won't return any prescription
					// or participation data.
					DigitalStatus = NumExtraLargos = 0;
					SetErrorVar (&v_ErrorCode, ERR_CARD_EXPIRED);
				}
			}	// Pharmacy sent a non-zero card date but it did *not* match the one from the Members table.


			// DonR 30Jan2018: If member did use a valid magnetic card but has his/her "Authorize Always" flag
			// set "permanently" TRUE, set it to zero; it turns out that a huge number of members (something
			// like one in three) have that flag set TRUE with no current reason for it.
			else
			{
				if ((v_IdentificationCode_s		!= 7				)	&&	// Don't process members using temporary cards.
					(!OnlineOrder									)	&&	// We don't want to reset the Authorize Always flag if the member didn't actually use his/her card!
					(MemberCardDate				>  0				)	&&	// There is a Card Issue Date for this member.
					(MemberCardDate				<  9997				)	&&	// 9997 = soldier, 9998 is illegal, and 9999 means they read a printed barcode instead of the magnetic card.
//					((MemberCardDate != 9997) || (MemberTzahal == 0))	&&	// 9997 indicates a special card for soldiers.
					(MemberCardDate				== Member.card_date	)	&&	// Date on card DOES match DB version.
					(Member.authorizealways		!= 0				)	&&	// Authorize Always flag is set TRUE.
					(Member.updated_by			!= 8888				)	&&	// The Authorize Always flag was *not* set by a website/mobile app request.
					(v_MemberIdentification		>  0				)	&&	// Non-zero TZ - probably a redundant check, but harmless.
					(v_MemberIdentification		!= 59				)	&&	// Special case - ignore real members...
					(v_MemberIdentification		!= 83				))		// ...whose ID's have been used for testing.
				{
					// Note: At least for now, there's no need for error-handling on this UPDATE. If it fails, nothing terrible
					// happens - the Authorize Always flag just stays TRUE until next time.
					// DonR 14Feb2018: Added update to updated_by to indicate that this is the transaction that
					// reset the service-without-card flag.
					// Update member based on TZ and TZ Code.
					ExecSQL (	MAIN_DB, UPD_members_ClearAuthorizeAlways,
								&TrnID,					&v_MemberIdentification,
								&v_IdentificationCode,	END_OF_ARG_LIST				);
				}	// Member passed a magnetic card with a real date that matched what we have for him/her in the Members table.
			}	// Something other than a normal card match - DonR 30Jan2018 end.


			// DonR 05Apr2017 CR #11541: If pharmacy used an expired temporary card, send
			// a "card expired" error (instead of a "member ID not found" error).
			// Note that the global CheckCardDate flag (from sysparams) does *not*
			// affect how we deal with temporary cards - it applies only to the date
			// on "real" Maccabi cards.
			if ((v_IdentificationCode_s == 7) && (ForceCardExpiredErr))
			{
				DigitalStatus = NumExtraLargos = 0;
				SetErrorVar (&v_ErrorCode, ERR_CARD_EXPIRED);
			}	// CR #11541 end.

		}	// Successfully read member information.


		// Logical data tests on Member eligibility.
		// DonR 25Nov2021 User Story #206812: Get died-in-hospital indicator from the Ishpuz system.
		// DonR 28Nov2022 User Story #407955: Allow pharmacies to perform RequestType 1 for non-valid
		// (or no-longer-valid) members.
		// DonR 30Nov2022 User Story #408077: Use a new macro MEMBER_IN_MEUHEDET (defined in MsgHndlr.h)
		// to decide if the person is a Meuhedet member.
		if (((MEMBER_INELIGIBLE) && (RequestType != 1))	||
			(MEMBER_IN_MEUHEDET))
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_NOT_ELEGEBLE);
			break;
		}
		// DonR 14Dec2021: At least for now, Iris does not want to get
		// "Member died in hospital" errors in Transaction 6001.
//		else
//		{
//			if (Member.died_in_hospital)
//			{
//				// DonR 30Nov2021: For now at least, "Member died in hospital" is probably
//				// not going to be (pardon the expression) a fatal error. In fact, it may
//				// not even be sent in Transaction 6001 - this needs clarification.
//				if (SetErrorVar (&v_ErrorCode, MEMBER_DIED_IN_HOSPITAL))
//					break;
//			}
//		}


		// Validate Online Order Number, if necessary.
		if (online_order_num > 0)
		{
			// Note that the SELECT below assumes that each online reservation can be used exactly once - there
			// is no allowance for a "partly sold" online reservation. This makes a degree of sense, since (at
			// least as of 17 June 2018) there is no validation on Maccabi's end to connect the drugs selected
			// by the member to reserve and the drugs selected by the delivering pharmacy to sell and deliver.
			// If later we want to allow for more detailed item-by-item validation, this SELECT would need to
			// include rows with sold_status = 1 (partially sold), and might need some additional checks as well.
			//
			// Note also that for the moment we're just checking for the existence of a matching reservation for
			// the current Member ID. If we want to give a different error for a reservation that exists but isn't
			// for this member - or for a reservation that exists but has been used already - we need more
			// elaborate logic here.
			ExecSQL (	MAIN_DB, READ_online_orders_TimestampsAndMember,
						&OO_member_id,			&OO_member_id_code,
						&OO_made_date,			&OO_made_time,
						&OO_start_work_date,	&OO_start_work_time,

						&online_order_num,		&Phrm_info.web_pharmacy_code,
						&Phrm_info.owner,		END_OF_ARG_LIST					);
// GerrLogMini (GerrId, "READ_online_orders_TimestampsAndMember returned %d for order %ld.", SQLCODE, online_order_num);

			if (SQLCODE == 0)
			{
				// If the pharmacy is not allowed to sell against online orders, or the order is for
				// a different member, or the order has expired, or the allowed time for working on
				// the order has passed, set appropriate error code(s).
				// These should all be severe errors that prevent the sale from being completed.
				if (Phrm_info.order_fulfiller == 0)
				{
					SetErrorVar (&v_ErrorCode, PHARM_NOT_ORDER_FULFILLER);
				}

				if ((OO_member_id != v_MemberIdentification) || (OO_member_id_code != v_IdentificationCode))
				{
					SetErrorVar (&v_ErrorCode, ONLINE_ORDER_WRONG_MEMBER);
				}

				OO_min_made_date = AddDays (SysDate, (0 - Phrm_info.max_order_sit_days));
				if (( OO_made_date <  OO_min_made_date)		||
					((OO_made_date == OO_min_made_date) && (OO_made_time < SysTime)))
				{
					SetErrorVar (&v_ErrorCode, ONLINE_ORDER_EXPIRED);
				}

				// If this is the first transaction involved in fulfilling this online order, set
				// start_work_date/time to start the clock ticking. Otherwise, make sure that the
				// maximum allowed work interval has not been exceeded for this online order.
				if (OO_start_work_date < 1)
				{
					// Update online order with current system time. Note that we don't really have
					// to worry about error-handling here - if this UPDATE fails, it's no great tragedy.
					ExecSQL (	MAIN_DB, UPD_online_orders_StartWorkTimestamp,
								&SysDate,			&SysTime,
								&online_order_num,	&Phrm_info.web_pharmacy_code,
								&Phrm_info.owner,	END_OF_ARG_LIST					);
				}	// This is the first transaction involved in fulfilling this online order.

				else
				{
					AddHours (SysDate, SysTime, (0 - Phrm_info.max_order_work_hrs), &OO_min_work_date, &OO_min_work_time);
					if (( OO_start_work_date <  OO_min_work_date)		||
						((OO_start_work_date == OO_min_work_date) && (OO_start_work_time < OO_min_work_time)))
					{
						SetErrorVar (&v_ErrorCode, ONLINE_ORDER_EXCESS_WORKTIME);
					}
				}	// This is *not* the first transaction dealing with fulfilling this online order.

			}	// Pharmacy sent Online Order Number that *was* found and needs to be validated.

			else
			{
				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					SetErrorVar (&v_ErrorCode, ONLINE_ORDER_NOT_FOUND);
				}
				else
				{
					// If we get here, there was some kind of database error other than "not found". This is
					// considered a show-stopper!
					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}	// DB error other than not-found.
			}	// Failed to read a row from online_orders.
		}	// Pharmacy sent an Online Order Number (which can happen only for Request Type 3).


		// DonR 10Jan2022 Feature #198767: When a pharmacy is requesting prescriptions to fill
		// an online order, allow recently-expired prescriptions to be sent. This is necessary
		// because sometimes the member orders drugs right before their prescriptions expire,
		// and once the order has been placed we don't want to disable the prescriptions that
		// the member ordered. Note that later on we compare the prescription's valid_until_date
		// to the date we're adjusting, MinUntilDate - so these just-expired prescriptions will
		// be sent as "valid to sell".
		// DonR 13Jan2022: Added new parameters to pharmacy_type_params to allow more flexibility
		// in deciding how much to extend prescriptions' Valid Until Date.
		if (TransactionID_in == 6001)
		{
			if (RequestType == 3)	// Either creating an online order or fulfilling an online order.
			{
				if (online_order_num > 0)
					AdjustDate = Phrm_info.select_late_rx_days_filling_online_order;	// Filling an online order.
				else
					AdjustDate = Phrm_info.select_late_rx_days_ordering_online;			// Creating an online order.
			}
			else					// "Normal" in-person sale at a pharmacy.
			{
				AdjustDate = Phrm_info.select_late_rx_days_buying_in_person;
			}
		}
		else	// Chanut Virtualit Transaction 6101.
		{
			AdjustDate = Phrm_info.select_late_rx_days_ordering_online;					// Creating an online order.
		}

		MinUntilDate = AddDays (SysDate, (0 -	AdjustDate));


		// Read applicable drugs prescribed from Prescriptions-Written table.
		DrugCount				= 0;
		CurrentVisitSubscript	= 0;
		ExtraDrugSubscript		= 0;
		NumRequestedValid		= 0;		// Paranoid re-initialization.
		NumRequestedExpired		= 0;		// Paranoia is our friend!
		VisitNumberToAdjust		= 0;		// (Possibly our only friend.)
		LastDocID				= -999;		// Re-initialize to bogus value so zero counts as something new.
		LastVisitNumber			= -999;		// Re-initialize to bogus value so zero counts as something new.

		// DonR 15Sep2019 CR #29694: Service Without Card *is* available at non-hesder-Maccabi pharmacies.
		// DonR 23Sep2019: ...But if the member *didn't* request service without card, the card is still mandatory!
		// DonR 22Dec2022 User Story #356642: Non-hesder pharmacies do *not* need to pass the member's magnetic
		// card for Request Type 1.
		if (((DigitalStatus	== 0)	&& (MemberCardDate != 0))													||	// Pharmacy sent a card-date that didn't match member data on file.
			((!HESDER_MACCABI)		&& (MemberCardDate <  1) && (DigitalStatus	== 0) && (RequestType == 0))	||	// DonR 30Jan2019 CR #27234: Non-hesder pharmacies *must* use a current member card.
			(!SelectEnabled))																						// "Extra" prescriptions only/Member validation only - no database select.
		{
			FetchComplete			= 1;
		}
		else	// Request Type = 0 or 1, so we do need to fetch prescriptions from the database.
		{
			FetchComplete			= 0;


			// DonR 24Apr2018: If pharmacy has requested data for a particular Doctor Prescription ID, perform a
			// preliminary SELECT to find the *last* Visit Date where a prescription with this Doctor Prescription ID
			// was issued. This lets us avoid sending old data, since Doctor Prescription ID's are sometimes re-used
			// for the same member. Note that we *don't* need this logic for selection by Visit Number, since these
			// are up to 11 digits and won't "wrap around"; the problem with Doctor Prescription ID's is that they
			// are only 6 digits, so they repeat relatively frequently.
			if (v_DoctorPrescID > 0)
			{
				ExecSQL (	MAIN_DB, TR6001_READ_GetLastMatchingVisitDate,
							&MinVisitDate,
							&v_MemberIdentification,	&v_DoctorPrescID,
							&v_IdentificationCode,		&SysDate,
							END_OF_ARG_LIST										);

				// No need for real error-trapping.
				if (SQLCODE != 0)
					MinVisitDate = 0;
			}
			else
			{
				MinVisitDate = 0;	// Redundant, paranoid re-initialization.
			}


			// Select all doctor presciptions matching the supplied Prescription ID/Visit Number
			// regardless of date, as well as everything we would send normally. If the pharmacy
			// has not sent a Doctor Prescription ID and/or a Visit Number (it should be one or
			// the other, but let's be ready to get both!), we set these variables to a nonsense
			// value so that only current prescriptions will be sent.
			// DonR 07Jan2021: Split off a separate version of TR6001_doctor_presc_cur for those cases
			// (over 90%) where the pharmacy wants ONLY current prescriptions and did not specify
			// a Prescription ID or Visit Number. Hopefully this version, with a much simpler WHERE
			// clause, will run significantly faster.
			if ((v_DoctorPrescID == 0) && (VisitNumber == 0))
			{
				v_DoctorPrescID = VisitNumber = -9999;	// Not used in the new simplified SELECT, but
														// still relevant elsewhere (I think).

				RxSelectQueryUsed = TR6001_doctor_presc_cur_simplified;	// For FETCH and CLOSE, so we don't need
																		// two versions of these calls.

				DeclareAndOpenCursor (	MAIN_DB, TR6001_doctor_presc_cur_simplified,
										&v_MemberIdentification,	&MinUntilDate,
										&MinValidFromDate,			&v_IdentificationCode,
										&ExcludeFullySoldRx,		END_OF_ARG_LIST			);
			}
			else
			{
				RxSelectQueryUsed = TR6001_doctor_presc_cur;			// For FETCH and CLOSE, so we don't need
																		// two versions of these calls.

				DeclareAndOpenCursor (	MAIN_DB, TR6001_doctor_presc_cur,
										&v_MemberIdentification,	&MinUntilDate,
										&MinValidFromDate,			&RequestType,
										&v_DoctorPrescID,			&v_DoctorPrescID,
										&VisitNumber,				&VisitNumber,
										&MinVisitDate,				&v_IdentificationCode,	END_OF_ARG_LIST		);
			}

			Conflict_Test (reStart);

			if (SQLERR_error_test ())
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				break;
			}
// GerrLogMini (GerrId, "Opened prescription cursor for Member %d; v_ErrorCode = %d, FetchComplete = %d.", v_MemberIdentification, v_ErrorCode, FetchComplete);
		}	// Reading prescriptions from database IS enabled.


		// We shouldn't get here if we've hit a fatal error - but just to be paranoid, we'll
		// make the prescription-reading conditional.
		if (!SetErrorVar (&v_ErrorCode, v_ErrorCode))
		{
			do
			{
				// Set "shortcut" pointers to the doctor_presc and previous-purchase sub-structures.
				Rx	= &SPres[DrugCount].Rx;
				PPD	= &SPres[DrugCount].PPD;

				// Try to read the next drug prescribed.
				if (!FetchComplete)
				{
					// DonR 29Aug2023 User Story #473527: If we're in "simulation mode", we have already opened the
					// "simulation" cursor TR6001_FindAlternatePackageSizeGenerics and successfully read a row into
					// AlternatePreferredLargo. We still need to make a safe copy of the "default" SPres structure
					// (in case the alternate preferred drug winds up being no better for the member than the default
					// drug), empty out the current SPres structure, and then copy various pieces of data from the
					// default so that the new "simulated" version will be an exact substitute - except with a
					// different Largo Code, pricing, and OP/Units.
					if (TestingAlternatePackageSizeGenerics)
					{
						// Successful fetch (at the bottom of the loop) of an alternate preferred
						// drug - set up the "simulation"!

						// First, save the current prescription line.
						DefaultRx = SPres[DrugCount];

						// Next, clear current prescription line data.
						memset ((char *)&SPres[DrugCount], 0, sizeof(SPres[DrugCount]));

						// Now copy the doctor_presc data instead of reading it from the table. Also copy
						// the "SuppressOutputToPharmacy" flag and the "NumRxInVisit" value, as well as
						// information about the prescribing doctor.
						SPres[DrugCount].Rx							= DefaultRx.Rx;
						SPres[DrugCount].SuppressOutputToPharmacy	= DefaultRx.SuppressOutputToPharmacy;
						SPres[DrugCount].NumRxInVisit				= DefaultRx.NumRxInVisit;
						SPres[DrugCount].DoctorLicense				= DefaultRx.DoctorLicense;
						strcpy (SPres[DrugCount].DoctorFirstName,	  DefaultRx.DoctorFirstName);
						strcpy (SPres[DrugCount].DoctorFamilyName,	  DefaultRx.DoctorFamilyName);
						strcpy (SPres[DrugCount].DoctorPhone,		  DefaultRx.DoctorPhone);
						strcpy (SPres[DrugCount].DocContactPhone,	  DefaultRx.DocContactPhone);
					}	// In "simulation mode" (TestingAlternatePackageSizeGenerics is TRUE).

					// DonR 24Aug2023 User Story #473527 continued: If we're not in "simulation mode", go ahead and
					// read the next row from doctor_presc.
					else
					{
						// DonR 07Jan2021: Split TR6001_doctor_presc_cur into two versions - the complicated original one,
						// (TR6001_doctor_presc_cur) plus a version (TR6001_doctor_presc_cur_simplified) with a simplified
						// WHERE for the 90% of cases where the pharmacy ONLY wants current prescriptions and doesn't
						// specify a Prescription ID or Visit Number.
						// DonR 07Nov2024 User Story #357209: Add 6 new columns to support external prescription providers
						// (initially MaccabiDent). Note that for now, external_doc_license_type and internal_comments aren't
						// used for anything.
						FetchCursorInto (	MAIN_DB, RxSelectQueryUsed,
											&Rx->member_id,					&Rx->member_id_code,			&Rx->clicks_patient_id,
											&Rx->doctor_id,					&Rx->doctor_presc_id,			&Rx->largo_prescribed,
											&Rx->valid_from_date,			&Rx->valid_until_date,			&Rx->order_number,
											&Rx->sold_status,				&Rx->ordered_status,			&Rx->deleted_status,
											&Rx->visit_number,				&Rx->visit_date,				&Rx->visit_time,
							
											&Rx->clinic_address,			&Rx->line_number,				&Rx->speciality_desc,
											&Rx->specialist_ishur,			&Rx->rule_number,				&Rx->prescription_type,
											&Rx->digital_presc_flag,		&Rx->dose_number,				&Rx->op,
											&Rx->total_units,				&Rx->qty_method,				&Rx->usage_method_code,
											&Rx->usage_instructions,		&Rx->amt_per_dose,				&Rx->unit_abbreviation,
							
											&Rx->doses_per_day,				&Rx->treatment_length,			&Rx->course_treat_days,
											&Rx->course_len,				&Rx->course_len_units,			&Rx->num_courses,
											&Rx->days_per_week,				&Rx->morning_evening,			&Rx->treatment_side,
											&Rx->member_phone,				&Rx->clinic_phone,				&Rx->row_added_date,
											&Rx->row_added_time,			&Rx->last_sold_date,			&Rx->last_sold_time,

											&Rx->tot_units_sold,			&Rx->tot_op_sold,				&Rx->linux_update_flag,
											&Rx->linux_update_date,			&Rx->linux_update_time,			&Rx->extern_update_flag,
											&Rx->extern_update_date,		&Rx->extern_update_time,		&Rx->reported_to_as400,
											&Rx->reported_to_cds,			&Rx->effective_unit_len,		&Rx->rx_origin,
											&Rx->external_doc_first_name,	&Rx->external_doc_last_name,	&Rx->external_doc_license_num,

											&Rx->external_doc_license_type,	&Rx->internal_comments,			&Rx->PharmacistAuthorization,
											&Rx->ProfCodeToPharmacy,		&Rx->ProfDescription,			END_OF_ARG_LIST						);

						Conflict_Test (reStart);
					
						// DonR 21Mar2021: There was no trap for errors other than end-of-fetch here, and it
						// looks like we're seeing an error for a particular member - so let's add an
						// SQLERR_error_test() call.
						if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
						{
							FetchComplete = 1;
						}
						else
						{
							// DonR 22Mar2021: Log Unicode conversion errors, but otherwise ignore them.
							if (SQLERR_code_cmp (SQLERR_data_conversion_problem) == MAC_TRUE)
							{
								GerrLogMini (GerrId, "Unicode conversion error FETCHing Member %d Visit %ld Rx ID %d Line Number %d, SQLCODE %d.",
											 v_MemberIdentification, Rx->visit_number, Rx->doctor_presc_id, Rx->line_number, SQLCODE);
							}
							else
							{
								if (SQLERR_error_test ())
								{
									SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
									break;
								}
							}

							// DonR 10Dec2025 User Story #441076: Strip leading/trailing spaces from some new fields.
							StripAllSpaces (Rx->internal_comments);
							StripAllSpaces (Rx->PharmacistAuthorization);
							StripAllSpaces (Rx->ProfDescription);


							// DonR 07Nov2023 User Story #473527: Set up Rx->adjusted_monthly_units. If the amount prescribed
							// looks "monthly", adjusted_monthly_units will be set based on 30-day months even if the doctor
							// prescribed based on a 28-day month. (29 and 31 days are also "monthly", but in real life we don't
							// see them in OP sizes or doctor prescriptions.) NOTE: As of February 2024, we don't actually do
							// anything with adjusted_monthly_units. I'm leaving the logic alone for now, since it's harmless
							// and won't degrade performance measurably. (UPDATE: As of 27Feb2025, we *do* use this value!)
							// DonR 15Feb2024 User Story #473527 fix: Also save the prescribed OP from the prescription, since
							// we adjust the number later on and we need to know the original number for optimizing stuff sold
							// with Quantity Method 1 (like tubes of Voltaren, for example).
							// DonR 18Feb2024 User Story #473527 fix: As long as we're saving and restoring relevant values read
							// from doctor_presc, add total_units and qty_method to the save/restore list.
							Rx->adjusted_monthly_units	= Rx->total_units;	// Default value = just what we got from Clicks.
							Rx->original_op				= Rx->op;
							Rx->original_total_units	= Rx->total_units;
							Rx->original_qty_method		= Rx->qty_method;

							// Compute demand as a monthly figure only for continuous treatment (letting integer math work its magic).
							if (Rx->prescription_type == 0)
							{
								switch (Rx->treatment_length)
								{
									case  7:	// In case doc prescribes 7 days with 4/8/12... pills per day.
									case 14:	// In case doc prescribes 14 days with an even number of pills per day.
									case 28:
									case 56:
									case 84:	if ((Rx->total_units % 28) == 0)
												{
													Rx->adjusted_monthly_units = 30 * (Rx->total_units / 28);
												}
												break;

									case 29:
									case 58:
									case 87:	if ((Rx->total_units % 29) == 0)
												{
													Rx->adjusted_monthly_units = 30 * (Rx->total_units / 29);
												}
												break;

									case 31:
									case 62:
									case 93:	if ((Rx->total_units % 31) == 0)
												{
													Rx->adjusted_monthly_units = 30 * (Rx->total_units / 31);
												}
												break;

									default:	break;
								}	// Switch to find "monthly" treatment durations.
							}	// Prescription is for continuous treatment.

						}	// Something other than end-of-fetch.
					}	// TestingAlternatePackageSizeGenerics is FALSE, so we need to read the next doctor prescription row.
				}	// Not yet finished reading doctor_presc cursor.

				// If we've reached the end of the doctor_presc cursor, add any "extra" largo codes
				// reported by the pharmacy (for paper prescriptions) to the end of the SPres array.
				// Question: Should we disable this for Request Types 0 and 1?
				if (FetchComplete)
				{
					if (ExtraDrugSubscript < NumExtraLargos)	// ExtraDrugSubscript is initially zero.
					{
						// Just in case the SQL call put any bogus values into variables, zero out the Rx structure.
						memset ((char *)Rx, 0, sizeof(TDoctorPrescRow));

						Rx->largo_prescribed = ExtraDrugs[ExtraDrugSubscript];
						ExtraDrugSubscript++;

						SPres[DrugCount].IsExtraLargo = 1;	// So we know not to report this as a regular prescription.
// GerrLogMini (GerrId, "Added Extra Largo %d to SPres array.", Rx->largo_prescribed);
						GoodFetch = 1;
					}
					else
					{
						GoodFetch = 0;	// End of both the doctor_presc cursor and the ExtraDrugs array.
					}
				}
				else	// NOT end-of-fetch.
				{
					if (SQLERR_code_cmp (SQLERR_ok) == MAC_TRUE)
					{
						GoodFetch = 1;

						// DonR 04Jan2022: If we're in "Chanut Virtualit" mode (Transaction 6101), do *not* send
						// prescriptions with deleted_status non-zero.
						if ((TransactionID_in == 6101) && (Rx->deleted_status != 0))
							continue;


						// DonR 23Feb2022 Epic #153562 / User Story #227221: For Secret Investigators, suppress all
						// prescriptions with non-zero Deleted or Sold Status. If the request specified a Visit Number
						// or Doctor Prescription ID, send *only* matching prescriptions and nothing else. Finally,
						// check for similar prescriptions and send only the "earliest" one - based on Visit Date,
						// Valid From Date, and Doctor Prescription ID.
						if (SECRET_INVESTIGATOR)
						{
							int					PrevDrug;
							TDoctorPrescRow		*Rx0;
							bool				RxIsRedundant	= false;

							// First check for "simple" reasons to reject this prescription: it's been at least
							// partially sold, it's deleted, or the pharmacy requested a particular Visit Number
							// or Doctor Prescription ID and this is a valid but non-matching prescription.
							if (( Rx->sold_status		> 0)											||
								( Rx->deleted_status	> 0)											||
								((Rx->doctor_presc_id	!= v_DoctorPrescID)	&& (v_DoctorPrescID	> 0))	||
								((Rx->visit_number		!= VisitNumber)		&& (VisitNumber		> 0)))
							{
								continue;
							}

							// Next, scan for similar prescriptions in the list we've already read.
							// At least for now, match only by the drug prescribed and don't worry about
							// generic matches.
							for (PrevDrug = 0; PrevDrug < DrugCount; PrevDrug++)
							{
								Rx0 = &SPres[PrevDrug].Rx;	// Just to keep code compact.

								// First, try to find a match based on the drugs prescribed; only if we
								// fail to find a match will we check for generic equivalents, since at
								// this point we haven't yet checked for drug substitutions.
								if (Rx0->largo_prescribed == Rx->largo_prescribed)
								{
									RxIsRedundant = true;

									// If the previous similar prescription is older (based on Visit Date,
									// Valid From Date, or Doctor Prescription ID, in that order) than the
									// one we just read, swap the new one in place of the old one. Otherwise
									// just ignore the new one.
									if (	( Rx0->visit_date <  Rx->visit_date)															||
											((Rx0->visit_date == Rx->visit_date) && (Rx0->valid_from_date <  Rx->valid_from_date))			||
											((Rx0->visit_date == Rx->visit_date) && (Rx0->valid_from_date == Rx->valid_from_date) && (Rx0->doctor_presc_id < Rx->doctor_presc_id))	)
									{
										break;	// Previous prescription on list is earlier (or has lower Doctor Prescripton ID) than the new one.
									}

									// If we get here, the new prescription is "better" than the previous
									// prescription for the same drug, so swap it in.
									SPres[PrevDrug].Rx = *Rx;

									break;

								}	// Drug prescribed matches one that's already been FETCHed.
							}	// Loop through the list of previously FETCHED drugs to find a match.

							// If RxIsRedundant is TRUE, the prescription matched a previously FETCHED
							// one, and was either copied into its location in the array or will simply
							// be discarded. In either case, do NOT add it to the end of the array - just
							// continue to the next FETCH.
							if (RxIsRedundant)
								continue;

						}	// DonR 23Feb2022 Epic #153562 / User Story #227221 END: This "member" is a
							// secret investigator ("mivaker samui") and the relevant logic is enabled.


						// DonR 24Oct2017 CR #13050: We are now including prescriptions with treatment length >= 45 days
						// in the SELECT regardless of their valid-until date; accordingly, we need to filter expired
						// long prescriptions after the fact. We do this by constructing a fictitious valid-until date
						// equal to the valid-from date + treatment length - 10 days. Note that this is a temporary fix:
						// eventually Clicks will provide long-duration prescriptions with an appropriate valid-until
						// date, and we can revert to the previous logic.
						// DonR 01Nov2017: For long prescriptions, we want to send the computed valid-until date even
						// if the prescription is still valid based on the valid-until date we got from Clicks. This
						// means that the valid-until date sent to the pharmacy will be consistent for the life of
						// the prescription, and we won't cause extra confusion.
						// DonR 27Nov2017: We need to change what is sent to pharmacies, since the pharmacy-side software
						// displays only a single valid-until date for a particular Doctor Prescription ID, even if it
						// includes prescriptions of different Treatment Lengths. We will now send the *original*
						// Valid-Until Date, and we'll add something to the logic below to send a correct "OK to sell"
						// flag for long-duration prescriptions.
						// DonR 07Jan2021: If the Valid Until Date in the database is still valid today, there is no
						// point in computing Rx->ComputedValidUntil and doing the other comparisons - so let's save
						// a few CPU cycles!
						// DonR 03Jun2021: If the computed Valid Until Date makes the prescription valid to sell, swap
						// it in instead of the incorrect Clicks-reported Valid Until Date. (Note that I'm not sure if
						// this is really still necessary - I think Clicks has already fixed the relevant bug. But I've
						// never gotten an official confirmation of this.) In fact, with this change ComputedValidUntil
						// can be made into a local variable.
						// DonR 17Aug2021: Checked the database for duration = 60 and 90, and it looks like the Clicks
						// bug has in fact been fixed; for now, though, I'm going to leave this code enabled.
						if ((Rx->treatment_length >= 45) && (Rx->valid_until_date < MinUntilDate))
						{
							int ComputedValidUntil;

							// If the prescription is expired even based on extending the Valid Until Date, just skip
							// past it - this is the equivalent of its having failed the WHERE criteria and never having
							// been SELECTed in the first place. HOWEVER, if the pharmacy requested a particular Doctor
							// Prescription ID and/or Visit Number and this prescription matches that request, leave
							// the expired prescription in the list! (Note that we need to test the criteria for being
							// non-zero rather than greater-than-zero, since they will be negative if the pharmacy has
							// not requested a specific prescription/visit.)
							// DonR 24Apr2018: Added MinVisitDate to this logic. This variable will have a non-zero value
							// *only if* the pharmacy requested data for a particular Doctor Prescription ID. If we see
							// a long-duration prescription that matches this Doctor Prescription ID but is from an
							// earlier visit, reject it - when Doctor Prescription ID's "roll over", we want to send
							// only the most recent matching prescriptions.
							// DonR 24Apr2018: Send transactions if the reported Valid Until Date is "b'tokef" OR the
							// computed Valid Until Date is "b'tokef" - previously we were ignoring the reported
							// valid-until date.
							ComputedValidUntil = AddDays (Rx->valid_from_date, (Rx->treatment_length - 10));

							if (ComputedValidUntil < MinUntilDate)
							{
								if (((Rx->doctor_presc_id	!= v_DoctorPrescID	)	&& (v_DoctorPrescID	!= 0			))	||
									((Rx->doctor_presc_id	== v_DoctorPrescID	)	&& (Rx->visit_date	<  MinVisitDate	))	||
									((Rx->visit_number		!= VisitNumber		)	&& (VisitNumber		!= 0			)))
								{
//GerrLogMini (GerrId, "Rejecting out-of-date prescription ID %d Largo %d.", Rx->doctor_presc_id, Rx->largo_prescribed);
									continue;
								}

								// If we get here, the prescription is expired even based on extending its Valid Until
								// Date, but it matches the Doctor Prescription ID and/or Visit Number requested by
								// the pharmacy.
							}
							else	// DonR 03Jun2021: The computed date makes the prescription valid - so copy it into Rx->valid_until_date.
							{
								Rx->valid_until_date = ComputedValidUntil;
							}
						}	// Need to adjust Valid Until Date for long-duration prescriptons.

						// If we get here, one of three things is true:
						//
						// 1) The prescription is valid based on its original Valid Until Date.
						// 2) The prescription has Treatment Length >= 45 days and is valid based on the extended
						//    Valid Until Date computed above.
						// 3) The prescription matches the Doctor Prescription ID / Visit Number sent by the pharmacy.
						//
						// This means that the prescription is valid for sale if its Valid Until Date is >= the
						// Minimum Until Date *OR* its Treatment Length is >= 45 days. (Of course, it may still be
						// invalid because its Valid *From* Date is in the future.)

						if (!TestingAlternatePackageSizeGenerics)
							NumRxFromDB++;
					}
				}	// Need to evaluate result of SQL FETCH.

				// If we successfully read something, process this prescribed drug.
				// Note: We need to remember that the fetch was (or wasn't) successful, since the
				// generic-substitution logic will override the SQL status variables. Thus "GoodFetch"!

				// DonR 22Mar2011: If the doctor_presc fetch failed, there's no point in reading
				// from drug_list - so move the "if (GoodFetch)" up here.
				if (GoodFetch)
				{
					// Just for safety's sake, copy the prescribed Largo code to a simple variable.
					LargoPrescribed = Rx->largo_prescribed;

					// We are outputting the amount per dose in much the same way we output prices - i.e.
					// multiplied by 100, with no decimal point. Thus if the amount per dose is 1.5 pills,
					// we want to send the pharmacy 150. The easiest way to do this is to set up an integer
					// variable, rather than try to get fancy with floating-point printf masks. Note that
					// we add a smidgin to the number just in case there's a loss of precision somewhere.
					SPres[DrugCount].dose_times_100 = ((SPres[DrugCount].Rx.amt_per_dose * 100.0) + 0.00000000001);
//GerrLogMini (GerrId, "Rx->num_courses = %d, Rx->course_len = %d, Rx->effective_unit_len = %d,\nRx->treatment_length = %d, Rx->prescription_type = %d.",
//	Rx->num_courses, Rx->course_len, Rx->effective_unit_len, Rx->treatment_length, Rx->prescription_type);

					// DonR 20Dec2016: Because Clicks does not yet store the number-of-courses value anywhere, we
					// need to derive this number from the other stuff we know about the prescription. Because
					// the course length may be in months or weeks (which can be spelled either in singular or
					// plural), we use a separate table (course_len_to_days) to translate the course length into
					// days. We will perform this translation only for Prescription Types 2 and 3 (*not* 4, since
					// it's not applicable there), and only when the total treatment length is an exact multiple
					// of the course length in days. So a 7-day (or 1-week) course length with a total treatment
					// length of 28 will translate into 4 courses, but if the treatment length is 30 days, we
					// will leave the number-of-courses value set to zero.
					// DonR 23Mar2017: Instead of sending the number of courses, we want to send the total
					// treatment length expressed in the same units as the course length. So instead of
					// dividing treatment length by (course_len * unit_len), we want to divide it only
					// by unit_len. (Note that the variable name num_courses should be changed!)
					// DonR 10Nov2020 HOT FIX: For some reason, the main "if" below sometimes continues  to
					// evaluate even if Rx->effective_unit_len == 0, and this is causing division-by-zero
					// crashes. The simplest fix is to have the outer "if" based on just the simple criteria,
					// so we know for sure that the program won't attempt to do Rx->treatment_length % Rx->effective_unit_len
					// if Rx->effective_unit_len is zero. Note, though, that even that change didn't work!
					// I got things to stop crashing only when I added a should-be-redundant extra "if"
					// inside the main "if". This is seriously weird.
					// DonR 11Nov2020: It turns out that the previous problem (see 10Nov2020 comment) was caused by the
					// backslash at the end of the line below with "(Rx->course_len > 0)". That backslash caused the next
					// line of code (with the "(Rx->treatment_length > 0)" to be treated as a continuation of the previous
					// line - in other words, as part of a comment! So that part of the "if" was never executed!
					if ((Rx->num_courses			<  1)											&&	// Non-zero value from database will be used if present.
						(Rx->course_len				>  0)											&&	//	> 
						(Rx->effective_unit_len		>  0)											&&	//   >	Needed input variables for calculation are all non-zero. 
						(Rx->treatment_length		>  0)											&&	//	>
						((Rx->prescription_type		== 2) || (Rx->prescription_type == 3))			&&	// Prescription Type is one of those that use courses.
						((Rx->treatment_length % Rx->effective_unit_len)	== 0))						// Treatment length in units comes out exactly even.
					{
						Rx->num_courses = Rx->treatment_length / Rx->effective_unit_len;
					}	// Need to compute num_courses (and the necessary parameters exist).

					// DonR 22Oct2023 User Story #487170: In order to compare prescribed course length accurately to
					// previous-sale course lenth, convert the prescribed course length to days. "Month-like" values
					// will be normalized to 30-day months, so that (for example) 4 weeks will equal 1 month.
					Rx->course_len_days = (Rx->effective_unit_len > 1) ?
													Rx->course_len * Rx->effective_unit_len :
													Rx->course_len;
					switch (Rx->course_len_days)
					{
						case  28:
						case  29:
						case  31:	Rx->course_len_days =  30;	break;

						case  56:
						case  58:
						case  62:	Rx->course_len_days =  60;	break;

						case  84:
						case  87:
						case  93:	Rx->course_len_days =  90;	break;

						case 112:
						case 116:
						case 124:	Rx->course_len_days = 120;	break;

						default:	break;
					}
					// DonR 22Oct2023 User Story #487170 end.


					// The same drug may appear several times in the list of prescriptions. To save time,
					// copy stuff from the first instance of a drug in the prescription list rather than
					// looking everything up in the database multiple times.
					for (i = DrugAlreadyInList = SameDrugSameDoctor = 0; i < DrugCount; i++)
					{
						if (SPres[i].Rx.largo_prescribed == Rx->largo_prescribed)	// Repeat drug.
						{
							if (!DrugAlreadyInList)
							{
								DrugAlreadyInList								= 1;
								SPres[DrugCount].DL								= SPres[i].DL;
								SPres[DrugCount].DL_prescribed					= SPres[i].DL_prescribed;
								SPres[DrugCount].DeliveryPermitted				= SPres[i].DeliveryPermitted;				// DonR 11Jun2018 Online Order (SuperPharm).
								SPres[DrugCount].LargoBlockedForMember			= SPres[i].LargoBlockedForMember;			// DonR 21Nov2021 User Story #196891
								SPres[DrugCount].PPD							= SPres[i].PPD;								// DonR 25May2022: Copy previous-purchase data.
								SPres[DrugCount].BestPreferredPackageSizeChosen	= SPres[i].BestPreferredPackageSizeChosen;	// DonR 30Aug2023 User Story #473527.
								// Don't break here, since the same drug may have been prescribed by multiple
								// doctors and we want to avoid database lookups to determine participation,
								// if possible.
							}

							// We can safely copy participation info from a previous item in the array if the two
							// items are for the same drug AND the same doctor, OR if they're for the same non-specialist
							// drug (in which case the prescribing doctor is irrelevant in determining participation).
							// DonR 26Jan2022: If we're running Transaction 6101 and PrDateValidForSale doesn't match the
							// previously-found prescription on the list, DO NOT set SameDrugSameDoctor TRUE. Even if all
							// the "hishtatfut" stuff is the same, there will likely be differences in the Reason Forbidden
							// Code, so we have to treat it as a new entity.
							// DonR 08Feb2022: There are so many checks for different Reason Codes in Transaction 6101 that
							// we need to recalculate them unless two prescriptions on the list were actually identical - which
							// hardly ever happens in real life. Accordingly, I'm disabling SameDrugSameDoctor for 6101!
							// DonR 23May2022: Since we're now sending the "reason" codes for 6001 as well as for 6101, the
							// previous fix (08Feb2022) isn't enough. Instead, we need to use SameDrugSameDoctor *only* for
							// copying member participation stuff, and calculate the "reason" codes for every prescription
							// even if it's similar to another one on the list.
							// DonR 28Apr2025 User Story #390071: If two different doctors prescribed the same drug BUT one
							// of them chose a Rule Number and the other didn't (or they both did, but using different
							// "nohalim"), do NOT set SameDrugSameDoctor TRUE - we need to predict participation based, in
							// part, on the rule number(s) the doctor(s) chose. We will assume, though, that the same doctor
							// consistently chose the same rule (or left it out), so there is a limit to our paranoia. (This
							// is how Transaction 6003 works, and we want to be as consistent as possible.)
							SameDrugSameDoctor	=	(	(	(SPres[DrugCount].DL.specialist_drug == 0)
															&&
															(SPres[i].Rx.rule_number	== SPres[DrugCount].Rx.rule_number)
														)
														||
														(	SPres[i].Rx.doctor_id		== SPres[DrugCount].Rx.doctor_id)
													);

							if (SameDrugSameDoctor)
							{
								SPres[DrugCount].YarpaPrice			= SPres[i].YarpaPrice;		// DonR 18Jan2022: Chanut Virtualit - made this conditional on SameDrugSameDoctor.
								SPres[DrugCount].MaccabiPrice		= SPres[i].MaccabiPrice;	// DonR 24Jan2022: Chanut Virtualit BUG FIX - need to copy this along with YarpaPrice.
								SPres[DrugCount].PriceCode			= SPres[i].PriceCode;
								SPres[DrugCount].ReducedPrice		= SPres[i].ReducedPrice;
								SPres[DrugCount].FixedPriceFlag		= SPres[i].FixedPriceFlag;
								SPres[DrugCount].PriceMessageCode	= SPres[i].PriceMessageCode;

								// DonR 27Apr2021 "Chanut Virtualit":
								// Copy the Shape Name only if it's the same drug *and* the same doctor - otherwise
								// there might be a "dispense as written" ishur that applies to some prescriptions
								// but not to others for the same drug. In theory, if there are prescriptions for
								// the same drug from multiple doctors, this will result in extra lookups to the
								// drug_shape table; but in real life, I don't think this happens all that often,
								// and the lookup is a fast and simple one anyway.
								strcpy (SPres[DrugCount].ShapeName, SPres[i].ShapeName);

								// Note that we do *not* copy the various "permitted" and "reason" codes, because
								// they depend on more than just same-drug-same-doctor stuff; we have to figure
								// them out individually.

								break;	// No need to keep looking, since we've found our same-drug-same-doctor perfect match!

							}	// Same drug, same doctor - copy participation data.
						}	// Same drug - copy drug_list data.
					}	// Loop through array to find matches.

					// If this is the first occurrence of this drug in the list, read its drug_list info.
					if (!DrugAlreadyInList)
					{
						// Per Iris Shaya, if the drug prescribed is not in the drug_list
						// table, don't report this drug to the pharmacy.
						// DonR 08Apr2018: Added new "see deleted drugs" parameter to read_drug(). Since deleted
						// drugs shouldn't be prescribed, here we just set the parameter FALSE.
						// DonR 25Aug2021 BUG FIX: Sometimes a drug gets deleted *after* it has been prescribed;
						// and in this case we do not want to make the prescription suddenly "invisible".
						// Accordingly, change the "see deleted drugs" parameter from FALSE to TRUE.
						if (!read_drug (Rx->largo_prescribed,
										MaxLargoVisible,
										&Phrm_info,
										true,		// DonR 25Aug2021 BUG FIX: Deleted drugs are "visible".
										&SPres[DrugCount].DL,
										NULL))
						{
							// DonR 01Nov2020: Add logging of any unexpected DB error reading drug_list.
							if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
							{
								SQLERR_error_test ();
							}

							continue;	// I.e. skip to next row from doctor_presc.
						}
						else	// Good read of drug_list.
						{
							// DonR 21Nov2021 User Story #196891: Check whether this drug is blocked for this member.
							// DonR 13Mar2025 User Story #384811: To support more detailed drug-blocking based on
							// different categories of Darkonaim (Maccabi, Harel Tourists, Harel Foreign Workers),
							// add Darkonai Type (3 times) to the READ_CheckDrugBlockedForMember parameter list.
							if ((Member.has_blocked_drugs) || (SPres[DrugCount].DL.has_member_type_exclusion))	// Don't waste a DB lookup if we know we won't get results.
							{
								ExecSQL (	MAIN_DB, READ_CheckDrugBlockedForMember,
											&RowsFound,
											&Member.ID,
											&Member.darkonai_type,	&Member.darkonai_type,	&Member.darkonai_type,
											&Rx->largo_prescribed,	&Member.ID_code,		END_OF_ARG_LIST			);

								if ((SQLCODE == 0) && (RowsFound > 0))
								{
									// Mark this drug as blocked - so for private pharmacies, we'll know we have to
									// force participation to 100%, and we'll pass an indicator to the Nihul Tikrot
									// application so it knows to leave this item out of its calculations.
									// NOTE: SPres is already initialized to all-zeroes, so we don't need a separate
									// initialization for SPres[DrugCount].LargoBlockedForMember.
									SPres[DrugCount].LargoBlockedForMember = 1;
								}
								else
								{
									if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
									{
										SQLERR_error_test ();
									}
								}
							}

							// Copy drug_list row to the "prescribed" structure (as the default).
							SPres[DrugCount].DL_prescribed	= SPres[DrugCount].DL;

						}	// Good read of drug_list.
					}	// Need to read a new drug from drug_list table.

					// Set up date-OK-to-sell flag.
					// Future sale can be permitted in several different ways. For now at least, future sales are
					// permitted only at Maccabi pharmacies except in the case of a vacation ishur - but this may
					// change in the future for members who live overseas.
					// DonR 02May2016: Per Iris Shaya, remove the condition relating to "ishurei chu''l" (a.k.a.
					// Has_PL_99997_Ishur).
					// DonR 27Nov2017: Prescriptions with Treatment Length >= 45 days automatically pass the "Valid
					// Until Date" test - any that didn't were already eliminated from the SELECTed list up above.
					// DonR 29Nov2017: Fixed the test for prescriptions with Treatment Length >= 45 days. We need
					// to leave expired prescriptions in the list IF they match a pharmacy's request for a specific
					// Doctor Prescription ID and/or Visit Number; so at this point we can't assume that long
					// duration alone is enough. OTOH the computed Rx->ComputedValidUntil will be non-zero only
					// for these long-duration prescriptions, so we can test it along with the default Valid Until
					// Date.
					// DonR 09Oct2018 CR #26700: Pharmacies are now authorized to sell future-dated prescriptions
					// based on a new flag, can_sell_future_rx, in the Pharmacy table.
					// DonR 03Jun2021: Removed ComputedValueUntil from the "Rx" structure; if the prescription is
					// valid for sale based on the computed Valid Until Date, that date will be copied into the
					// normal Rx->valid_until_date field.
					// DonR 26Jan2022: Moved this block of code up by around 170 lines, so we can use a change in
					// PrDateValidForSale to force SameDrugSameDoctor FALSE and ensure that we give correct Reason
					// Forbidden Codes in all cases.
					// DonR 16Feb2022 HOT FIX: Moved this code back down to where it used to be. We were checking
					// drug_list/allow_future_sales before we read from the drug_list table!
					// Marianna 06Feb2024 User Story #540234 
					// calculate MaxFromDateToCompare : CannabisMaxFromDate must be drug_type == 'K'
					// DonR 13May2024 HOT FIX: We don't assign a value to the "shortcut" pointer variable DL
					// until waaaaay later in the code - so we can't use it here. Rather than copy the assignment,
					// it's simpler just to reference SPres[].DL directly, since the rest of the logic already
					// works that way.
					MaxFromDateToCompare = (SPres[DrugCount].DL.PreventFutureCannabisSales) ? CannabisMaxFromDate : MaxFromDate;

					if ((Rx->valid_until_date >= MinUntilDate)			&&			// Prescription hasn't yet completely expired, AND...
						((Rx->valid_from_date <= MaxFromDateToCompare)		||		// Prescription isn't too far in the future, OR...
							((CAN_SELL_FUTURE_RX)								&&
							(!SPres[DrugCount].DL.PreventFutureCannabisSales)	&&	// Marianna 06Feb2024 User Story #540234
							((SPres[DrugCount].DL.allow_future_sales				== FUTURE_SALE_MAC_ONLY) 	||		// Maccabi pharmacy and drug permits future sale...
							( SPres[DrugCount].DL.allow_future_sales				== FUTURE_SALE_ALL_PHARM) 	||
							( OVERSEAS_MEMBER)))))																		// ...or member normally lives overseas.
					{
						SPres[DrugCount].PrDateValidForSale = 1;	// OK to sell.
					}
					else
					{
						// Future prescription (0 = too early to sell) or else expired prescription (2 = too late to sell).
						SPres[DrugCount].PrDateValidForSale = (Rx->valid_from_date > MaxFromDateToCompare) ? 0 : 2;
					}
		
				
					// DonR 27Nov2017: Keep track of expired/non-expired prescriptions if the pharmacy has requested
					// a particular Doctor Prescription ID / Visit Number.
					// DonR 09Sep2020: Add Request Type 3 to this logic, since (at least in theory) a pharmacy
					// could send a Doctor Prescription ID for this Request Type.
					// DonR 31Jan2023 User Story #424975: If Request Type is 1, we want to send *all* matching
					// prescriptions, whether they're expired or not. The easy way to accomplish this is simply
					// to remove (RequestType == 1) from the conditions for this "if" block.
					// DonR 28Aug2023 User Story #473527: Perform this test only the first time we look at each
					// doctor_presc row - skip it for "simulation mode". In "simulation mode", we'll just copy
					// the "SuppressOutputToPharmacy" value and leave the NumRequestedExpired and NumRequestedValid
					// counters alone.
					if (((RequestType == 0) || (RequestType == 3)) && (!TestingAlternatePackageSizeGenerics))
					{
						if (((Rx->doctor_presc_id	== v_DoctorPrescID	) || (v_DoctorPrescID	== 0))		&&
							((Rx->visit_number		== VisitNumber		) || (VisitNumber		== 0)))
						{
							// Save the current visit number, so when we generate output for the pharmacy we know which
							// visit *may* need to have its number of prescriptions adjusted down. (Note that we're
							// assuming that the same Doctor Prescription ID will not be present for two different
							// visits for the same member. This assumption should be correct, even though the index
							// structure of doctor_presc doesn't enforce it.)
							VisitNumberToAdjust = Rx->visit_number;

							if (SPres[DrugCount].PrDateValidForSale == 2)	// = expired
							{
								NumRequestedExpired++;
								SPres[DrugCount].SuppressOutputToPharmacy = 1;	// Will suppress output of this Rx to pharmacy
																				// IF NumRequestedValid > 0.
							}
							else
							{
								NumRequestedValid++;
							}
						}
					}

					// DonR 17Nov2016: If the Clinic Address for this prescription is longer than what
					// we're supposed to send to the pharmacy, truncate it.
					Rx->clinic_address[60] = (char)0;

					// If we haven't already gotten participation info for the same drug and doctor, do it now.
//if (!TikrotProductionMode)
//GerrLogMini (GerrId, "6001: DrugCount %d - SameDrugSameDoctor %d, TestingAlternatePackageSizeGenerics %d, v_SpecPresc %d.",
//	DrugCount, SameDrugSameDoctor, TestingAlternatePackageSizeGenerics, v_SpecPresc);
					if (!SameDrugSameDoctor)
					{
						// Substitute Generic Drugs IF member doesn't have an AS/400 ishur for the prescribed drug.
						// Per Iris Shaya, if there is an AS/400 ishur for this member/drug, don't perform
						// generic-drug substitution. Note that (at least for now) we aren't worrying about
						// the extension of expired ishurim here - we look only at "normal", active ishurim!
						// DonR 22Mar2011: Reordered last two WHERE criteria to conform to index structure.
						// DonR 23Mar2011: Don't look for an AS/400 ishur if we already know member doesn't have one.
						// DonR 12Sep2012: Ishurim with Member Price Code of zero are invalid - ignore them!
						// NOTE: For now at least, we are NOT looking at all the conditions for an ishur to apply
						// to the member's participation; this means, for example, that if the ishur is good for
						// Maccabi pharmacies only, we'll still use the ishur's participation info even if the
						// member is at a private pharmacy.
						// DonR 12Jul2017: Instead of using a cursor, just do a SELECT FIRST 1.
						// DonR 18Feb2018: It might be possible to collapse these two into a single SELECT, using
						// an ORDER BY / CASE construction - i.e. ORDER BY CASE sl.largo_code
						// WHEN :LargoPrescribed THEN -999 ELSE dl.economypri_seq. I'm not sure if this would work,
						// but it might be fun to try!
						//
						// DonR 30Jan2019 CR #27234: Non-hesder pharmacies get no member discounts - so don't even
						// try reading from special_prescs.
						// DonR 21Nov2021 User Story #196891: As in Transaction 6003, we are *not* suppressing
						// ishur lookup for blocked drugs. See longer comment below for more detail.
						// DonR 03Oct2022 BUG FIX 272058: If this is an ishur that's "attached" to a particular pharmacy,
						// Maccabi pharmacies other than the "attached" one can still sell the drug with the ishur
						// discount - they just get a ERR_SPEC_PR_FOR_OTHER_PHARM_WRN warning message in Transaction
						// 6003. Accordingly, we need these ishurim to be visible to all Maccabi pharmacies in
						// Transaction 6001/6101. To support this, added a second instance of the Maccabi Pharmacy
						// flag to the relevant SQL as the 8th input parameter.
						if ((v_SpecPresc) && (HESDER_MACCABI))
						{
							ExecSQL (	MAIN_DB, TR6001_READ_special_prescs_prescribed_largo,
										&PriceCode,						&ReducedPrice,					&IshurPharm,
										&PermissionType,				&IshurLargo,					&IshurHealthBasket,

										&v_MemberIdentification,

										// DonR 30Aug2023 User Story #473527: If we're in "simulation" mode, look for an ishur
										// for the alternate preferred Largo Code we're simulating; otherwise, look for an
										// ishur for the drug that was prescribed.
										(TestingAlternatePackageSizeGenerics) ? &AlternatePreferredLargo : &LargoPrescribed,

										&SysDate,						&SysDate,						&Phrm_info.maccabi_pharmacy,
										&Phrm_info.private_pharmacy,	&v_PharmNum,					&Phrm_info.maccabi_pharmacy,
										&v_IdentificationCode,			END_OF_ARG_LIST													);

							// DonR 12Jul2017 CR #12181: If we didn't find an ishur for the prescribed drug, look for
							// ishurim for other drugs in the same generic-substitution group.
							// DonR 29Jan2018: Do NOT check for ishurim if the drug prescribed has Preferred Status
							// of 4, 8, or 9.
							// DonR 04Feb2018: Use the new economypri_seq field in drug_list instead of cross-referencing
							// to economypri/item_seq. This was the last remaining direct lookup to economypri in sqlserver.exe
							// other than the actual economypri download transaction; since drug_list is accessed all
							// the time, it should always be in the database server's cache and thus these lookups
							// should run a bit faster.
							// DonR 30Aug2023 User Story #473527: If we're in "simulation" mode, we do *not* want to look
							// for ishurim for the standard preferred drug - we already did it the first time around for
							// this prescription.
							if ((!TestingAlternatePackageSizeGenerics)		&&	// DonR 30Aug2023 User Story #473527.
								(SQLCODE							!= 0)	&&
								(SPres[DrugCount].DL.preferred_flg	!= 4)	&&
								(SPres[DrugCount].DL.preferred_flg	!= 8)	&&
								(SPres[DrugCount].DL.preferred_flg	!= 9))
							{
								ExecSQL (	MAIN_DB, TR6001_READ_special_prescs_substitute_largo,
											&PriceCode,						&ReducedPrice,			&IshurPharm,
											&PermissionType,				&IshurLargo,			&IshurEP_seq,
											&IshurHealthBasket,

											&v_MemberIdentification,		&v_IdentificationCode,	&LargoPrescribed,
											&SysDate,						&SysDate,				&Phrm_info.maccabi_pharmacy,
											&Phrm_info.private_pharmacy,	&v_PharmNum,			&SPres[DrugCount].DL.economypri_group,
											END_OF_ARG_LIST																						);

								// This diagnostic can probably be removed once we've done some testing of the CR #12181 changes.
								if ((SQLCODE != 0) && (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE))
								{
									SQLERR_error_test ();
								}
							}	// DonR 12Jul2017 CR #12181 end.

							// DonR 21Nov2021 User Story #196891: As a general rule, a member should not have both an AS/400
							// ishur *and* a per-drug block on the same Largo Code, since the two things are pretty much completely
							// contradictory. For the moment, I am *not* disabling ishur lookup for blocked drugs in Trn. 6001/6101,
							// but we'll need to see if this is actually the correct way of handling the issue. If we do want to
							// suppress ishur discounts for blocked drugs, this is the place to do it; we would need to re-check
							// the member_blocked_drugs table for the substitute Largo Code if an ishur was found for a generic
							// equivalent to the prescribed drug. It's worth noting that Transaction 6003 also permits ishur discounts
							// for blocked drugs - so we're basically relying on not getting contradictory information from AS/400.
							if (SQLCODE == 0)	// Successful ishur read (either prescribed drug or the most-preferred substitute drug).
							{
								SPres[DrugCount].PriceCode				= PriceCode;
								SPres[DrugCount].ReducedPrice			= ReducedPrice;
								SPres[DrugCount].InHealthBasket			= IshurHealthBasket;
								SPres[DrugCount].FixedPriceFlag			= ((PriceCode == 1) && (ReducedPrice > 0)) ? 1 : 0;
								SPres[DrugCount].FoundAs400Ishur		= true;	// Ptn. from ishur, even if it's 100% w/o fixed price.
								SPres[DrugCount].PtnRequiresPratiPlus	= (PermissionType == 6) ? 1 : 0;

								// DonR 12Jul2017 CR #12181: If the ishur we found is for a substitute drug, swap that in
								// for the prescribed drug.
								if ((IshurLargo != Rx->largo_prescribed) && (IshurLargo > 0))
								{
									SPres[DrugCount].DL_prescribed	= SPres[DrugCount].DL;	// Should be redundant, as this was already done above.

									// We can assume that any drug for which there's a valid ishur *and* an economypri row will also be found
									// in the drug_list table - so don't bother with error-checking here.
									// DonR 08Apr2018: Since we're not checking errors anyway, set the new "see deleted drugs" parameter TRUE here.
									// DonR 01Nov2020: Add logging of any unexpected DB error reading drug_list.
									if (!read_drug (	IshurLargo,
														MaxLargoVisible,
														&Phrm_info,
														true,	// "See" the drug even if it's been logically deleted.
														&SPres[DrugCount].DL,
														NULL	))
									{
										if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
										{
											SQLERR_error_test ();
										}
									}
								}	// Need to swap in the drug for which there is an ishur.


								// DonR 30Aug2023 User Story #473527: If the member has an ishur for a non-preferred version of
								// a drug, we can assume that we don't want to perform any substitutions - just sell the member
								// that drug. But if the member has an ishur for a preferred generic version of a drug, it seems
								// reasonable to assume that s/he may also have ishurim for other preferred versions - and thus
								// we should perform "simulation" to see if a different drug is more "preferred".
								// Note that if we're *already* in "simulation mode", NeedToFindBestPreferredPackageSize is not
								// relevant - but there's no harm in recalculating it, since it's all just integer comparisons.
								// DonR 17Dec2024 BUG FIX #375452: The generic-drug package-size optimization logic needs to
								// work for Chanut Virtualit (Trn. 6101) the same as it does for 6001 - so I'm removing the
								// "only 6001" condition from this "if" statement.
								SPres[DrugCount].NeedToFindBestPreferredPackageSize =
									(	( SPres[DrugCount].DL.largo_type		== 'T')											&&	// Treatment drugs only.
										( SPres[DrugCount].DL.economypri_group	>  0)											&&	// Drug has generic substitutes.
										( SPres[DrugCount].DL.multi_pref_largo	>  0)											&&	// ...And more than one of them is "preferred".
										( SPres[DrugCount].DL.preferred_flg		== 1)											&&	// The drug in the ishur is "preferred".
										(!SPres[DrugCount].BestPreferredPackageSizeChosen)											// We haven't already chosen the optimal preferred drug.
									);

							}	// Found an applicable ishur.
						}	// Member has an AS/400 Ishur.

//if (!TikrotProductionMode)
//GerrLogMini (GerrId, "6001: After ishur check, PriceCode = %d for Line %d Rx Largo %d, Largo to sell %d, simulation trigger %d.",
//	SPres[DrugCount].PriceCode, DrugCount, LargoPrescribed, SPres[DrugCount].DL.largo_code, SPres[DrugCount].NeedToFindBestPreferredPackageSize);
						// At this point, if the Member Price Code variable has a non-zero value, we're taking
						// participation from an AS/400 ishur and we do NOT want to substitute a generic drug.
						// DonR 29Jan2018: Added a parameter to find_preferred_drug() to let it perform generic
						// substitution on drugs with Preferred Flag = 3. This flag is TRUE for prescription-request
						// transactions (2001, 6001) but FALSE everywhere else - meaning that these drugs can
						// be sold under their own conditions with no explanation from the pharmacy.
						if (SPres[DrugCount].PriceCode < 1)
						{
							// DonR 24Aug2023 User Story #473527: If this pass through the prescription loop is a
							// simulation using an alternate preferred drug, swap that drug in "by hand" instead
							// of calling find_preferred_drug(). NOTE: In this situation, we won't change the
							// current value of DispenseAsWritten, since it will have been set the first time we
							// went through the logic for this doctor prescription and will still have the correct
							// value. Also note that if TestingAlternatePackageSizeGenerics is TRUE, we know that
							// AlternatePreferredLargo has a real value, since TR6001_FindAlternatePackageSizeGenerics
							// filters out anything weird.
							if (TestingAlternatePackageSizeGenerics)
							{
								LargoToDispense		= AlternatePreferredLargo;
								FindPref_err		= 0;	// Not that we actually look at this variable anywhere...
								DispenseAsWritten	= 0;	// This shouldn't really be relevant either - just being paranoid.

								read_drug (	AlternatePreferredLargo,	9999999,
											NULL,						false,	// Deleted drugs are "invisible".
											&GenericDrugRow,			NULL	);
							}
							else
							{
								find_preferred_drug (Rx->largo_prescribed,
													 SPres[DrugCount].DL.economypri_group,
													 SPres[DrugCount].DL.preferred_flg,
													 SPres[DrugCount].DL.preferred_largo,
													 SPres[DrugCount].DL.multi_pref_largo,
													 1,		// Perform substitution on drugs with Preferred Status = 3.
													 Rx->doctor_id,
													 v_MemberIdentification,
													 v_IdentificationCode,
													 &LargoToDispense,
													 NULL,	// Specialist Drug Flag pointer
													 NULL,	// Parent Group Code pointer
													 NULL,	// Member Price Code pointer
													 &DispenseAsWritten,
													 NULL,	// In-health-basket pointer
													 NULL,	// Rule Status pointer
													 &GenericDrugRow,
													 &FindPref_err);

								// DonR 30Aug2023 User Story #473527: If we're here, the current pass through the loop is *not*
								// part of a "simulation" to find the best preferred generic alternative. Since we now know the
								// default drug to sell (either the original or the default generic substitute), we can set a
								// flag variable to tell us whether we will want to run a "simulation" with other generic
								// options. Note that while most of the relevant parameters will be the same for non-generics
								// and generic substitutes, the package size may be different - so we need to choose which
								// package size to use. Note also that if substitution is disabled entirely (either because the
								// prescribed drug's Preferred Status is 2 or because the doctor nixed substitution), there's no
								// point in choosing an optimal preferred alternative even if the other conditions are met.
								// DonR 17Dec2024 BUG FIX #375452: The generic-drug package-size optimization logic needs to
								// work for Chanut Virtualit (Trn. 6101) the same as it does for 6001 - so I'm removing the
								// "only 6001" condition from this "if" statement.
								SPres[DrugCount].NeedToFindBestPreferredPackageSize =
									(	( SPres[DrugCount].DL.largo_type		== 'T')											&&	// Treatment drugs only.
										( SPres[DrugCount].DL.economypri_group	>  0)											&&	// Drug has generic substitutes.
										( SPres[DrugCount].DL.multi_pref_largo	>  0)											&&	// ...And more than one of them is "preferred".
										( SPres[DrugCount].DL.preferred_flg		!= 2)											&&	// The prescribed drug allows substitution.
										(!DispenseAsWritten)																	&&	// Doctor didn't disable substitution.
										(!SPres[DrugCount].BestPreferredPackageSizeChosen)											// We haven't already chosen the optimal preferred drug.
									);
//if (!TikrotProductionMode)
//GerrLogMini (GerrId, "6001: After find_preferred_drug(), Line %d Largo %d, simulation trigger %d.",
//	DrugCount, LargoPrescribed, SPres[DrugCount].NeedToFindBestPreferredPackageSize);

							}	// TestingAlternatePackageSizeGenerics is FALSE, so call find_preferred_drug().

							// Don't substitute if doctor has filled out a "dispense as written" ishur (Form 90/92).
							// Also, if drug's preferred_flg is 2, don't do the substitution.
							// If the doctor has provided a "dispense as written" ishur, Trn. 6003 will
							// allow "as-if-preferred" participation; and if not, member will pay based
							// on the drug's default participation conditions.
							if ((LargoToDispense					!= Rx->largo_prescribed)	&&
								(SPres[DrugCount].DL.preferred_flg	!= 2)						&&
								(!DispenseAsWritten))
							{
								// Swap in the preferred generic drug for the prescribed drug - but save the original!
// WORKINGPOINT: NEED TO ACCOUNT FOR DIFFERENT PACKAGE SIZES!!!
								SPres[DrugCount].DL_prescribed			= SPres[DrugCount].DL;	// Should be redundant, as this was already done above.
								SPres[DrugCount].DL						= GenericDrugRow;
								SPres[DrugCount].LargoBlockedForMember	= 0;	// Reset to default, since now we're dispensing a different drug.

								// DonR 21Nov2021 User Story #196891: If the member has blocked drugs and we're making a generic
								// substitution, look up the generic drug in the member_blocked_drugs table.
								// DonR 13Mar2025 User Story #384811: To support more detailed drug-blocking based on
								// different categories of Darkonaim (Maccabi, Harel Tourists, Harel Foreign Workers),
								// add Darkonai Type (3 times) to the READ_CheckDrugBlockedForMember parameter list.
								if ((Member.has_blocked_drugs) || (SPres[DrugCount].DL.has_member_type_exclusion))	// Don't waste a DB lookup if we know we won't get results.
								{
									ExecSQL (	MAIN_DB, READ_CheckDrugBlockedForMember,
												&RowsFound,
												&Member.ID,
												&Member.darkonai_type,	&Member.darkonai_type,	&Member.darkonai_type,
												&LargoToDispense,		&Member.ID_code,		END_OF_ARG_LIST			);

									if ((SQLCODE == 0) && (RowsFound > 0))
									{
										// Mark this drug as blocked - so for private pharmacies, we'll know we have to
										// force participation to 100%, and we'll pass an indicator to the Nihul Tikrot
										// application so it knows to leave this item out of its calculations.
										// NOTE: SPres is already initialized to all-zeroes, so we don't need a separate
										// initialization for SPres[i].LargoBlockedForMember.
										SPres[DrugCount].LargoBlockedForMember = 1;
									}
									else
									{
										if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
										{
											SQLERR_error_test ();
										}
									}
								}	// There are blocked drugs for this member.
							}	// Substituting preferred drug for prescribed drug.


							// DonR 07Jun2015: Moved call to predict_member_participation() inside the "this drug is not
							// covered by an AS/400 ishur" block, since we don't grant other discounts if we're getting
							// participation (even if it's full price!) from an AS/400 ishur.
							//
							// Predict member participation and generate discount-possible message code, if applicable.
							// Note that Doctor ID Type is zero (= Maccabi doctor) by definition for prescriptions in doctor_presc.
							//
							// DonR 30Jan2019 CR #27234: If the requesting pharmacy does not have "hesder Maccabi", do *not*
							// calulate predicted participation - just send the full price.
							// DonR 16Aug2021 User Story #163882: Treat darkonaim-plus people who always pay 100% (minus shovarim
							// they get from their insurance company) the same as people buying drugs at non-hesder pharmacies.
							// DonR 21Nov2021 User Story #196891: Also force 100% participation for any drug that's blocked
							// for this member.
							// DonR 28Apr2025 User Story #390071: Add doctor-chosen Rule Number to predict_member_participation()
							// arguments, since 6003 now uses these rules automatically to grant discounts without requiring a
							// pharmacy ishur.
							if ((HESDER_MACCABI) && (!Member.force_100_percent_ptn) && (!SPres[DrugCount].LargoBlockedForMember))
							{
								err = predict_member_participation (&Member,
																	&SPres[DrugCount].DL,
																	&Phrm_info,
																	0,	// Doctor ID Type.
																	Rx->doctor_id,
																	Rx->visit_date,
																	Rx->rule_number,					// DonR 28Apr2025 User Story #390071.
																	&SPres[DrugCount].PriceCode,
																	&SPres[DrugCount].PricePercent,
																	&SPres[DrugCount].FixedPriceFlag,
																	&SPres[DrugCount].ReducedPrice,
																	&PermissionType,
																	&SPres[DrugCount].InsuranceUsed,	// DonR 29Jun2023 User Story #461368: Needed now!
																	&SPres[DrugCount].InHealthBasket,
																	NULL);	// Error Code		- NIU in Trn. 6001.
// GerrLogMini (GerrId, "Got price code %d from predict_member_participation for Largo %d.", SPres[DrugCount].PriceCode, SPres[DrugCount].DL.largo_code);
							}
							else
							{
								// Members buying drugs at non-hesder pharmacies, as well as darkonaim-plus
								// people who don't get Maccabi discounts, pay full price.
								SPres[DrugCount].PriceCode			= 1;	// = 100%
								SPres[DrugCount].FixedPriceFlag		= 0;	// = No discounted price
								SPres[DrugCount].ReducedPrice		= 0;	// = No discounted price
								PermissionType						= 0;	// = Full-price participation is not dependent on "Prati Plus".
							}

							SPres[DrugCount].PtnRequiresPratiPlus = (PermissionType == 6) ? 1 : 0;

						}	// Prescribed drug is not covered by AS/400 ishur.


						// DonR 17Aug2022 BUG FIX: The 200-some line section below was originally further up,
						// *before* we substitute generic drugs for what the doctor prescribed. This meant
						// that the "PrevPurchaseWithSameLargo" flag was being set FALSE even when the drug
						// being sold is exactly the same drug as the member previously bought! The solution
						// is to move this code down here, *after* the call to find_preferred_drug().

						// DonR 25May2022: To support the "reason code" logic below, read in previous-purchase
						// data and perform those tests on it that don't depend on stuff (like Prescription Type)
						// that's specific to specific prescriptions. This way, we perform the required database
						// lookup(s) only once per Largo Code.
						//
						// Several different tests (for pickup and also for conversation required) involve purchase
						// history for the current drug or a generic substitute. Rather than run multiple queries,
						// cursor through the history once - and take "notes"! (Most tests look only at the most
						// recent purchase; others look at generic substitutes with the same shape code at any time
						// within the allowed date range.)
						FirstRow = 1;

						// Since we're not yet sure we're going to find any relevant previous purchases
						// for this drug, we should initialize the drug's Previous Purchase Data ("PPD")
						// structure to all-zero (= FALSE for booleans, zero for numbers, and "" for
						// strings). This is actually redundant since we earlier initialized the entire
						// SPres structure to all-zero; but a little paranoia is a good thing!
						// We also need to initialize the single-instance PrevPurchase structure - otherwise
						// it will still have values from the previous drug! (We could do this by copying
						// from PPD to PrevPurchase, but an explicit memset() seems like better practice.)
						memset ((char *)&SPres[DrugCount].PPD,	0, sizeof(TPrevPurchaseData));
						memset ((char *)&PrevPurchase,			0, sizeof(TPrevPurchaseData));

						// DonR 13Jan2022: Instead of the global parameter OnlineOrderRememberUsageMonths (loaded
						// from sysparams/usage_memory_mons) use the pharmacy_type_params version.
						MinPurchaseDate		= AddMonths (SysDate, (0 - Phrm_info.usage_memory_mons));

						LargoToDispense		= SPres[DrugCount].DL.largo_code;
						economypri_group	= SPres[DrugCount].DL.economypri_group;
						parent_group_code	= SPres[DrugCount].DL.parent_group_code;

						// Note that we read prescription_drug values into the PrevPurchase structure; most of
						// these values are of interest only for the first (= most recent) row that we read.
						// We don't want to overwrite the values we want to remember from the first row with
						// values from later rows!
						DeclareAndOpenCursorInto (	MAIN_DB, TR6101_READ_CheckPriorPurchasesToAllowPickup,
													&PrevPurchase.PrevLargoBought,		&PrevPurchase.PrevUseInstrTemplate,	&PrevPurchase.PrevShapeCodeNew,
													&PrevPurchase.PrevUnitsPerDose,		&PrevPurchase.PrevDosesPerDay, 		&PrevPurchase.PrevHowToTakeCode,
													&PrevPurchase.PrevUnitCode,			&PrevPurchase.PrevCourseTreatDays,	&PrevPurchase.PrevCourseLength,
								
													&PrevPurchase.PrevCourseUnits,		&PrevPurchase.PrevDaysOfWeek,		&PrevPurchase.PrevTimesOfDay,			
													&PrevPurchase.PrevSideOfBody,		&PrevPurchase.PrevDuration,			&PrevPurchase.PrevCourseUnitLength,

													&v_MemberIdentification,			&MinPurchaseDate,					&LargoToDispense,
													&economypri_group,					&v_IdentificationCode,				END_OF_ARG_LIST						);

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						}

						do
						{
							FetchCursor (	MAIN_DB, TR6101_READ_CheckPriorPurchasesToAllowPickup	);

							if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
							{
								break;
							}
							else
							{
								if (SQLERR_error_test ())
								{
									SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
									break;
								}
							}

							if (FirstRow)
							{
								FirstRow = 0;

								// For the first row *only*, copy what we read from prescription_drugs to the
								// Doctor Prescription's PPD structure for later use. (Note that the simple
								// pointer variable PPD has already been set to &SPres[DrugCount].PPD above.)
								*PPD = PrevPurchase;

								// If we get here, we know that we successfully FETCHed a previous-purchase row.
								PPD->FoundPreviousPurchase = 1;

								// Conversation condition 1.3 looks at any row in the SELECT results.
								// DonR 25May2022: Not changing anything, but pointing out that the previous
								// comment does not appear correct since we're within the "if (FirstRow)" block.
								if (PPD->PrevLargoBought == LargoToDispense)
								{
									PPD->PrevPurchaseWithSameLargo = 1;
								}

								// Since we're storing the previous-purchase data for later use, we might as well
								// perform the StripAllSpaces() calls now - there's no sense in stripping spaces
								// from the same string multiple times!
								StripAllSpaces (PPD->PrevUnitCode	);
								StripAllSpaces (PPD->PrevCourseUnits);
								StripAllSpaces (PPD->PrevDaysOfWeek	);
								StripAllSpaces (PPD->PrevTimesOfDay	);
								StripAllSpaces (PPD->PrevSideOfBody	);

								// Convert PrevUnitsPerDose to PrevAmtPerDose, to match how the Amount Per Dose
								// is stored in doctor_presc (e.g. 150 converts to 1.50).
								PPD->PrevAmtPerDose = (double)PPD->PrevUnitsPerDose / 100.0;

								// DonR 22Oct2023 User Story #487170 - set up the Course Length in standardized days.
								// Note that we're not guaranteed a non-zero value of PrevCourseUnitLength, so we
								// need to use it as a multiplying factor *only* when it has a value > 0 (which in
								// practice means 7 or 30, for weeks or months respectively).
								PPD->PrevCourseLengthDays = (PPD->PrevCourseUnitLength > 1) ?
																PPD->PrevCourseLength * PPD->PrevCourseUnitLength :
																PPD->PrevCourseLength;
								switch (PPD->PrevCourseLengthDays)
								{
									case  28:
									case  29:
									case  31:	PPD->PrevCourseLengthDays =  30;	break;

									case  56:
									case  58:
									case  62:	PPD->PrevCourseLengthDays =  60;	break;

									case  84:
									case  87:
									case  93:	PPD->PrevCourseLengthDays =  90;	break;

									case 112:
									case 116:
									case 124:	PPD->PrevCourseLengthDays = 120;	break;

									default:	break;
								}
								// DonR 22Oct2023 User Story #487170 end.

							}	// This is the first (= most recent) prior sale in the SELECT cursor.

							// Pickup condition 1.7 looks at any row in the SELECT results.
							// (Note that the value read from prescription_drugs is in the PrevPurchase
							// structure, and we're setting PrevPurchaseWithSameShape in the PPD structure
							// that we copied when FirstRow was TRUE.)
							if (PrevPurchase.PrevShapeCodeNew == SPres[DrugCount].DL.shape_code_new)
							{
								PPD->PrevPurchaseWithSameShape = 1;
							}
						}
						while ((SQLCODE == 0) && (!PPD->PrevPurchaseWithSameShape));

						CloseCursor (MAIN_DB, TR6101_READ_CheckPriorPurchasesToAllowPickup);

						// Marianna 05Dec2021 : If PrevPurchaseWithSameShape is still FALSE, perform an extra lookup
						// to find previous purchases of *unrelated* items with the same Shape Code.
						if ((SPres[DrugCount].DL.needs_patient_instruction) && (!PPD->PrevPurchaseWithSameShape))
						{
							RowsFound = 0;	// Marianna : 05Dec2021 for new query. DonR: Probably not really needed, but harmless.

							//Marianna 05Dec2021 : query that check count of same shapecodenew
							ExecSQL (	MAIN_DB, TR6101_READ_CountSameShapeCode,
										&RowsFound,
										&v_MemberIdentification	,	&MinPurchaseDate	,	&SPres[DrugCount].DL.shape_code_new	,
										&v_IdentificationCode	,	END_OF_ARG_LIST													);

							if ((SQLCODE == 0) && (RowsFound > 0))
							{
								PPD->PrevPurchaseWithSameShape = 1;
							}
						}	// Need extra lookup for previous purchase of unrelated items with same Shape Code.
						// DonR 17Aug2022 BUG FIX ends here.


						// Retrieve the to-be-sold drug's Yarpa Price so we can check (later on) whether it's
						// too expensive for pickup/delivery, and also use it to calculate member participation.
						// Note that we need to do this for Trn. 6001 as well as 6101, since we give a "too
						// expensive for pickup" reason code even for ordinary 6001's.
						ExecSQL (	MAIN_DB, READ_PriceList_simple,
									&Yarpa_Price,						&Maccabi_Price,				&Supplier_Price,
									&SPres[DrugCount].DL.largo_code,	&Phrm_info.price_list_num,	END_OF_ARG_LIST		);

						SPres[DrugCount].YarpaPrice		= (SQLCODE == 0) ? Yarpa_Price		: 0;
						SPres[DrugCount].MaccabiPrice	= (SQLCODE == 0) ? Maccabi_Price	: 0;
// GerrLogMini (GerrId, "Got Yarpa Price %d for Largo %d Price List Code %d, SQLCODE = %d.", Yarpa_Price, SPres[DrugCount].DL.largo_code, Phrm_info.price_list_num, SQLCODE);

						// DonR 27Apr2021 "Chanut Virtualit": If this is a Chanut Virtualit request and we haven't
						// already copied in the drug's Shape Name, look it up now in drug_shape.
						// DonR 20Jan2022: Read "home_delivery_ok" flag from drug_shape and store it
						// as "DeliverWithoutConsultation".
						if ((TransactionID_in == 6101) && (*SPres[DrugCount].ShapeName ==  (char)0))
						{
							ExecSQL (	MAIN_DB, TR6101_GetDrugShapeName,
										&SPres[DrugCount].ShapeName,			&SPres[DrugCount].DeliverWithoutConsultation,
										&SPres[DrugCount].DL.shape_code_new,	END_OF_ARG_LIST									);

							StripAllSpaces (SPres[DrugCount].ShapeName);
						}

						short		to_age;						//Marianna 23Oct2022 BUG 272058
						short		extend_rule_days;			//Marianna 23Oct2022 BUG 272058
						int			AdjustedMemberDateOfBirth;	//Marianna 27Oct2022 BUG 272058
						int			AdjustedMemberAge;			//Marianna 27Oct2022 BUG 272058

						// DonR 18Jan2022: Because we send a "reason code" (18) based on whether a full-price sale
						// is forbidden, we need to test for this condition *before* we set up all our reason codes.
						// DonR 20Jan2022: If there is a Maccabi Price for this item, we will use that if all other
						// reasons for a reduced price are inapplicable. In this case, we do *not* want to send a
						// "100% forbidden" message.
						FullPriceSaleForbidden = 0;	// Needs to be reset for each drug!

						if ((SPres[DrugCount].FoundAs400Ishur					== false)	&&	// AS/400 Ishur not found.
							(SPres[DrugCount].PriceCode							== 1)		&&	// 100% participation.
							(SPres[DrugCount].ReducedPrice						== 0)		&&	// No fixed-price discount.
							(SPres[DrugCount].MaccabiPrice						== 0)		&&	// DonR 20Jan2022: A Maccabi Price suppresses the message.
							(HESDER_MACCABI											)		&&	// DonR 30Sep2019 CR #27234.
							(!Member.force_100_percent_ptn							)		&&	// DonR 17Aug2021 User Story #163882.
							(!SPres[DrugCount].LargoBlockedForMember				)		&&	// DonR 21Nov2021 User Story #196891.
							(SPres[DrugCount].DL.largo_type						== 'T')		&&	// This drug is a "treatment".
							(SPres[DrugCount].DL.no_presc_sale_flag				== 0)		&&	// This drug requires a prescription.
//							(MACCABI_PHARMACY)												&&	// Transaction was initiated by a Maccabi pharmacy.
							(MACCABI_PHARMACY || (CONSIGNMENT_SALE(SPres[DrugCount].DL)))	&&	// DonR 20Apr2023 User Story #432608: MaccabiPharm OR consignment sale.
							(Member.MemberMaccabi))												// Maccabi member.
						{
							// See if the drug being sold has an applicable automatic "nohal" that would apply to this
							// member *if* s/he had appropriate extra insurance.
							if ((SPres[DrugCount].DL.rule_status			== 0)	&&
								(SPres[DrugCount].DL_prescribed.rule_status	== 0))
							{
								// No point in looking up "nohalim" for drugs that have no nohalim!
								SQLCODE = RowsFound = 0;	// Simulate query that came up with nothing.
							}
							else
							{
								ExecSQL (	MAIN_DB, TR6001_READ_CheckForAutoShabanNohalDiscount,
											&RowsFound,
											&SPres[DrugCount].DL.largo_code,	&SPres[DrugCount].DL_prescribed.largo_code,
											&Member.age_months,					&Member.age_months,
											&Member.sex,						&SysDate,
											&ROW_NOT_DELETED,					&Member.MemberMaccabi,
											&Member.MemberHova,					&Member.MemberKeva,
											END_OF_ARG_LIST																		);
							}	// Need to look up applicable "nohalim".

							// If we didn't find an automatic "nohal" the would apply if the member had additional
							// insurance, check for specialist discounts that might be applicable if s/he had
							// additional insurance.
							if ((SQLCODE											== 0)		&&	// No DB error from the previous SELECT.
								(RowsFound											== 0)		&&	// No relevant "nohalim" were found.
								((SPres[DrugCount].DL.specialist_drug				>  0)	||		// Drug to be sold is a specialist drug...
									(SPres[DrugCount].DL_prescribed.specialist_drug	>  0)))			// ...OR the original drug prescribed is a specialist drug.
							{
								ExecSQL (	MAIN_DB, TR6001_READ_CheckForAutoShabanSpecialistDiscount,
											&RowsFound,
											&Rx->doctor_id,						&ROW_NOT_DELETED,
											&SPres[DrugCount].DL.largo_code,	&SPres[DrugCount].DL_prescribed.largo_code,
											&Member.MemberMaccabi,				&Member.MemberHova,
											&Member.MemberKeva,					&ROW_NOT_DELETED,
											END_OF_ARG_LIST																		);
							}	// Need to check for potential specialist discount.

							// Marianna 20Oct2022 BUG 272058
							// If we didn't find an automatic "nohal" and didn't find for specialist discounts 
							// check for drug_extension.
							if ((SQLCODE	== 0) &&	// No DB error from the previous SELECT.
								(RowsFound	== 0))		// No relevant specialist discounts were found.					
							{
								DeclareAndOpenCursorInto (	MAIN_DB, TR6101_READ_CheckForDrugExtensionPharmacyIshurim,
															&to_age,							&extend_rule_days,

															&SPres[DrugCount].DL.largo_code,	&Member.sex,
															&Member.age_months,					&Member.age_months,
															&SysDate,							&Member.insurance_type,
															&Member.current_vetek,				&Member.prev_insurance_type,
															&Member.prev_vetek,					END_OF_ARG_LIST					);

								if (SQLERR_error_test ())
								{
									SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								}
								else
								{
									do
									{
										FetchCursor (MAIN_DB, TR6101_READ_CheckForDrugExtensionPharmacyIshurim);

										if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
										{
											break;
										}
										else
										{
											if (SQLERR_error_test ())
											{
												SetErrorVar(&v_ErrorCode, ERR_DATABASE_ERROR);
												break;
											}
										}

										// copied from TR2033
										// DonR 21Feb2005: We now have an optional "age tolerance" in Drug
										// Extension, to allow for continuing treatment for a period of time
										// beyond the normal expiration of the member's eligibility.
										if ((to_age < Member.age_months) && (extend_rule_days > 0))
										{
											AdjustedMemberDateOfBirth = AddDays (Member.date_of_bearth, (0 - extend_rule_days));
											// Compute Member Age in months.
											// DonR 28Dec2015: Change age logic to be more intuitive. A newborn baby's age
											// in months will now be zero until s/he is in fact a month old; in all cases,
											// Member Age will be the number of *completed* months of life. GenMonsDif()
											// already returns the correct value - so all we have to do is stop adding 1 to it.

											AdjustedMemberAge = GetMonsDif (SysDate, AdjustedMemberDateOfBirth);
										}
										else
										{
											AdjustedMemberAge = Member.age_months;
										}

										// check if find "nohal" in drug_extension
										if (to_age >= AdjustedMemberAge)
										{
											RowsFound = 1;
											break;
										}

									} while ((SQLCODE == 0));

								}

								CloseCursor(MAIN_DB, TR6101_READ_CheckForDrugExtensionPharmacyIshurim);
							}	//Marianna 20Oct2022 BUG 272058: END check for drug_extension

							// No real error-trapping needed here - I hope! Note that in this case the existence of
							// a potentially-applicable "nohal" or specialist discount *disables* the message.
							if ((SQLCODE == 0) && (RowsFound == 0))
								FullPriceSaleForbidden = 1;

						}	// Need to check for forbidden 100% Maccabi-pharmacy-to-Maccabi-member sale.


						// DonR 23May2022: Moved the Participation Message Code logic here, so it will still be inside the
						// "if (!SameDrugSameDoctor)" block, while all the "reason code" logic will be put *outside* the block.

						// DonR 07Jun2015: Generate Participation Message Code - basically, a prediction of what Transaction
						// 6003 will say about the availability of discounts for this drug. Some of these codes are "advisory",
						// while others (e.g. "you can't sell this drug without an AS/400 ishur") will actually prevent the
						// sale from going through. (Note that we don't test Prescription Source here - the assumption is
						// that the Ishur Required Flag is enough to indicate that this error is appropriate.)
						// DonR 17Aug2021 User Story #163882: Disable most of the Price Message Code logic for Darkonaim-Plus
						// people who automatically pay 100% for everything. The only ones that I'm not (yet?) disabling are
						// the first two; I need to check whether these people can buy "ishur required" drugs without an ishur,
						// and the second one doesn't apply unless there *is* an ishur, which should probably never be the case
						// for these people.
						SPres[DrugCount].PriceMessageCode = 0;	// This should already be the case.

						// First, check for "AS/400 Ishur Required".
						// QUESTION: Are ishur required in this case for Darkonaim-Plus who automatically pay
						// 100% for everything?
						if ((SPres[DrugCount].PriceCode			== 1)		&&	// 100% participation.
							(SPres[DrugCount].ReducedPrice		== 0)		&&	// No fixed-price discount.
							(SPres[DrugCount].FoundAs400Ishur	== false)	&&	// AS/400 Ishur not found.
							(SPres[DrugCount].DL.ishur_required	== 9))			// This drug requires an AS/400 ishur (assuming no other discount).
						{
							SPres[DrugCount].PriceMessageCode = TR6001_AS400_ISHUR_REQUIRED;
						}

						// Next, check for special "in hospital" pharmacy code in ishur. Note that this error is not
						// dependent on discounts or Prescription Source.
						// DonR 18Feb2018: In fact, this "if" can *never* be true! We already select ishurim based on
						// "pharmacy code = requesting pharmacy OR pharmacy code = 0" - so it's impossible for us to
						// have read an ishur with a different non-zero pharmacy code than the code of the pharmacy
						// that sent the current request!
						if ((SPres[DrugCount].FoundAs400Ishur)					&&	// AS/400 Ishur *was* found.
							(IshurPharm							!= 0)			&&	// Ishur includes a non-zero Pharmacy Code.
							(IshurPharm							!= v_PharmNum))		// The Pharmacy Code in the ishur is different from the pharmacy sending Trn. 6001.
						{
							// Note that as of 07Jun2015, Iris has not asked for other wrong-pharmacy error codes in
							// Transaction 6001. If we want to be complete, we should add logic for the general-case
							// "private pharmacy can't sell against ishur that specifies another pharmacy" error,
							// as well as testing for pharmacy-type mismatch (which returns the same error code as
							// the pharmacy-code-mismatch case).
							if ((IshurPharm == 995482) || (IshurPharm == 997582))
							{
								SPres[DrugCount].PriceMessageCode = TR6001_PH995482_IN_ISHUR;
							}
							else
							{
								//Marianna 27Oct2022 BUG 272058: We find pharmacy codes other than the requesting pharmacy
								SPres[DrugCount].PriceMessageCode = TR6001_SPEC_PR_FOR_OTHER_PHARM_WRN;
							}
						}

						// Third, test for possible discount from a non-automatic "nohal" that can be activated
						// by a Pharmacy Ishur.
						// DonR 06Nov2022: Note that this test is at least somewhat redundant - look at how
						// TR6101_READ_CheckForDrugExtensionPharmacyIshurim is used later on. At some point
						// we should look at combining these two lookups!
						if ((SPres[DrugCount].PriceMessageCode				== 0)		&&	// No message has yet been set.
							(SPres[DrugCount].FoundAs400Ishur				== false)	&&	// AS/400 Ishur not found.
							(SPres[DrugCount].PriceCode						== 1)		&&	// 100% participation.
							(SPres[DrugCount].ReducedPrice					== 0)		&&	// No fixed-price discount.
							(HESDER_MACCABI										)		&&	// DonR 30Sep2019 CR #27234.
							(!Member.force_100_percent_ptn						)		&&	// DonR 17Aug2021 User Story #163882.
							(!SPres[DrugCount].LargoBlockedForMember			)		&&	// DonR 21Nov2021 User Story #196891.
							((SPres[DrugCount].DL.rule_status				>  0)	||		// There is at least one drug_extension "nohal" for this drug...
							 (SPres[DrugCount].DL_prescribed.rule_status	>  0)))			// ...OR for the original drug prescribed.
						{
							ExecSQL (	MAIN_DB, TR6001_READ_CheckPharmacyIshurPossibility,
										&RowsFound,
										&SPres[DrugCount].DL.largo_code,	&SPres[DrugCount].DL_prescribed.largo_code,
										&Member.age_months,					&Member.age_months,
										&Member.sex,						&SysDate,
										&ROW_NOT_DELETED,					&Member.MemberMaccabi,
										&Member.MemberHova,					&Member.MemberKeva,
										&Phrm_info.pharmacy_permission,		&Phrm_info.pharmacy_permission,
										&Phrm_info.pharmacy_permission,		&Member.insurance_type,
										&Member.current_vetek,				&Member.prev_insurance_type,
										&Member.prev_vetek,					END_OF_ARG_LIST									);

							// No real error-trapping needed here - I hope!
							if ((SQLCODE == 0) && (RowsFound > 0))
								SPres[DrugCount].PriceMessageCode = TR6001_PH_ISHUR_POSSIBLE;
						}	// Need to check possibility of getting a discount with a pharmacy ishur.

						// Fourth, test for possible specialist discount.
						if ((SPres[DrugCount].PriceMessageCode					== 0)		&&	// No message has yet been set.
							(SPres[DrugCount].FoundAs400Ishur					== false)	&&	// AS/400 Ishur not found.
							(SPres[DrugCount].PriceCode							== 1)		&&	// 100% participation.
							(SPres[DrugCount].ReducedPrice						== 0)		&&	// No fixed-price discount.
							(HESDER_MACCABI											)		&&	// DonR 30Sep2019 CR #27234.
							(!Member.force_100_percent_ptn							)		&&	// DonR 17Aug2021 User Story #163882.
							(!SPres[DrugCount].LargoBlockedForMember				)		&&	// DonR 21Nov2021 User Story #196891.
							((SPres[DrugCount].DL.specialist_drug				>  0)	||		// Drug to be sold is a specialist drug...
							 (SPres[DrugCount].DL_prescribed.specialist_drug	>  0)))			// ...OR the original drug prescribed is a specialist drug.
						{
							ExecSQL (	MAIN_DB, TR6001_READ_CheckSpecialistDiscountPossibility,
										&RowsFound,
										&SPres[DrugCount].DL.largo_code,	&SPres[DrugCount].DL_prescribed.largo_code,
										&Member.MemberMaccabi,				&Member.MemberHova,
										&Member.MemberKeva,					&ROW_NOT_DELETED,
										&Member.insurance_type,				&Member.current_vetek,
										&Member.prev_insurance_type,		&Member.prev_vetek,
										END_OF_ARG_LIST																		);

							// No real error-trapping needed here - I hope!
							if ((SQLCODE == 0) && (RowsFound > 0))
								SPres[DrugCount].PriceMessageCode = TR6001_SPECIALIST_POSSIBLE;
						}	// Need to check for possible specialist participation.

						// Fifth (and finally), check to see if this sale would be forbidden at a Maccabi pharmacy
						// because of predicted 100% participation.
						// DonR 18Jan2022: Because we need to know whether the sale will be forbidden further
						// up in the code (to set "reason code" 18), I moved the actual logic before all the
						// "reason code" stuff. So here, all we need to do is use the FullPriceSaleForbidden
						// value we set up above.
						if ((SPres[DrugCount].PriceMessageCode == 0) && (FullPriceSaleForbidden))	// No message has yet been set and the drug can't be sold at full price at MaccabiPharm.
						{
							SPres[DrugCount].PriceMessageCode = TR6001_100_PCT_FORBIDDEN;
						}	// Need to check for forbidden 100% Maccabi-pharmacy-to-Maccabi-member sale.

						// End of Participation Message Code section.

						// DonR 23May2022: This is now the end of the "if (!SameDrugSameDoctor)" block; all
						// the "reason code" logic will execute unconditionally for all prescriptions.

					}	// This is the first occurrence of this Largo Code/prescribing doctor in the list of
						// prescriptions retrieved (i.e. SameDrugSameDoctor is FALSE).


					// DonR 14Nov2023 User Story #473527: Set some flags used when comparing alternate
					// preferred drugs. Note that these flags need to be set separately for each doctor
					// prescription, since two of them depend on the quantity prescribed.
					// DonR 15Feb2024 User Story #473527 FIX: If we're dealing with stuff like gels (e.g.
					// Voltaren) and the doctor prescribed X packages rather than units, we need to work as
					// if we were dealing with units for purposes of deciding which alternative preferred
					// drug is best.

					// Reset OP, Total Units, and Quantity Method to the original values from the database.
					// NOTE: We shouldn't have to bother doing this for adjusted_monthly_units, since it's
					// set once after we read the prescription and doesn't change after that.
					Rx->op			= Rx->original_op;
					Rx->total_units	= Rx->original_total_units;
					Rx->qty_method	= Rx->original_qty_method;

					// If the doctor prescribed in terms of packages (i.e. for gels and similar stuff), use
					// the *prescribed* drug's package size to determine the effective units prescribed.
					// DonR 27Feb2025 Bug #395667 Part 1: Use the adjusted monthly units-prescribed value
					// rather than the "raw" value - this way if the doctor prescribes 30 pills of a
					// 28-pill-per-OP drug, we'll consider that an even number of packages.
					UnitsPrescribed = (Rx->qty_method == 1)	? (Rx->op * SPres[DrugCount].DL_prescribed.effective_package_size)
															: Rx->adjusted_monthly_units;
//															: Rx->total_units;

					// 1) If total_units is zero, then by definition there will be no remainder - so
					//    EvenPackagesToFill will be TRUE.
					// DonR 27Feb2025 Bug #395667 Part 2: Use the adjusted monthly package-size value
					// rather than the "raw" value - this way if the doctor prescribes 30 pills of a
					// 28-pill-per-OP drug, we'll consider that an even number of packages.
//					SPres[DrugCount].EvenPackagesToFill		= ((UnitsPrescribed % SPres[DrugCount].DL.effective_package_size) == 0);
					SPres[DrugCount].EvenPackagesToFill		= ((UnitsPrescribed % SPres[DrugCount].DL.monthly_package_size) == 0);

					// 2) If total_units is zero, use the OP number from Clicks; otherwise use integer division.
					//    Note that we're not concerned here with leftover units, only the number of full packages.
					//    (DonR 15Feb2024: Since we're computing Total Units for cases where the doctor has specified the
					//    amount prescribed in terms of OP, we shouldn't really have to worry about units == 0 here - but
					//    I'll leave the math there just in case.)
					SPres[DrugCount].NumWholePackages		= (UnitsPrescribed > 0) ?
																	(UnitsPrescribed / SPres[DrugCount].DL.effective_package_size) :
																	Rx->op;
//GerrLogMini (GerrId, "\nLargo %d gives EvenPkg %d, %d whole OP to fill for %d total units.\nUnitsPrescribed = %d, effective_package_size = %d, NumWholePackages = %d.",
//	SPres[DrugCount].DL.largo_code, SPres[DrugCount].EvenPackagesToFill, SPres[DrugCount].NumWholePackages, Rx->total_units,
//	UnitsPrescribed, SPres[DrugCount].DL.effective_package_size, SPres[DrugCount].NumWholePackages);

					// 3) No special math for "same Parent Group".
					SPres[DrugCount].SameParentGroupAsRx	= (SPres[DrugCount].DL.parent_group_code == SPres[DrugCount].DL_prescribed.parent_group_code);
//GerrLogMini (GerrId, "\nRx Largo %d sell %d, Qty Method %d, %d/%d prescribed, UnitsPrescribed %d, EvenPackagesToFill %d, NumWholePackages %d.",
//	SPres[DrugCount].DL_prescribed.largo_code, SPres[DrugCount].DL.largo_code, Rx->qty_method, Rx->op, Rx->total_units, UnitsPrescribed,
//	SPres[DrugCount].EvenPackagesToFill, SPres[DrugCount].NumWholePackages);
					// DonR 14Nov2023 User Story #473527 end.


					// DonR 23May2022: The section below now executes independently of the SameDrugSameDoctor flag, so
					// we can be sure that each prescription we report is individually checked for the various "reason
					// codes" and "conversation reason codes".

					// DonR 19May2021: For Chanut Virtualit (Trn. 6101), use separate logic to determine
					// if the prescribed item (A) can be ordered online, (B) can be picked up by the
					// member after ordering, and (C) can be delivered. Once we've done that, we need
					// to check whether a consultation with a pharmacist is required - the code is
					// written on the assumption that the consultation logic is independent of the logic
					// for whether sale/pickup/delivery is permitted.
					//
					// DonR 17Aug2021: Per Iris Shaya, we now want to perform the "Chanut Virtualit" logic for both
					// Transaction 6001 and 6101 - with the "old-style" delivery-permitted logic as part of the output
					// for Transaction 6001, as well as the Reason Forbidden Code from the "Chanut Virtualit" logic.
					// Pharmacies will get a download of the virtual_store_reason_texts table, which will include values
					// for the permitted/forbidden flags for each Reason Code; so pharmacies that want to switch to the
					// newer, more detailed logic will simply ignore the old Delivery Permitted flag and use the Reason
					// Code to look up which operations are (and are not) permitted. Accordingly, almost all this code
					// will execute exactly the same for Transactions 6001 and 6101; the only difference is that for
					// Transaction 6001 we'll disable the reason-text lookup, since pharmacies will perform that lookup
					// against their own local copy of the table and we don't want to do extra work and slow down the
					// system.
					bool	PrescriptionTypeMismatch	= 0;
					bool 	UsageInstructionChanged		= 0; //Marianna 01Dec2021 : 0- no change, 1 - changed

					// Pickup condition 1.6 looks only at the most recent previous purchase.
					PrescriptionTypeMismatch = (PPD->PrevUseInstrTemplate != Rx->prescription_type) ? 1 : 0;

					// Marianna 09Dec2021: check if there is change in instructions, done only for the *most recent* purchase.
					// Marianna 19Jan2022: check all the fields NOT include  ' treatment_length '
					// first; look at treatment_length/duration ONLY if this is not a "tipul ratzif" prescription.
					// DonR 23Jan2022: Because numeric comparisions are a lot faster to execute than string
					// comparisons, move the treatment_length test to before the string tests.
					// DonR 24Jan2022: In order for treatment_length/duration difference to be ignored, the drug must be
					// chronic *and* the prescription must be for continuous treatment.
					// DonR 25Jan2022: In prescription_drugs, Units Per Dose is the actual value times 100 (to accomodate
					// fractional dosages, like pills split in half). Accordingly, we have to divide by 100 before comparing
					// to the value in doctor_presc - and the computation has to be done as a float.
					// DonR 26Jan2022: We need to strip trailing (and possibly leading) spaces from the string variables
					// before comparing them.
					// DonR 25May2022: These comparisons are now made against the "PPD" (= Previous Purchase Data) values
					// that were retrieved earlier, once for each Largo Code in the prescriptions list. Note that the string
					// values in PPD have already been stripped of leading and trailing spaces - there's no point in doing so
					// multiple times, so we do it when the data is read from prescription_drugs.
					// DonR 22Oct2023 User Story #487170: Instead of comparing both Course Length and Course Length Units
					// separately, we now compute Course Length in Days for both previous purchases and doctor prescriptions.
					// This way we can compare more accurately - for example, 7 days will equal 1 week. Also, disable the
					// comparison of overall duration for chronic drugs *without* looking at the Prescription Type.
					if (	( PPD->PrevUseInstrTemplate	!=	Rx->prescription_type)																				||
							( PPD->PrevAmtPerDose		!=	Rx->amt_per_dose)																					||
							( PPD->PrevDosesPerDay		!=	Rx->doses_per_day)																					||
							( PPD->PrevHowToTakeCode	!=	Rx->usage_method_code)																				||
							( PPD->PrevCourseTreatDays	!=	Rx->course_treat_days)																				||
//							( PPD->PrevCourseLength		!= 	Rx->course_len)			// DonR 22Oct2023 User Story #487170 DISABLED								||
							( PPD->PrevCourseLengthDays	!= 	Rx->course_len_days)	/* DonR 22Oct2023 User Story #487170 */										||
//							((PPD->PrevDuration			!=	Rx->treatment_length) && ((Rx->prescription_type != 0) || (SPres[DrugCount].DL.chronic_flag != 1)))	||	// Marianna 19Jan2022
							((PPD->PrevDuration			!=	Rx->treatment_length) && (SPres[DrugCount].DL.chronic_flag != 1))									||	// DonR 22Oct2023 User Story #487170 ignore Rx->prescription_type.
							// Marianna 09Dec2021 : compare strings
//							// DonR 21Feb2022: Use strncmp() to compare only the first 4 characters of Course Length Units.
//							// This way "שבוע" and "שבועות" (and "חודש" and "חודשים") will compare as equal.
							( strcmp  (PPD->PrevUnitCode	, StripAllSpaces (Rx->unit_abbreviation	))		!= 0 )												||
//							( strncmp (PPD->PrevCourseUnits	, StripAllSpaces (Rx->course_len_units	), 4)	!= 0 )	// DonR 22Oct2023 User Story #487170 DISABLED	||
							( strcmp  (PPD->PrevDaysOfWeek	, StripAllSpaces (Rx->days_per_week		))		!= 0 )												||
							( strcmp  (PPD->PrevTimesOfDay	, StripAllSpaces (Rx->morning_evening	))		!= 0 )												||
							( strcmp  (PPD->PrevSideOfBody	, StripAllSpaces (Rx->treatment_side	))		!= 0 )	)
					{
							UsageInstructionChanged = 1;
					}

					// Marianna 17Dec2024 User Story #313648
					int		DrugFoundInPriceList = 0;

					// Query to check if drug exist in price_list
					ExecSQL(MAIN_DB, TR6101_CheckItemExistsInPriceList,
							&DrugFoundInPriceList,
							&SPres[DrugCount].DL.largo_code, END_OF_ARG_LIST);
					
					SQLERR_error_test();
								

					// Now initialize various result variables.
					// Begin with the assumption that it *is* OK to order this item online, and that
					// customer pickup (without consulting a pharmacist) and home delivery are also allowed.
					// Also start with the assumption that a conversation with a pharmacist is not required.
					SPres[DrugCount].ReasonForbiddenCode		=		// I.e. no reason not to order.
					SPres[DrugCount].DisplayReasonForbidden		=		// No reason code, so no need to display it.
					SPres[DrugCount].ConversationRequired		=		// Consultation is not (yet) required.
					SPres[DrugCount].ConversationReasonCode		=		// No reason (yet) for a consultation.
					SPres[DrugCount].DisplayConversationReason	= 0;	// No reason code, so no need to display it.

					strcpy (SPres[DrugCount].ReasonForbiddenDesc,		"");
					strcpy (SPres[DrugCount].ConversationReasonDesc,	"");

					SPres[DrugCount].OnlineSalePermitted	=
					SPres[DrugCount].PickupPermitted		=
					SPres[DrugCount].DeliveryPermitted		= 1;	// Default = allow everything.


					// DonR 17Aug2021: Compute the "SuperPharm-style" delivery-permitted flag here, since
					// we now want to send pharmacies both that flag and the "Chanut Virtualit" Reason
					// Forbidden Code as part of the output from Transaction 6001. The "do-while" structure
					// allows us to avoid oodles of elses!
					do
					{
						// 1) Non-drug items and drugs available without prescription are always OK to deliver.
						if ((SPres[DrugCount].DL.largo_type != 'T') || (SPres[DrugCount].DL.no_presc_sale_flag != 0))
						{
							SPres[DrugCount].SuperPharmDeliveryPermitted = 1;	// = Permitted.
							break;
						}

						// 2) Hypnotics and narcotics are never OK to deliver.
						//    DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
						if ((SPres[DrugCount].DL.drug_type == 'H') || (SPres[DrugCount].DL.is_narcotic))
						{
							SPres[DrugCount].SuperPharmDeliveryPermitted = 2;	// = Forbidden because of the drug involved.
							break;
						}

						// 3) If the drug's "OK to deliver" flag is set TRUE (and it's not a hypnotic or narcotic),
						//    delivery is permitted regardless of prior purchases.
						// DonR 23Aug2021: Switched this bit of logic from home_delivery_ok to delivery_ok_per_shape_code.
						// The "new" value is actually from the same source as home_delivery_ok used to be (i.e. Drug Shape),
						// while home_delivery_ok is now set per drug in RK9001P.
						if (SPres[DrugCount].DL.delivery_ok_per_shape_code != 0)
						{
							SPres[DrugCount].SuperPharmDeliveryPermitted = 1;	// = Permitted.
							break;
						}

						// 4) If we get here, the item in question is a non-OTC, non-hypnotic/narcotic drug with
						//    its "OK to deliver" flag set FALSE. In this case, it can still be delivered if the member
						//    has recently bought the same drug or a related drug, and thus presumably knows how the
						//    drug is supposed to be taken.
						if (PPD->FoundPreviousPurchase)
							SPres[DrugCount].SuperPharmDeliveryPermitted = 1;	// = Permitted.
						else
							SPres[DrugCount].SuperPharmDeliveryPermitted = 3;	// = Forbidden because the member hasn't taken a similar drug recently.

					}
					while (0);
					// Check if item can be delivered - SuperPharm version for Trn. 6001 delivery-flag output.


					// The second "do" block is for determining whether sale/pickup/delivery is allowed, using
					// the more elaborate "Chanut Virtualit" logic.
					do
					{
						// 1) Set OnlineSalePermitted (output as tag "online_sale_flg").

						// Marianna 17Dec2024 User Story #313648
						// For Chanut Virtualit, items can't be ordered online if they have no entry in price_list.
						if ((!DrugFoundInPriceList) && (TransactionID_in == 6101))
						{
							SPres[DrugCount].ReasonForbiddenCode = 27;
						}
						else

						// DonR 21Nov2022 User Story #276651: If the item is "fictitious" (i.e. Largo 99999) it can't be
						// ordered online; it's a paper prescription that needs to be presented in person so the pharmacist
						// can prepare whatever the doctor ordered. (This applies only to Virtual Store requests.)
						if ((SPres[DrugCount].DL.largo_code ==  99999) && (TransactionID_in == 6101))
						{
							SPres[DrugCount].ReasonForbiddenCode = 25;
						}
						else

						// DonR 25Mar2024 User Story #540234: Don't allow cannabis sales through Chanut Virtualit.
						// Note that at least for now, we do *not* have a special pharmacy flag to allow cannabis
						// sales; it's forbidden at all Maccabi pharmacies, and thus at the "virtual" pharmacy too.
						if (SPres[DrugCount].DL.drug_type == 'K')
						{
							SPres[DrugCount].ReasonForbiddenCode = 26;
						}
						else

						// 1.1 - Narcotics.
						//       DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of drug_type.
//						if ((SPres[DrugCount].DL.drug_type == 'N') && (!Phrm_info.allow_order_narcotic))
						if ((SPres[DrugCount].DL.is_narcotic) && (!Phrm_info.allow_order_narcotic))
							SPres[DrugCount].ReasonForbiddenCode = 1;
						else

						// 1.2 - Preparations.
						if ((SPres[DrugCount].DL.needs_preparation) && (!Phrm_info.allow_order_preparation))
							SPres[DrugCount].ReasonForbiddenCode = 2;
						else

						// 1.3 - Item needs in-person measurement.
						if (SPres[DrugCount].DL.needs_patient_measurement)
							SPres[DrugCount].ReasonForbiddenCode = 3;
						else

						// Marianna 16Nov2021 NEW - needs_refrigeration = freezing
						if (SPres[DrugCount].DL.needs_refrigeration == NEEDS_FREEZER)
							SPres[DrugCount].ReasonForbiddenCode = 20;
						else

						// 1.4 - Future-dated prescriptions.
						// Marianna 01Nov2021: This applies only to Virtual Store, *not* to regular 6001 requests.
						if ((SPres[DrugCount].PrDateValidForSale == 0) && (TransactionID_in == 6101)) //Marianna 1Nov2021 added the 2nd if
						{
							SPres[DrugCount].ReasonForbiddenCode = 4;
						}
						else

						// 1.5 - Soon-to-expire prescriptions.
						// Marianna 01Nov2021: This applies only to Virtual Store, *not* to regular 6001 requests.
						// DonR 13Jan2022: Added new data parameters read from pharmacy_type_params: select_late_rx_days_filling_online_order
						// is the tolerance used in Transaction 6001 when a pharmacy is actually fulfilling an online order, and
						// allow_online_order_days_before_expiry is the "safety margin" that prevents a member from placing orders that there
						// won't be enough time to fulfill. 
						if ((TransactionID_in == 6101)	&&		// Marianna 1Nov2021 added; DonR 13Jan2022 made this the first condition.
							(AddDays (SysDate, (Phrm_info.allow_online_order_days_before_expiry - Phrm_info.select_late_rx_days_filling_online_order)) > Rx->valid_until_date))
						{
							SPres[DrugCount].ReasonForbiddenCode = 17;
						}
						else

						// 1.6 - 100% participation.
						// Marianna 01Nov2021: This applies only to "trufot" ordered from Virtual Store, *not* to regular 6001 requests.
						if ((TransactionID_in					== 6101)	&&	// Applies only to Chanut Virtualit.
							(SPres[DrugCount].DL.largo_type		== 'T')		&&	// "Trufa" (treatment drug)
							(!Phrm_info.allow_full_price_order)				&&	// Pharmacy is not allowed to sell at full price.
							(FullPriceSaleForbidden))							// Forbidden full-price sale was detected above.
						{
							SPres[DrugCount].ReasonForbiddenCode = 18;
						}

						// If we know the member can't even order this item online, obviously s/he can't
						// pick it up or have it delivered either.
						if (SPres[DrugCount].ReasonForbiddenCode != 0)
						{
							SPres[DrugCount].OnlineSalePermitted	=
							SPres[DrugCount].PickupPermitted		=
							SPres[DrugCount].DeliveryPermitted		= 0;

							break;
						}


						// 2) If we get here, we know that online ordering, at least, is permitted. Next, check
						//    if it's possible for the member to pick up the order without seeing a pharmacist.

						// (1.1 in the spec just says that if ordering is prohibited, so is pickup.)

						// 1.2 - Non-digital prescription.
						if (Rx->digital_presc_flag < 1)
							SPres[DrugCount].ReasonForbiddenCode = 8;
						else

						// Marianna 16Nov2021 NEW needs dilution
						if (SPres[DrugCount].DL.needs_dilution)
							SPres[DrugCount].ReasonForbiddenCode = 22;
						else

						// 1.3 - Drug doesn't allow pickup.
						if (!SPres[DrugCount].DL.online_order_pickup_ok)
							SPres[DrugCount].ReasonForbiddenCode = 19;
						else

						// 1.4 - Item is too expensive for pickup.
						if (SPres[DrugCount].YarpaPrice > Phrm_info.max_price_for_pickup)
							SPres[DrugCount].ReasonForbiddenCode = 5;
						else

						// Now use the results of the purchase-history lookup to decide whether we've found a
						// reason to forbid pickup (and thus delivery as well).

						// 1.5 - No recent previous purchase *and* prescription type is "discontinuous".
						// Marianna 01Nov2021: This applies only to "trufot".
						if ((Rx->prescription_type			!= 0)		&&	// Discontinuous
							(SPres[DrugCount].DL.largo_type	== 'T')		&&	// "Trufa" (treatment drug)
							(!PPD->FoundPreviousPurchase))
						{
							SPres[DrugCount].ReasonForbiddenCode	= 11;
							SPres[DrugCount].ConversationRequired	=  1;	// Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode	= 11;	// Marianna 21Feb2022: new logic by Iris
						}
						else

						// 1.6 - Most recent previous purchase had Usage Instruction Template (which comes from
						// Rx->prescription_type) different from the current Prescription Type.
						// Marianna 24Nov2021: This applies only to "trufot".
						// Usage Instruction compared to the previous purchase.
						// Marianna 12Dec2021: Iris  - this is not (UsageInstructionChanged) but (Rx->prescription_type != from the last).
						if ((SPres[DrugCount].DL.largo_type	== 'T')		&&	// "Trufa" (treatment drug)
							(PrescriptionTypeMismatch))
						{
							SPres[DrugCount].ReasonForbiddenCode	= 12;
							SPres[DrugCount].ConversationRequired	=  1;	// Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode	= 12;	// Marianna 21Feb2022: new logic by Iris
						}
						else

						// Marianna 24Nov2021 NEW
						// The member  has bought the same drug or a generic drug within the last few months
						// *and* prescription type is "discontinuous"
						// *and* there was a change in Usage Instruction fields compared to the previous purchase.
						// DonR 22Oct2023 User Story #487170: This set of conditions no longer disables pickup/delivery,
						// so I'm disabling it in this section and adding it to the "conversation only" section below.
//						if ((Rx->prescription_type			!= 0)		&&	// Discontinuous
//							(SPres[DrugCount].DL.largo_type	== 'T')		&&	// "Trufa" (treatment drug)
//							(PPD->FoundPreviousPurchase)				&&
//							(UsageInstructionChanged))
//						{
//							SPres[DrugCount].ReasonForbiddenCode	= 21;
//							SPres[DrugCount].ConversationRequired	=  1;	// Marianna 21Feb2022: new logic by Iris
//							SPres[DrugCount].ConversationReasonCode	= 21;	// Marianna 21Feb2022: new logic by Iris
//						}
//						else

						// 1.7 - No previous purchase had the same Shape Code *and* the item to be sold
						// requires the pharmacist to instruct the member in its use.
						// Marianna : No recent previous purchase, the member has not bought the same drug
						// or a generic drug within the last few months. (Not even an unrelated drug with the same Shape Code.)
						// Marianna 24Nov2021: This applies only to "trufot"  *and* prescription type is "continuous".
						if ((Rx->prescription_type			== 0)				&&	// Continuing treatment
							(SPres[DrugCount].DL.largo_type	== 'T')				&&	// "Trufa" (treatment drug)
							(SPres[DrugCount].DL.needs_patient_instruction)		&&
							(!PPD->PrevPurchaseWithSameShape)					&&
							(!PPD->FoundPreviousPurchase))
						{
							SPres[DrugCount].ReasonForbiddenCode	= 15;
							SPres[DrugCount].ConversationRequired	=  1;	// Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode	= 15;	// Marianna 21Feb2022: new logic by Iris
						}
						// No "else" here - this is the last test in this section.

						// If we know the member can't pick this item up without consulting a pharmacist, we also know that
						// s/he can't have it delivered either.
						if (SPres[DrugCount].ReasonForbiddenCode != 0)
						{
							SPres[DrugCount].PickupPermitted		=
							SPres[DrugCount].DeliveryPermitted		= 0;

							break;
						}

						// 3) If we get here, we know that online ordering and customer pickup without consulting
						//    with a pharmacist are permitted. Next, check if delivery is enabled - there are a
						//    couple of situations where pickup is OK but delivery is not.

						// (1.1 in the spec just says that if ordering/pickup is prohibited, so is delivery.)

						// 1.2 - Is this item flagged as permitting home delivery?
						if (!SPres[DrugCount].DL.home_delivery_ok)
						{
							SPres[DrugCount].ReasonForbiddenCode = 6;
						}
						else
						{
							// 1.3 - If this item requires refrigeration, is refrigerated delivery permitted?
							if ((SPres[DrugCount].DL.needs_refrigeration == NEEDS_REFRIGERATION) && (!Phrm_info.allow_refrigerated_delivery))
							{
								SPres[DrugCount].ReasonForbiddenCode = 7;
							}
						}

						// If we found a reason to forbid home delivery, set the Delivery Permitted flag FALSE.
						if (SPres[DrugCount].ReasonForbiddenCode != 0)
						{
							SPres[DrugCount].DeliveryPermitted = 0;
						}

					}
					while (0);
					// Transaction 6101 (Chanut Virtualit) - check if item can be ordered/picked up/delivered.


					// The third "do" block is for determining whether a consultation with a pharmacist
					// is required, and, if so, why.
					// Marianna 21Feb2022: if a Conversation Reason Code was already set , do not enter
					// the loop, no need to check again ConversationRequired.
					while (SPres[DrugCount].ConversationReasonCode == 0)
					{
						// 1) First look at some specific reasons that a conversation is *not* required.

						// 1.1 - Non-drug items.
						if (SPres[DrugCount].DL.largo_type != 'T')	// Not a "treatment" drug.
						{
							SPres[DrugCount].ConversationReasonCode = 9;
						}
						else

						// 1.2 - Consultation not required because drug_shape/home_delivery_ok is FALSE.
						// DonR 20Jan2022: It turns out that drug_shape/consultation_required is itself
						// not required - the older flag drug_shape/home_delivery_ok is properly interpreted
						// as meaning "home delivery is OK even without a consultation." Because the
						// drug_list/delivery_ok_per_shape_code flag is set based on the shape name rather
						// than the shape code, here I'm using the flag as read from drug_shape by shape
						// code and stored as "DeliverWithoutConsultation".
						if (SPres[DrugCount].DeliverWithoutConsultation)
						{
							SPres[DrugCount].ConversationReasonCode = 10;
						}
						else

						// Marianna 21Feb2022 : NEW LOGIC BY IRIS
						if ((Rx->prescription_type			!= 0)	&&	// Discontinuous
							(SPres[DrugCount].DL.largo_type	== 'T')	&&	// "Trufa" (treatment drug) - condition should be redundant.
							(!PPD->FoundPreviousPurchase))
						{
							SPres[DrugCount].ConversationRequired	= 1;	//Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode	= 11;	//Marianna 21Feb2022: new logic by Iris
						}
						else
								
						if ((SPres[DrugCount].DL.largo_type == 'T') &&	// "Trufa" (treatment drug) - condition should be redundant.
							(PrescriptionTypeMismatch))
						{
							SPres[DrugCount].ConversationRequired	= 1;	//Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode	= 12;	//Marianna 21Feb2022: new logic by Iris
						}
						else

						// DonR 22Oct2023 User Story #487170: Previously, this bit of code would never execute because the earlier
						// Reason 21 code blocked pickup/delivery and prevented this whole "while" block from executing. But now,
						// a change in Usage Instructions no longer prevents pickup/delivery - it just requires a conversation.
						if ((Rx->prescription_type != 0)			&&	// Discontinuous
							(SPres[DrugCount].DL.largo_type == 'T')	&&	// "Trufa" (treatment drug) - condition should be redundant.
							(PPD->FoundPreviousPurchase)			&&
							(UsageInstructionChanged))
						{
							SPres[DrugCount].ConversationRequired = 1;		//Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode = 21;	//Marianna 21Feb2022: new logic by Iris
						}
						else
								
						if ((Rx->prescription_type == 0)					&&	// Continuing treatment
							(SPres[DrugCount].DL.largo_type == 'T')			&&	// "Trufa" (treatment drug) - condition should be redundant.
							(SPres[DrugCount].DL.needs_patient_instruction)	&&
							(!PPD->PrevPurchaseWithSameShape)				&&
							(!PPD->FoundPreviousPurchase))						// Is this condition (A) necessary and (B) correct?
						{
							SPres[DrugCount].ConversationRequired = 1;		//Marianna 21Feb2022: new logic by Iris
							SPres[DrugCount].ConversationReasonCode = 15;	//Marianna 21Feb2022: new logic by Iris
						}
						else
						//END NEW LOGIC BY IRIS 21Feb2022

						// 1.3 - Member has bought the same drug within the last few months.
						// Marianna 02Dec2021: No change in  Usage Instruction compared to the previous purchase.
						// Marianna 18Jan2022: NEW check if chronic drug *and* prescription type is "continuous"
						// UsageInstructionChanged not include mesheh tipul beyamim
						if ((PPD->PrevPurchaseWithSameLargo)	&&
							(PPD->FoundPreviousPurchase)		&&	// Should be redundant - can't have PrevPurchaseWithSameLargo TRUE without a previous purchase!
							(!UsageInstructionChanged))
						{
                			SPres[DrugCount].ConversationReasonCode = 13;
						}
						else

						// NEW 17Jan2022
						// Marianna 18Jan2022: NEW check if chronic drug *and* prescription type is "continuous"
						// UsageInstructionChanged not include mesheh tipul beyamim
						// 27Feb2022 Marianna: Bug fix: The tests for continuing treatment and chronic drug
						// need to be deleted for Conversation Reason Code 24, since those cases are dealt
						// with by other Reason Codes.
						// Marianna 17Dec2024: Iris asked to change required conversation from 'yes' to 'no'
						// (the request came with User Story #313648)
						// We moved the block of code from the "conversation required" group to the "conversation not required" group.
						if ((PPD->FoundPreviousPurchase)		&&	// Found a previous purchase for a related drug...
							(!PPD->PrevPurchaseWithSameLargo)	&&	// ...although NOT with the same Largo Code...
							(!UsageInstructionChanged))				// ...and the Usage Instruction fields are all the same.
						{
							// Marianna 17Dec2024: Iris asked to change required conversation from 'yes' to 'no' 
							//SPres[DrugCount].ConversationRequired	= 1; 
							SPres[DrugCount].ConversationReasonCode = 24;

						}
						else

						// 2) Two conditions *do* require a conversation.

						// 1.4 - Member has not bought the same drug within the last few months, and the drug does
						// *not* require the pharmacist to instruct the member in its use. (The latter condition
						// explains why a conversation is necessary but it doesn't have to be in person - so pickup
						// or delivery is still possible.)
						// Marianna 25Nov2021: No recent previous purchase *and* prescription type is "continuous"
						if ((!PPD->FoundPreviousPurchase)		&&
							(Rx->prescription_type == 0)		&&
							(!SPres[DrugCount].DL.needs_patient_instruction))
						{
							SPres[DrugCount].ConversationRequired	= 1;
							SPres[DrugCount].ConversationReasonCode	= 14;
						}
						else

						// 1.5 - Marianna: Member has made a previous purchase with the same
						// Shape Code, but the drug to be sold requires the pharmacist to instruct the member in
						// its use. As with the previous condition, this is a relatively minor issue, so a phone
						// conversation should be adequate.
						// Marianna: No recent previous purchase, the member has not bought the same drug
						// or a generic drug within the last few months.
						if ((Rx->prescription_type	== 0)						&&	// Continuing treatment
							(SPres[DrugCount].DL.needs_patient_instruction)		&&
							(PPD->PrevPurchaseWithSameShape)					&&	// Found a previous purchase with the same Shape Code...
							(!PPD->FoundPreviousPurchase))							// ...but it's not a related drug.
						{
							SPres[DrugCount].ConversationRequired	= 1;
							SPres[DrugCount].ConversationReasonCode = 16;
						}
						else

						// Marianna 20Jan2022: New ELSE - if no other conditions are true, send Conversation
						// Reason Code 23.
						{
							SPres[DrugCount].ConversationRequired	= 1;
							SPres[DrugCount].ConversationReasonCode = 23;
						}
						// End of this set of conditions - no more elses.

						// DonR 21Feb2022: This shouldn't be necessary since the last assignment of a non-zero
						// value to ConversationReasonCode is unconditional - but just as a matter of good
						// (i.e. paranoid) programming practice, I'll put in a forced "break" anyway.
						break;
					}
					while (0);
					// Transaction 6101 (Chanut Virtualit) - check if consultation is required.


					// If there are non-zero Reason Codes for sale/pickup/delivery status *or* consultation
					// required, look them up now to get the associated text and show-to-member flag.
					// DonR 17Aug2021: Since we removed the outer "if", add an inner "if" so that we look
					// up reason text only for Transaction 6101. Transaction 6001 (which will be executed
					// much more frequently) doesn't send this text, so we can save the database lookups.
					if (TransactionID_in == 6101)
					{
						if (SPres[DrugCount].ReasonForbiddenCode > 0)
						{
							ExecSQL (	MAIN_DB, TR6101_READ_GetReasonText,
										&SPres[DrugCount].ReasonForbiddenDesc,	&SPres[DrugCount].DisplayReasonForbidden,
										&SPres[DrugCount].ReasonForbiddenCode,	END_OF_ARG_LIST								);

							StripAllSpaces (SPres[DrugCount].ReasonForbiddenDesc);

							SQLERR_error_test ();
						}

						if (SPres[DrugCount].ConversationReasonCode > 0)
						{
							ExecSQL (	MAIN_DB, TR6101_READ_GetReasonText,
										&SPres[DrugCount].ConversationReasonDesc,	&SPres[DrugCount].DisplayConversationReason,
										&SPres[DrugCount].ConversationReasonCode,	END_OF_ARG_LIST									);

							StripAllSpaces (SPres[DrugCount].ConversationReasonDesc);

							SQLERR_error_test ();
						}
					}	// TransactionID_in == 6101, so look up Reason Forbidden and Reason for Conversation texts.


					// If the doctor ID for this prescription is a new one, read doctor info. If this is
					// an "extra" Largo Code, Rx->doctor_id will be zero, which will force a not-found error.
					// (Note: In "simulation mode", this "if" should always be FALSE since the simulated
					// prescription, by definition, is from the same doctor.)
					// DonR 07Nov2024 User Story #357209: If this is an external prescription, copy the
					// necessary doctor-related fields from the prescription itself rather than looking
					// them up in the doctors table.
					if (Rx->doctor_id != LastDocID)
					{
						LastDocID = Rx->doctor_id;

						if (Rx->rx_origin == 0)	// = Maccabi Doctor
						{
							ExecSQL (	MAIN_DB, TR6001_READ_doctors,
										&v_DoctorFirstName,			&v_DoctorFamilyName,
										&DoctorPhone,				&DummyCheckInteractions,
										&v_DoctorLicense,			&v_DocContactPhone,
										&DoctorProfCodeToPharmacy,	&DoctorProfDescription,
										&LastDocID,					END_OF_ARG_LIST				);

							Conflict_Test (reStart);

							if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
							{
								// Since Doctor ID is not an input parameter in Trn. 6001, we do *not* want to give an
								// error for an unknown Doc ID in doctor_presc - just blank out the name variables.
								strcpy (v_DoctorFirstName,		"");
								strcpy (v_DoctorFamilyName,		"");
								strcpy (DoctorPhone,			"");
								strcpy (v_DocContactPhone,		"");
								strcpy (DoctorProfDescription,	"");
								v_DoctorLicense				= 0;
								DoctorProfCodeToPharmacy	= 0;
							}
							else
							{
								if (SQLERR_error_test ())
								{
									SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
									break;
								}

// Bug 394512: Testing code was left running in Production. I've remarked it
// out for now; next version, I'll delete it entirely.
//								// TEMPORARY FOR TESTING ONLY - FORCE IN A NON-ZERO VALUE FOR DOCTOR LICENSE NUMBER.
//								if (v_DoctorLicense == 0)
//									v_DoctorLicense = LastDocID % 1000000;
							}	// Something other than row-not-found.
						}	// Rx->rx_origin == 0, so look up Maccabi Doctor in table.

						else
						{
							// If Rx->rx_origin > 0, take the values for an external doctor that were written
							// to doctor_presc and use them instead of data from the doctors table.
							strcpy (v_DoctorFirstName,		  Rx->external_doc_first_name);
							strcpy (v_DoctorFamilyName,		  Rx->external_doc_last_name);
							strcpy (DoctorPhone,			  Rx->clinic_phone);
							strcpy (v_DocContactPhone,		  "");		// Doesn't exist for external doctors.
							strcpy (DoctorProfDescription,	  Rx->ProfDescription);
							DoctorProfCodeToPharmacy		= Rx->ProfCodeToPharmacy;
							v_DoctorLicense					= Rx->external_doc_license_num;
							DummyCheckInteractions			= 1;		// Just in case someone decides to do something with this value - default to TRUE.

							// Log an error message if we get an invalid Rx->rx_origin value. Valid values (so far) are:
							// 0 = Maccabi Doctor
							// 1 = MaccabiDent
							// 2 = Hospital
							// 3 = Other (?)
							// 4 = Pharmacist
							if ((Rx->rx_origin < 0) || ((Rx->rx_origin > 4)))
							{
								GerrLogMini (	GerrId, "Trn. 6001: Invalid Rx_Origin value %d for TZ %d Visit %d Line %d.",
												Rx->rx_origin, v_MemberIdentification, Rx->visit_number, Rx->line_number);
							}
						}
					}	// New Doctor ID.


					// If this is the first prescription in a new visit, set it up as the "header" row.
					// If the visit number is zero, don't do anything - this should be the case only for
					// "extra" largo codes.
					// DonR 28Aug2023 User Story #473527: If we're in "simulation mode" to find the best
					// preferred generic alternative drug, we've already copied all the doctor fields to
					// the SPres structure, so we don't want to do it again.
					if ((Rx->visit_number != LastVisitNumber) && (Rx->visit_number > 0) && (!TestingAlternatePackageSizeGenerics))
					{
						CurrentVisitSubscript	= DrugCount;
						LastVisitNumber			= Rx->visit_number;
						NumDoctorVisits++;
						strcpy (SPres[DrugCount].DoctorFirstName,	v_DoctorFirstName);
						strcpy (SPres[DrugCount].DoctorFamilyName,	v_DoctorFamilyName);
						strcpy (SPres[DrugCount].DoctorPhone,		DoctorPhone);
						strcpy (SPres[DrugCount].DocContactPhone,	v_DocContactPhone);
						strcpy (SPres[DrugCount].ProfDescription,	DoctorProfDescription);
						SPres[DrugCount].DoctorLicense		= v_DoctorLicense;
						SPres[DrugCount].ProfCodeToPharmacy	= DoctorProfCodeToPharmacy;

						// DonR 03Feb2015: Per Iris, we are now sending the member's default phone number
						// from the Members table as the first phone number, and the second phone number
						// is no longer in use - so we will send blanks there.
						if (Rx->visit_date > LatestVisitDate)
						{
							LatestVisitDate = Rx->visit_date;
//							strcpy (LatestMemberPhone, Rx->member_phone);
						}
					}	// First occurrence of a new non-zero visit number.


					// Increment the prescriptions-per-visit counter for the "header" prescription for this visit.
					// DonR 27Aug2023 User Story #473527: Don't increment counter if we're in "simulation mode",
					// since that means we're looking at the *same* doctor prescription we were looking at in the
					// last iteration of the main doctor-prescription cursor loop.
					if ((Rx->visit_number > 0) && (!TestingAlternatePackageSizeGenerics))
						SPres[CurrentVisitSubscript].NumRxInVisit++;

					SPres[DrugCount].DrugAnswerCode		= NO_ERROR;
					SPres[DrugCount].DFatalErr			= MAC_FALS;

					// Just for convenience, set the "shortcut variables" for the drug_list and doctor_presc rows.
					DL = &SPres[DrugCount].DL;
					DP = &SPres[DrugCount].DL_prescribed;
					Rx = &SPres[DrugCount].Rx;

					// Compute quantity remaining to be sold.
					//
					// There are two basic cases to handle:
					//
					//    1) Nothing has been sold against this prescription. In this case,
					//       we'll just send the exact values we got from Clicks.
					//
					//    2) Something has been sold. In this case, we'll compute the number
					//       of unsold units, then re-cast the result in terms of OP and units.
					//
					// For any other status value (including fully sold), we'll just send zeroes.
					//
					// DonR 18Mar2018 CR #14502: Use the new "effective package size" value rather than
					// the original package size. This is the same, except for stuff like syrups and
					// creams where package size is 1 but we need to calculate how many OP to sell
					// by looking at the package volume.
					//
					// But first, a little paranoia (considering that read_drug() already has this logic):
					if (DL->effective_package_size < 1)
						DL->effective_package_size = 1;
					if (DP->effective_package_size < 1)
						DP->effective_package_size = 1;

					// If the doctor specified the number of packages to sell, we want to use the "OP" value;
					// otherwise we want to use the "total units" value. Since Clicks can write *both* to the
					// database (i.e. 2 OP *and* 60 units when in fact 2 OP equals 60 units, and that is the
					// amount required), we will simply suppress the number we don't want to use.
					// Note that we're assuming that if the doctor did specify the number of packages required,
					// we don't have to worry about different package sizes for substitute drugs.
					// DonR 14Apr2016: If a generic substitute will be sold that has a different package size
					// than what the doctor originally prescribed, DO NOT use the prescribed OP even if the
					// "Quantity Method" flag indicates that the doctor specified the number of packages to sell.
					// Instead, multiply the doctor's OP number by the prescribed package size, and treat this
					// as a normal "units" prescription.
					// DonR 18Mar2018 CR #14502: Handle OP a little differently when both drugs have their
					// "Calculate OP by Volume" flags set TRUE.
					// DonR 18Jan2022: For Chanut Virtualit, added new array element TotalUnitsPrescribed. This
					// allows us to report a meaningful number of units prescribed whether we're selling by
					// total units or by OP.
					if ((DL->calc_op_by_volume > 0) && (DP->calc_op_by_volume > 0))
					{
						// Just to be paranoid, make sure that if the prescription is flagged as "unsold", the
						// already-sold quantities are forced to be zero.
						if (Rx->sold_status == 0)
						{
							Rx->tot_op_sold	= Rx->tot_units_sold = SPres[DrugCount].UnitsAlreadySold = 0;
						}

						Rx->qty_method	= 1;	// Since we can't sell units of a syrup or cream. Normally this is already = 1.

						UnitsPrescribed		= (Rx->op			* DP->effective_package_size);	// Units should *never* be prescribed for these drugs.
						UnitsAlreadySold	= (Rx->tot_op_sold	* DP->effective_package_size) + Rx->tot_units_sold;
						UnitsToSell			= UnitsPrescribed - UnitsAlreadySold;

						if (UnitsToSell < 0)
							UnitsToSell = 0;	// Pure paranoia, since an "oversold" prescription should already be marked as completely sold.

						// Calculate the number of packages to sell. If there are any leftover units, add one OP.
						SPres[DrugCount].UnitsToSell	= 0;
						SPres[DrugCount].OPToSell		= UnitsToSell / DL->effective_package_size;
						if ((UnitsToSell % DL->effective_package_size) > 0)
							SPres[DrugCount].OPToSell++;

						// We also need to translate the original OP prescribed to be in terms of the
						// package volume of what we're telling the pharmacy to sell.
						Rx->op = UnitsPrescribed / DL->effective_package_size;
						if ((UnitsPrescribed % DL->effective_package_size) > 0)
						{
							Rx->op++;
						}

						// DonR 26Apr2021/18Jan2022 "Chanut Virtualit": Save Units Already Sold and Units (OP in this case) Prescribed.
						// DonR 08Feb2022 Chanut Virtualit: Since we're reporting the number of *OP* to sell as "units_unsold", we
						// should also report the amount previously sold as OP rather than units. This will be in terms of the size of
						// the item currently being sold; if previous sales were of different sizes, we may wind up rounding down. Note
						// that I'm making this change conditional on TransactionID_in == 6101, even though I think the change would be
						// harmless for ordinary Transaction 6001 as well.
						SPres[DrugCount].UnitsAlreadySold		= (TransactionID_in == 6101) ? UnitsAlreadySold / DL->effective_package_size : UnitsAlreadySold;
						SPres[DrugCount].TotalUnitsPrescribed	= Rx->op;
					}	// Calculating OP by volume.

					else
					{	// *NOT* calculating OP by volume - i.e. "normal" mode.
						if ((Rx->qty_method == 1) && (DL->effective_package_size != DP->effective_package_size))
						{
							Rx->qty_method	= 0;	// Because the package size is different, treat as a "units" prescription.
							Rx->total_units	= Rx->op * DP->effective_package_size;
						}

						// DonR 18Jan2022 "Chanut Virtualit": Save Units Prescribed. If Total Units was
						// supplied, use that; otherwise multiply OP prescribed times package size.
						// DonR 20Jan2022: Use the "official" package size rather than the "effective"
						// package size; this way if we're dealing with a syrup or ointment, we'll send
						// the number of OP to sell rather than the number of ml/mg/whatever.
						SPres[DrugCount].TotalUnitsPrescribed = (Rx->total_units > 0) ?
																		Rx->total_units	:
																		Rx->op * DL->package_size;

						// If the doctor specified the number of packages to sell, use that number and
						// ignore Total Units. Otherwise use Total Units and ignore the OP number. (If they
						// are both non-zero, they are redundant and adding them together will give double
						// quantity.)
						if (Rx->qty_method == 1)
							Rx->total_units	= 0;	// Doctor specified OP - so ignore units.
						else
							Rx->op			= 0;	// Doctor did not specify OP - so use units and ignore OP.


						switch (Rx->sold_status)
						{
							case 0:		// Unsold. Note that either OpToSell or UnitsToSell will be zero - see above.
										UnitsAlreadySold					= 0;
										SPres[DrugCount].UnitsAlreadySold	= 0;
										SPres[DrugCount].OPToSell			= Rx->op;
										SPres[DrugCount].UnitsToSell		= Rx->total_units;

										// Divide UnitsToSell (if we're in "units mode") into OP and remainder. This
										// computation is based on what's going to be sold, *not* on what was originally prescribed!
										if (SPres[DrugCount].UnitsToSell > 0)
										{
											SPres[DrugCount].OPToSell		= SPres[DrugCount].UnitsToSell / DL->effective_package_size;
											SPres[DrugCount].UnitsToSell	= SPres[DrugCount].UnitsToSell % DL->effective_package_size;
										}
										break;

							case 1:		// Partially sold. As in the above case, either Op or total_units will be zero.
										// DonR 07Jul2015: Always figure quantities based on the package size of the
										// originally-prescribed drug. Of course, the same needs to be done in update_doctor_presc().
										UnitsAlreadySold	= (Rx->tot_op_sold	* DP->effective_package_size) + Rx->tot_units_sold;
										UnitsPrescribed		= (Rx->op			* DP->effective_package_size) + Rx->total_units;
										UnitsToSell			= UnitsPrescribed - UnitsAlreadySold;

										if (UnitsToSell < 0)
											UnitsToSell = 0;	// Pure paranoia, since an "oversold" prescription should already be marked as completely sold.

										// Divide UnitsToSell into OP and remainder. Of course, this computation is based
										// on what's going to be sold, *not* on what was originally prescribed!
										SPres[DrugCount].OPToSell		= UnitsToSell / DL->effective_package_size;
										SPres[DrugCount].UnitsToSell	= UnitsToSell % DL->effective_package_size;
										break;

							case 2:		// Fully sold.
										// DonR 26Apr2021 "Chanut Virtualit": Calculate Units Already Sold in all cases.
										UnitsAlreadySold	= (Rx->tot_op_sold	* DP->effective_package_size) + Rx->tot_units_sold;
										SPres[DrugCount].OPToSell		= 0;
										SPres[DrugCount].UnitsToSell	= 0;
										break;

							default:	// Unknown status - should never happen!
										// DonR 26Apr2021 "Chanut Virtualit": Calculate Units Already Sold in all cases.
										UnitsAlreadySold	= (Rx->tot_op_sold	* DP->effective_package_size) + Rx->tot_units_sold;
										SPres[DrugCount].OPToSell		= 0;
										SPres[DrugCount].UnitsToSell	= 0;
										break;
						}	// Switch on prescription's sold_status.

						// DonR 26Apr2021 "Chanut Virtualit": Save Units Already Sold.
						SPres[DrugCount].UnitsAlreadySold = UnitsAlreadySold;
					}	// NOT calculating OP by volume.


					// DonR 08Jul2015: Add automatic "rounding" for monthly presriptions - so, for example, if the doctor
					// has prescribed 30 pills (or a multiple of 30) for 30 days, and the drug to be sold comes in
					// packages of 28 pills, we want to treat one package as "one month's worth" and not tell pharmacies
					// to open packages to give the member two more pills. Note the following:
					// A) If the doctor specified the number of OP, Rx->total_units will be zero - and that will disable
					//    this logic.
					// B) If a doctor prescribes 1/2 pill per day over 60 days (= 30 total units), that will also qualify
					//    for "rounding".
					// C) If, for some reason, there were previous partial sales that together add up to something
					//    "month-like" (e.g. 15 units one time, and 14 units after that, with 31 units still unsold)
					//    the logic below will assume that these two sales together constituted one package, and thus
					//    will not disable rounding. This should lead to reasonable "real life" results without requiring
					//    the "rounding" logic to perform a full investigation of previous partial purchases.
					//
					// DonR 14Apr2016: Monthly rounding is for Maccabi pharmacies only.
					// DonR 30Jan2023 User Story #424699 - exclude narcotics from rounding.
//					// DonR 20Apr2023 User Story #432608 - include "consignatzia" pharmacies in rounding, even for non-consignment sales.
					//
					// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of drug_type.
					if (// 1) General conditions.
						(SendRoundedPackagesToPharm)													&&	// From sysparams/round_pkgs_2_pharm.
						(SPres[DrugCount].UnitsToSell > 0)												&&	// There is in fact something "non-round" to sell.
						(MACCABI_PHARMACY)																&&	// 14Apr2016: This rounding method is for Maccabi pharmacies only.
//						(MACCABI_PHARMACY || CONSIGNMENT_PHARMACY)										&&	// DonR 20Apr2023 User Story #432608: Round for MaccabiPharm *and* "consignatzia" pharmacies.

						// 2) Check whether the drug being sold is appropriate for "rounding".
						(DL->package_size	>= 28)														&&	// Drug comes in a "monthly" package.
						(DL->package_size	<= 31)														&&
						(DL->largo_type		== 'T')														&&	// This is a "treatment" (i.e. a normal drug).
//						(DL->drug_type		!= 'N')														&&	// DonR 30Jan2023 User Story #424699 - don't round narcotics.
						(!DL->is_narcotic)																&&	// DonR 30Jan2023 User Story #424699 - don't round narcotics.

						// 3) Check whether the prescription has a "monthly-type" duration.
						(Rx->treatment_length > 0)														&&	// Since zero MOD anything is zero!
						(	((Rx->treatment_length % 28) == 0) ||
							((Rx->treatment_length % 29) == 0) ||
							((Rx->treatment_length % 30) == 0) ||
							((Rx->treatment_length % 31) == 0)		)									&&	// Prescription is for one or more months.

						// 4) Check whether the amount originally prescribed comes out to a "monthly" number of units.
						(Rx->total_units > 0)															&&	// Again, since zero MOD anything is zero.
						(	((Rx->total_units % 28) == 0) ||
							((Rx->total_units % 29) == 0) ||
							((Rx->total_units % 30) == 0) ||
							((Rx->total_units % 31) == 0)		)										&&	// Original amount prescribed doesn't require opening a package.

						// 5) Check whether anything previously sold comes out to a "monthly" number of units.
						//    (Note that in this case we don't have to worry about testing for a non-zero value!)
						//    If our modulo checks don't work (e.g. if member has previously bought one package
						//    with 29 pills and one with 30 pills), we also check based on a floating-point
						//    calculation; this shouldn't execute if UnitsAlreadySold is zero (since the first
						//    modulo test will return TRUE) but I've put in an extra .001 anyway, so division
						//    by zero can't happen even in theory.
						(	((UnitsAlreadySold % 28) == 0) ||
							((UnitsAlreadySold % 29) == 0) ||
							((UnitsAlreadySold % 30) == 0) ||
							((UnitsAlreadySold % 31) == 0) ||
							((		 (float)(UnitsAlreadySold % 28)
								/	((float)(UnitsAlreadySold / 28) + .001)) < 3.0)	)	)					// Amount previously sold is also "monthly'.
					{
						// If we get here, we actually do want to perform "rounding".
						//
						// I believe that we can get away with simple arithmetic here - it should certainly cope
						// with any circumstances we're likely to see in real life. So just increment the number
						// of OP to sell if the "remainder" is at least half an OP, and set the number of units
						// to sell to zero.
						if (SPres[DrugCount].UnitsToSell >= (DL->package_size / 2))
							SPres[DrugCount].OPToSell++;

						// DonR 05May2016: As of today, I added logic to update_doctor_presc() to close out
						// prescriptions based on essentially the same rounding logic used here - so we should
						// no longer have the possibility of sending zero units/zero OP for an "open" prescription.
						// However, it still makes sense to add a condition here just in case - particularly as
						// there may be some existing prescriptions that are marked as "partially sold" when the
						// rounding logic would consider them completely closed and thus send zero/zero.
						if (SPres[DrugCount].OPToSell > 0)	// DonR 05May2016: added condition.
							SPres[DrugCount].UnitsToSell = 0;
					}
					// DonR 08Jul2015 end.


					// DonR 14Apr2016: If we're selling something in non-openable packages and there are "leftover"
					// units to sell (which implies that we have not performed the monthly rounding above, for
					// whatever reason), round up by adding 1 to OP-to-sell and zeroing units-to-sell.
					if ((DL->openable_pkg == 0)  && (SPres[DrugCount].UnitsToSell > 0))
					{
						SPres[DrugCount].OPToSell++;
						SPres[DrugCount].UnitsToSell = 0;
					}

					// DonR 26Apr2021 "Chanut Virtualit": After all our calculations and rounding to full
					// packages, calculate the total number of units (including full and partial OP together)
					// that will be sold for this prescription.
					SPres[DrugCount].TotalUnitsToSell		= (SPres[DrugCount].OPToSell * DL->package_size) + SPres[DrugCount].UnitsToSell;

					// DonR 26Apr2021 "Chanut Virtualit": Calculate the actual member participation
					// based on quantity prescribed, PriceCode, and ReducedPrice.
					if (TransactionID_in == 6101)
					{
						double				PtnPerPackage_f;
						double				MemberPtn_f;
						double				DiscountMultiplier_f;
						int					PtnOpPrice;
						int					AltYarpaPrice;
						int					PtnBeforeDiscount;
						Tmember_price_row	PriceRow;

						// Marianna 29Mar2022 Epic 232192: Get the price percentage *before* calculating
						// member discounts, since Type 2 Darkonaim get a discount based on the percentage.
						GET_MEMBER_PRICE_ROW (SPres[DrugCount].PriceCode, &PriceRow);
						// Add error handling?

						// DonR 22Feb2022: To avoid rounding errors, determine the member discount percent
						// *before* calculating "hishtatfut"; this way we can perform a single floating-point
						// computation and round to agorot only once we have a completed calculation, taking
						// pricing, member discounts, and quantity into consideration.

						// DonR 27Jan2022: We also need to calculate member discounts for Chanut Virtualit.
						//
						// Member discounts apply if:
						//
						// A) The drugs are being bought with a prescription. This is *always* true in 6101, so it's
						//    not part of the "if" here.
						//
						// B) The member is entitled to a discount: Either by having Member Rights 7 or 17
						//    (entitled to a 100% discount) or with an explicit discount level set by
						//    Member Discount Percent.
						//    DonR 04Dec2014: Member can also get an automatic 100% discount if s/he has
						//    a match between his/her serious-illness bitmap and the drug's illness bitmap.
						//    This is implemented with the new macro GETS_100PCT_DISCOUNT.
						//
						// C) Drug is in Health Pack (i.e. "The Basket") - this can be set from drug_list,
						//    drug_extension, spclty_largo_prcnt, or an AS400 ishur.
						//
						// D) The drug's Largo Type is appropriate for the type of discount being granted. For this, we now use
						//    Largo Type lists from Sysparams to qualify discounts instead of hard-coded values. For flexibility,
						//    there are separate lists for illness-based and non-illness-based discounts, as well as the new
						//    category of "ventilator" discounts. The comparision between a drug's Largo Type and these lists is
						//    performed in read_drug() and stored in DL.IllnessDiscounts/VentilatorDiscounts/NonIllnessDiscounts.
						if ( (MEMBER_GETS_DISCOUNTS)																			&&	// Condition (B).
							((SPres[DrugCount].InHealthBasket != 0)	|| (IGNORE_HEALTH_BASKET (SPres[DrugCount].DL)))			&&	// Condition (C).
							((SPres[DrugCount].DL.IllnessDiscounts)	|| (SPres[DrugCount].DL.VentilatorDiscounts) || (SPres[DrugCount].DL.NonIllnessDiscounts)) )	// Condition (D) - revised by CR #31591.
						{
							// DonR 13May2020 CR #31591: Add a new category of "ventilator" discounts. These are
							// given for members with their VentilatorDiscount flag set non-zero (currently comes
							// from members/asaf_code, which should be renamed when we migrate to MS-SQL), for
							// all items with Largo Type matching a list - currently "B", "Y", or "D".
							if (((Member.VentilatorDiscount) && (SPres[DrugCount].DL.VentilatorDiscounts))	||
								(GETS_100PCT_DISCOUNT_WITHOUT_DIAGNOSIS (SPres[DrugCount].DL)))
							{
								SPres[DrugCount].AdditionToPrice	= 10000;
							}
							else
							{
								if (GETS_100PCT_DISCOUNT_WITH_DIAGNOSIS (SPres[DrugCount].DL))
								{
									// If we get here, we need to see if one or more of the member's diagnoses
									// corresponds with a listed diagnosis for the drug being sold.
									MatchingDiagnosis = 0;

									ExecSQL (	MAIN_DB,
												READ_Find_member_diagnosis,
												Find_diagnosis_from_member_diagnoses,
												&MatchingDiagnosis,
												&SPres[DrugCount].DL.largo_code,	&Member.member_id,
												&Member.mem_id_extension,			END_OF_ARG_LIST		);

									// If we didn't get a positive count(*) and a valid SQL result code, check against
									// additional member diagnoses in the special_prescs table.
									if ((SQLCODE != 0) || (MatchingDiagnosis < 1))
									{
										ExecSQL (	MAIN_DB,
													READ_Find_member_diagnosis,
													Find_diagnosis_from_special_prescs,
													&MatchingDiagnosis,
													&SPres[DrugCount].DL.largo_code,		&Member.member_id,
													&SysDate,								&SysDate,
													&Member.mem_id_extension,				END_OF_ARG_LIST		);
									}

									if ((SQLCODE == 0) && (MatchingDiagnosis > 0))
									{
										SPres[DrugCount].AdditionToPrice	= 10000;
									}
								}	// 100% discount conditional on diagnosis-code match.
							}	// Did *not* grant a 100% discount based on non-diagnosis match. 

							if (SPres[DrugCount].AdditionToPrice != 10000)	// No 100% discount - does member have a discount percentage set?
							{
								// Marianna 24Mar2022 Epic 232192: Type 2 Darkonaim (Harel Foreign Workers) get a 100% discount if the participation
								// percentage is less or equal to a configurable value - currently 15%.
								if ((Member.mem_id_extension == 9) && (Member.darkonai_type == 2) && (PriceRow.member_price_prcnt <= DarkonaiMaxHishtatfutPct))
								{
									SPres[DrugCount].AdditionToPrice = 10000; // 100% discount
								} // Get 100% discount darkonai 

								// DonR 12Jan2004: Make sure we don't overwrite a big discount with a little one.
								// DonR 13May2020 CR #31591: For flexibility, make this discount conditional on
								// the drug's NonIllnessDiscounts flag, which is set by read_drug() based on whether
								// the drug's Largo Type matches the list set in sysparams/memb_disc_4_types.
								if ((SPres[DrugCount].DL.NonIllnessDiscounts) && (Member.discount_percent > SPres[DrugCount].AdditionToPrice))
									SPres[DrugCount].AdditionToPrice = Member.discount_percent;
							}	// No 100% discount granted, so we need to look at the member's Discount Percent (if it's non-zero).

						}	// Member may be entitled to a discount.

						// Convert the discount percentage to a floating-point price multiplier.
						switch (SPres[DrugCount].AdditionToPrice)
						{
							case     0:		DiscountMultiplier_f = 1.0;		// No discount - member pays 100%.
											break;

							case 10000:		DiscountMultiplier_f = 0.0;		// Full discount - member pays zero.
											break;

							default:		// Calculate the Discount Multiplier for partial discounts.
											DiscountMultiplier_f = ((double)10000 - (double)SPres[DrugCount].AdditionToPrice) / (double)10000;
											break;
						}

						// Next, calculate the non-discounted participation.
						if (SPres[DrugCount].ReducedPrice > 0)
						{
							PtnPerPackage_f = (double)SPres[DrugCount].ReducedPrice;
						}
						else
						{
							// If we didn't get a fixed price (from an ishur or from some kind
							// of "nohal"), we have to read price_list and muck about with
							// percentages, minimum/maximum prices, and so on.
							//
							// Marianna 29Mar2022 Epic 232192: Moved the GET_MEMBER_PRICE_ROW() call
							// to just before the member discount section.
							// GET_MEMBER_PRICE_ROW (SPres[DrugCount].PriceCode, &PriceRow);
							// ADD ERROR HANDLING!

							// DonR 20Jan2022: If we haven't found any other reduced price (either a fixed price
							// or a participation percentage less than 100), use the Maccabi Price if it exists.
							// Note that the use of the Maccabi Price mean that the sale is no longer at 100% for
							// purposes of preventing full-price sales at MaccabiPharm.
							PtnOpPrice = ((PriceRow.member_price_prcnt == 10000) && (SPres[DrugCount].MaccabiPrice > 0)) ?
											SPres[DrugCount].MaccabiPrice : SPres[DrugCount].YarpaPrice;

							// DonR 29Jun2023 User Story #461368: In order to reduce inflation, the Ministry of Health has
							// ordered a six-month price freeze on member participation for drugs in the Health Basket. We
							// are implementing this by adding a special price list (Price List Code = 21) that will store
							// the June 2023 prices; the Yarpa Price from this list will be used for participation calculation
							// in place of the new, higher Yarpa Price if all the conditions are met. Note that the "treatments
							// only" logic is being implemented on the AS/400 feed to the RK9017P/price_list table, so we don't
							// need it here - but I'm leaving it here in remarked-out form anyway, just in case we decide later
							// to enable it.
							// DonR 04Jul2023 User Story #461368: Updated criteria to match what Orli Spiegel is doing on AS/400.
							// Now we *do* check for "trufot", but we do *not* check Insurance Used. In real life, the results
							// should be the same, since Health Basket is normally FALSE when non-basic insurance is used and
							// only "trufot" should be included in Price List 21 anyway.
							// Marianna 09Jul2023 User Story #463302: Add a new sysparams flag, alt_price_list_only_if_cheaper, to
							// allow the "frozen" alternate Yarpa Price to be used unconditionally, even if it's higher than the
							// price from the current price list.
							if ((SysDate									>= alt_price_list_first_date	)	&&
								(SysDate									<= alt_price_list_last_date		)	&&
								(alt_price_list_code						>  0							)	&&
								(SPres[DrugCount].DL.largo_type				== 'T'							)	&&	// This is a "treatment" (i.e. a normal drug).
//								(SPres[DrugCount].InHealthBasket			!= 0							)	&&	// Implies a prescription sale with price < 100%.
//								(SPres[DrugCount].InsuranceUsed				== BASIC_INS_USED				))
								(SPres[DrugCount].InHealthBasket			!= 0							))
							{
								ExecSQL (	MAIN_DB, READ_AlternateYarpaPrice,
											&AltYarpaPrice,
											&SPres[DrugCount].DL.largo_code,	&alt_price_list_code,
											&SPres[DrugCount].YarpaPrice,		&alt_price_list_only_if_cheaper,	// Marianna 09Jul2023 User Story #463302.
											END_OF_ARG_LIST															);

								Conflict_Test (reStart);

								if (SQLCODE ==  0)
								{
									// Copy the alternate Yarpa price to the working OP Price variable.
									PtnOpPrice = AltYarpaPrice;
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6101: Substituting Price List %d price of %d for default Yarpa Price %d for Largo %d.",
//	alt_price_list_code, PtnOpPrice, SPres[DrugCount].YarpaPrice, SPres[DrugCount].DL.largo_code);
								}	// Successful read of alternate (frozen) Yarpa Price.
								else
								{	// Did NOT read an alternate (frozen) Yarpa Price. PtnOpPrice will retain its default value.

									if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
									{
										// Not Found is perfectly OK - take no action other than (redundantly)
										// setting SPres[i].AlternateYarpaPrice to zero.
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6101: Did NOT find a Price List %d price better than the default Yarpa Price %d for Largo %d.",
//	alt_price_list_code, SPres[DrugCount].YarpaDrugPrice, SPres[DrugCount].DL.largo_code);
									}
									else
									{
										if (SQLERR_error_test ())
										{
if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6001/6101: SQLCODE %d trying to read Price List %d for a price better than the default Yarpa Price %d for Largo %d.",
	SQLCODE, alt_price_list_code, SPres[DrugCount].YarpaPrice, SPres[DrugCount].DL.largo_code);
											SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
										}
									}	// Some SQL error other than not-found.
								}	// Did NOT successfully read an alternate (frozen) Yarpa Price.
							}	// We want to try reading an alternate (frozen) Yarpa Price for this item.
								// DonR 29Jun2023 User Story #461368 end.

							// If there is a minimum discounted price, use that if the package price is within range.
							// If price is below the minimum, there is no discount.
							if ((PriceRow.min_reduced_price > 0) && (PriceRow.max_pkg_price > 0))
							{
								if ((PtnOpPrice >= PriceRow.min_reduced_price) &&
									(PtnOpPrice <= PriceRow.max_pkg_price))	// Or just "<"?
								{
									PtnPerPackage_f = (double)PriceRow.min_reduced_price;
								}
								else
								{
									// If price is above the top of the range for the minimum discounted price,
									// apply percentage discount.
									if (PtnOpPrice > PriceRow.max_pkg_price)
									{
										PtnPerPackage_f = (double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
									}
									else
									{
										PtnPerPackage_f = (double)PtnOpPrice;	// Cheap drug = no discount.
									}
								}
							}	// Participation type has a minumum per-package price.
							else
							{
								// For any other participation code, just apply the discount.
								PtnPerPackage_f = (double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
							}	// This Price Code has no minimum per-package price.
						}	// No fixed price, so we have to derive the per/OP price from price_list and member_price.

						// Compute participation for the actual amount remaining to sell.
						MemberPtn_f = PtnPerPackage_f * ((double)SPres[DrugCount].TotalUnitsToSell / (double)SPres[DrugCount].DL.package_size);

						// Now put it all together!
						// Save the member's non-discounted participation (in even, correctly-rounded agorot).
						PtnBeforeDiscount = (int)(MemberPtn_f + 0.5001);

						// Multiply per-package and total participation by the Member Discount Multiplier,
						// and store the results as integers in correctly-rounded agorot.
//GerrLogMini (GerrId, "Discount Multiplier %f; OP %f -> %f (%d); Ptn %f -> %f (%d).",
//	DiscountMultiplier_f, PtnPerPackage_f, PtnPerPackage_f	* DiscountMultiplier_f, (int)((PtnPerPackage_f	* DiscountMultiplier_f) + 0.5001),
//	MemberPtn_f, MemberPtn_f	* DiscountMultiplier_f, (int)((MemberPtn_f	* DiscountMultiplier_f) + 0.5001));
						PtnPerPackage_f	*= DiscountMultiplier_f;
						MemberPtn_f		*= DiscountMultiplier_f;
						SPres[DrugCount].MemberPtnPerPackage	= (int)(PtnPerPackage_f	+ 0.5001);
						SPres[DrugCount].TotalMemberPtn			= (int)(MemberPtn_f		+ 0.5001);

						// Save the amount of the discount in agorot. (For now at least, we're not
						// actually doing anything with this number.)
						SPres[DrugCount].DiscountApplied = PtnBeforeDiscount - SPres[DrugCount].TotalMemberPtn;

					}	// Need to calculate member participation for "Chanut Virtualit" Transaction 6101.


					// DonR 14Nov2023 User Story #473527: If we are already in "simulation mode", perform a series
					// of tests to see which preferred drug is "best", based on a hierarchical series of criteria.
					if (TestingAlternatePackageSizeGenerics)
					{
						// By default, assume that the new drug we're testing *is* preferable to the default.
						DefaultDrugIsPreferable = false;

						// Dummy loop to keep the code a little simpler.
						do
						{
							// Perform a series of tests on the alternate preferred drug versus the default
							// preferred drug, according to a hierarchical sequence.

							// 1) We can assume that if the member has an ishur for a particular drug, that drug
							//    is preferable to any drug *without* an ishur, regardless of package size, etc.
							//    Note that we test first for simple inequality - since if the two drugs have
							//    unequal "found ishur" flags, one of them has to be preferable to the other.
							if (DefaultRx.FoundAs400Ishur != SPres[DrugCount].FoundAs400Ishur)
							{
								DefaultDrugIsPreferable = DefaultRx.FoundAs400Ishur;
								break;
							}

							// 2) If one drug will fill the demand exactly (assuming that everything has already been
							//    been converted into 30-day "months" for "monthly" demand and package-size numbers)
							//    and the other drug leaves a remainder, the one without a remainder is preferable.
							//    Again, if the two drugs have different values for this flag, the one that fills the
							//    demand without leaving any leftovers is preferable.
							if (DefaultRx.EvenPackagesToFill != SPres[DrugCount].EvenPackagesToFill)
							{
								DefaultDrugIsPreferable = DefaultRx.EvenPackagesToFill;
								break;
							}

							// 3) If we get here, the two drugs are equal in terms of having (or not having) an ishur
							//    for this member, and being able (or unable) to fill the prescription completely
							//    without opening packages. At this point the logic diverges: There are somewhat
							//    different criteria when there is no option that completely fills the prescription
							//    without any leftover.
							if (DefaultRx.EvenPackagesToFill)	// Both drugs fill the prescription with no remainder.
							{
								// 3.1) If the package sizes are unequal, the larger package size is preferable. (Note
								//      that we could instead look at T6001_Drugs.NumWholePackages here - but the result
								//      would be identical.)
								if (DefaultRx.DL.monthly_package_size != SPres[DrugCount].DL.monthly_package_size)
								{
									DefaultDrugIsPreferable = (DefaultRx.DL.monthly_package_size > SPres[DrugCount].DL.monthly_package_size);
									break;
								}

								// 3.2) If the package size is equal but one of the two drugs is in the same Parent Group
								//      as the doctor prescribed, that one is preferable.
								if (DefaultRx.SameParentGroupAsRx != SPres[DrugCount].SameParentGroupAsRx)
								{
									DefaultDrugIsPreferable = DefaultRx.SameParentGroupAsRx;
									break;
								}

								// 3.3) If we get here, we've found no good reason to prefer one drug over the other. In
								//      this case, we might as well stick with the default.
								DefaultDrugIsPreferable = true;
								break;

							}		// Both drugs completely fill the doctor prescription with no remainder.

							else	// Both drugs have a remainder - either we have to sell extra, or else open a package.
							{
								// 3.4) If neither option fills the prescription exactly, see if one of them has the same
								//      package size as what the doctor prescribed. (Note that both drugs should have the
								//      same drug in the DL_prescribed structure - so we can compare both to the DefaultRx
								//      copy.) If both or neither pass this test, continue to the next criterion.
								if ((       DefaultRx.DL.monthly_package_size == DefaultRx.DL_prescribed.monthly_package_size)	&&
									(SPres[DrugCount].DL.monthly_package_size != DefaultRx.DL_prescribed.monthly_package_size))
								{
									DefaultDrugIsPreferable = true;		// Default drug is the same size, and "new" drug is not.
									break;
								}

								if ((       DefaultRx.DL.monthly_package_size != DefaultRx.DL_prescribed.monthly_package_size)	&&
									(SPres[DrugCount].DL.monthly_package_size == DefaultRx.DL_prescribed.monthly_package_size))
								{
									DefaultDrugIsPreferable = false;	// Just for clarity - this should already be the case.
									break;
								}

								// 3.5) If the two drugs have different "adjusted monthly" package sizes (and neither one is the same
								//      package size as what the doctor prescribed) choose the one that fills the presription with a
								//      lower number of packages. Note that we're not examining the number of unused pills in a
								//      package - so we're not guaranteed to minimize the number of "wasted" pills.
								if (DefaultRx.NumWholePackages != SPres[DrugCount].NumWholePackages)
								{
									DefaultDrugIsPreferable = (DefaultRx.NumWholePackages < SPres[DrugCount].NumWholePackages);
									break;
								}

								// 3.6) If the package size is effectively equal but one of the two drugs is in the same Parent Group
								//      as the doctor prescribed, that one is preferable.
								if (DefaultRx.SameParentGroupAsRx != SPres[DrugCount].SameParentGroupAsRx)
								{
									DefaultDrugIsPreferable = DefaultRx.SameParentGroupAsRx;
									break;
								}

								// 3.7) If we get here, we've found no good reason to prefer one drug over the other. In
								//      this case, we might as well stick with the default.
								DefaultDrugIsPreferable = true;
								break;

							}	// Both drugs have a remainder - either we have to sell extra, or else open a package.

						}
						while (0);	// End of dummy loop.

						// If the alternate preferred drug is preferable to the default preferred drug for any of the
						// reasons above, we don't have to do anything. But if the default drug is preferable, or if
						// the two drugs are equally preferable, we'll stay with the default - which means we have to
						// copy its whole SPres structure from where we saved it in DefaultRx.
						if (DefaultDrugIsPreferable)
						{
							SPres[DrugCount] = DefaultRx;
						}
						// Else do nothing - don't copy anything, and don't increment DrugCount.

					}	// if (TestingAlternatePackageSizeGenerics)

					// If we're not already in "simulation mode" *and* the current drug is one with more than one preferred
					// generic version (along with other relevant conditions), open the "preferred alternatives" cursor with
					// appropriate criteria and set TestingAlternatePackageSizeGenerics TRUE.
					else
					{
						// If we get here, we are *not* in "simulation mode" - but we may need to start "simulation mode"
						// if the current drug is one with multiple preferred alternatives.

						// DonR 24Aug2023 User Story #473527 (continued): If the prescription we just read from
						// doctor_presc is one where we need to check for a "better" alternative preferred drug,
						// open up the TR6001_FindAlternatePackageSizeGenerics to find the possibilities.
						if (SPres[DrugCount].NeedToFindBestPreferredPackageSize)
						{
							DeclareAndOpenCursor (	MAIN_DB, TR6001_FindAlternatePackageSizeGenerics,
													&SPres[DrugCount].DL.economypri_group,
													&SPres[DrugCount].DL.largo_code,
													END_OF_ARG_LIST										);

							Conflict_Test (reStart);

							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								CloseCursor (MAIN_DB, TR6001_FindAlternatePackageSizeGenerics);
								break;
							}
							else
							{
								// Successful open of TR6001_FindAlternatePackageSizeGenerics, so turn
								// "simulation mode" on. Also set BestPreferredPackageSizeChosen so that
								// other prescriptions for the same prescribed drug will get the same
								// sold drug *without* having to go through the "simulation" stuff.
								TestingAlternatePackageSizeGenerics = TRUE;
								SPres[DrugCount].BestPreferredPackageSizeChosen = TRUE;
							}

						}	// Prescription meets the conditions for starting "simulation mode" to search for a cheaper
							// preferred drug than the default.

					}	// TestingAlternatePackageSizeGenerics was FALSE - so we were not already in "simulation mode".


					// At this point, if TestingAlternatePackageSizeGenerics is TRUE then the "simulation" cursor
					// TR6001_FindAlternatePackageSizeGenerics is open, and may or may not have more rows to read.
					// Attempt a FETCH, and either leave "simulation mode" TRUE or else close the cursor and increment
					// DrugCount to read the next doctor_presc row.
					if (TestingAlternatePackageSizeGenerics)
					{
						// Read the next preferred drug from drug_list, and save it for the next loop iteration.
						FetchCursorInto (	MAIN_DB, TR6001_FindAlternatePackageSizeGenerics,
											&AlternatePreferredLargo,	END_OF_ARG_LIST			);
//GerrLogMini (GerrId, "Fetched TR6001_FindAlternatePackageSizeGenerics. AlternatePreferredLargo = %d, SQLCODE = %d, DrugCount = %d.",
//	AlternatePreferredLargo, SQLCODE, DrugCount);

						Conflict_Test (reStart);
					
						if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
						{
							// We're finished with alternate preferred drugs for this prescription, so clean up
							// and return to normal prescription-fetching. Note that in this case we need to
							// increment DrugCount, since we're going to read the next prescription from the
							// doctor_presc table into a new slot in the SPres array.
							CloseCursor (MAIN_DB, TR6001_FindAlternatePackageSizeGenerics);
							AlternatePreferredLargo				= 0;
							TestingAlternatePackageSizeGenerics	= FALSE;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								CloseCursor (MAIN_DB, TR6001_FindAlternatePackageSizeGenerics);
								TestingAlternatePackageSizeGenerics	= FALSE;	// Probably redundant, but harmless.
								break;
							}
						}	// NOT end-of-fetch for TR6001_FindAlternatePackageSizeGenerics.
					}	// TestingAlternatePackageSizeGenerics was TRUE, so we tried reading the next
						// row from TR6001_FindAlternatePackageSizeGenerics.


					// Reminder: We want to increment DrugCount *only* if we are not in "simulation mode" to find a
					// cheaper preferred alternative drug with a different package size. There are two possibilities:
					// 1) We've FETCHed a row successfully from TR6001_FindAlternatePackageSizeGenerics, and thus we're
					//    still in "simulation mode" (TestingAlternatePackageSizeGenerics is TRUE). In this case, we
					//    want to go to the next iteration of the prescription-reading loop *without* incrementing
					//    DrugCount, since we're still trying to optimize the same doctor prescription.
					// 2) Either we got to the end of the TR6001_FindAlternatePackageSizeGenerics cursor and we've turned
					//    "simulation mode" off (TestingAlternatePackageSizeGenerics is FALSE), or we weren't in "simulation
					//    mode" in the first place. In this case, we need to increment DrugCount since the next iteration of
					//    the loop will read a new row from doctor_presc.
					if (!TestingAlternatePackageSizeGenerics)
						DrugCount++;

					if (DrugCount >= MAX_TRN6001_DRUGS)
					{
						// DonR 20Jul2006: Per Iris Shaya, if we've got more than 999
						// prescriptions to send, don't return an error; just send
						// the first 99 prescriptions and don't make a big deal out of it.
						GoodFetch = 0;
						continue;
					}
				}	// GoodFetch is non-zero - successful read.

				else
				{
					if (FetchComplete)
					{
						continue;	// Jumps to "while" and exits loop.
					}

					else
					{
						// If we get here and FetchComplete is zero, it means that the FETCH from doctor_presc
						// failed in some non-benign way.
						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}
				}	// GoodFetch is zero - read failed.

			}	// "Do" block.
			while (GoodFetch);
			// End of loop for reading doctor_presc rows.

		}	// Nothing fatal in Doctor, Member, Pharmacy data.

		// DonR 07Jan2021: Split TR6001_doctor_presc_cur into two versions - the complicated original one,
		// (TR6001_doctor_presc_cur) plus a version (TR6001_doctor_presc_cur_simplified) with a simplified
		// WHERE for the 90% of cases where the pharmacy ONLY wants current prescriptions and doesn't
		// specify a Prescription ID or Visit Number.
		if (RxSelectQueryUsed != 0)
		{
			CloseCursor (	MAIN_DB, RxSelectQueryUsed	);

			// Do we really want to have error-checking on a CloseCursor statement?
			// Leave it in for now, I guess...
			if (SQLERR_error_test ())
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				break;
			}
		}


		// DonR 09Nov2017 CR #13141: Check for duplicate fillable prescriptions. Note that this can be done
		// only *after* the completion of the cursor-reading loop, since each drug's duplicate
		// flag can be set only based on knowledge of the full list of prescriptions.
		// DonR 29Nov2017: Do not set duplicate-prescription flags if the "duplicate" has already
		// been completely sold.
		for (ThisRx = 0; ThisRx < DrugCount; ThisRx++)
		{
			// DonR 10Dec2017: Don't bother setting the flag for prescriptions that are not currently sellable.
			if (SPres[ThisRx].PrDateValidForSale != 1)
				continue;

			for (i = 0; i < DrugCount; i++)
			{
				// DonR 10Dec2017: If the Doctor Prescription ID is the same, don't count this as
				// a duplicate fillable prescription.
				// Also, if two drugs are in the same (non-zero) substitution group, that's
				// the equivalent (for purposes of duplicate-checking) to their being the same drug.
				// This is easier to implement as a negative condition (i.e. a reason to "continue")
				// than a positive one.
				if (( i											== ThisRx)																						|| 
					( SPres[i].Rx.doctor_presc_id				== SPres[ThisRx].Rx.doctor_presc_id)															||
					((SPres[i].Rx.largo_prescribed				!= SPres[ThisRx].Rx.largo_prescribed)	&& (SPres[i].DL_prescribed.economypri_group == 0))		||
					( SPres[i].DL_prescribed.economypri_group	!= SPres[ThisRx].DL_prescribed.economypri_group))
				{
					continue;
				}
				// If we get here, the two drugs are either the same OR have the same non-zero substitution group code.

//				// DonR 10Dec2017: If two drugs are in the same (non-zero) substitution group, that's
//				// the equivalent (for purposes of duplicate-checking) to their being the same drug.
//				// This is easier to implement as a negative condition (i.e. a reason to "continue")
//				// than a positive one.
//				if (((SPres[i].Rx.largo_prescribed	!= SPres[ThisRx].Rx.largo_prescribed)	&& (SPres[i].DP.economypri_group == 0))		||
//					( SPres[i].DP.economypri_group	!= SPres[ThisRx].DP.economypri_group))
//				{
//					continue;
//				}
//
//				if ((SPres[i].Rx.largo_prescribed	== SPres[ThisRx].Rx.largo_prescribed)		&&
//					(SPres[i].PrDateValidForSale	== 1)										&&
				if ((SPres[i].PrDateValidForSale	== 1)										&&
					(SPres[i].Rx.sold_status		!= 2)										&&
					(SPres[i].Rx.deleted_status		== 0))
				{
					// 1 means that at least one other valid prescription has its Digital Prescription
					// Flag set TRUE; 2 means that only non-digital duplicate prescriptions exist.
					if (SPres[ThisRx].OtherValidRxExists == 0)
						SPres[ThisRx].OtherValidRxExists = 2;

					if (SPres[i].Rx.digital_presc_flag > 0)
					{
						SPres[ThisRx].OtherValidRxExists = 1;
						break;	// No need to continue checking for ThisRx - break out of inner loop.
					}
				}	// We found an additional fillable prescription for the same drug as in ThisRx.
			}	// Loop through the prescription array to look for additonal prescriptions matching ThisRx.
		}	// Check each prescription in the array for additional fillable prescriptions - DonR 09Nov2017 CR #13141 end.



//		// Process "extra" drugs requested by pharmacy.
//		for (i = 0; i < NumExtraLargos; i++)
//		{
//			ExtraDrugs[i].LargoCode = GetInt	(&PosInBuff,  9				); CHECK_ERROR ();
//
//			err = predict_member_participation (&Member,
//												&SPres[DrugCount].DL,
//												&Phrm_info,
//												0,	// Doctor ID Type.
//												0,	// No Maccabi doctor ID!
//												&ExtraDrugs[i].PriceCode,
//												&ExtraDrugs[i].FixedPriceFlag,
//												NULL);
//		}



		// Compile list of previous drug sales; we report the last sale for each Economypri group or
		// individual drug that isn't in Economypri. Relevant drugs must have Largo Type "T" (that
		// is, a "treatment"), and the most recent sale must have been within the last four months
		// (which we'll treat as equal to a fixed 122 days including today).
		// Note that I added an ORDER BY DATE DESC to the SELECT in get_drugs_in_blood() to make things
		// a little more convenient here.
		// DonR 23Jan2018 CR #13937: Do not report prior sales for those members with check_od_interact
		// set FALSE. These "members" are in fact Maccabi investigators, not patients!
		// DonR 30Jan2019 CR #27234: At least for now, non-hesder pharmacies do *not* get interaction/
		// overdose messages or prior-sale info.
		// DonR 03Nov2020: Disable history reporting for Request Type 4, which is supposed to be
		// only a card-validity test.
		// DonR 23Feb2022: Changed to macro SECRET_INVESTIGATOR to enable global-parameter control of
		// the "mivaker samui" logic.
		if ((!SECRET_INVESTIGATOR) && (HESDER_MACCABI) && (HistoryEnabled) && (TransactionID_in != 6101))
		{
			flg = get_drugs_in_blood (&Member,
									  &v_DrugsBuf,
									  GET_ALL_DRUGS_BOUGHT,
									  &v_ErrorCode,
									  &reStart);
			if (flg == 1)
			{
				break;	// high severity error OR deadlock occurred.
			}

			for (DrugNum = LastPriorLargo = NumPriorSales = 0; DrugNum < v_DrugsBuf.max; DrugNum++)
			{
				if ((v_DrugsBuf.Durgs[DrugNum].Code				== LastPriorLargo)		||	// Not the most recent sale of this drug.
					(v_DrugsBuf.Durgs[DrugNum].LargoType[0]		!= 'T')					||	// Not a "treatment".
					(v_DrugsBuf.Durgs[DrugNum].StartDate		<  LastFourMonths))			// Too far in the past to be relevant.
					continue;

				LastPriorLargo = v_DrugsBuf.Durgs[DrugNum].Code;	// So we look only at the most recent sale of each drug.

				// See if we already found something for this Economypri Group. (If the drug isn't in
				// Economypri, we know that it isn't already in the array.)
				PriorSaleSubscript = -1;

				if (v_DrugsBuf.Durgs[DrugNum].EconomypriGroup > 0)
				{
					for (i = 0; i < NumPriorSales; i++)
					{
						if (PriorSales[i].EconomypriGroup == v_DrugsBuf.Durgs[DrugNum].EconomypriGroup)
						{
							PriorSaleSubscript = i;
							break;
						}
					}
				}

				// If we didn't find something relevant in the Prior Sales array, add to the end of
				// the array and increment its size.
				if (PriorSaleSubscript < 0)
				{
					PriorSaleSubscript = NumPriorSales;
					NumPriorSales++;
				}

				// Store only the newest data for each drug group.
				if (( v_DrugsBuf.Durgs[DrugNum].StartDate	 >  PriorSales[PriorSaleSubscript].LastSaleDate)		||
					((v_DrugsBuf.Durgs[DrugNum].StartDate	 == PriorSales[PriorSaleSubscript].LastSaleDate) &&
					 (v_DrugsBuf.Durgs[DrugNum].PurchaseTime >  PriorSales[PriorSaleSubscript].LastSaleTime)))
				{
					PriorSales[PriorSaleSubscript].LastSaleDate		= v_DrugsBuf.Durgs[DrugNum].StartDate;
					PriorSales[PriorSaleSubscript].LastSaleTime		= v_DrugsBuf.Durgs[DrugNum].PurchaseTime;
					PriorSales[PriorSaleSubscript].LargoCode		= v_DrugsBuf.Durgs[DrugNum].Code;
					PriorSales[PriorSaleSubscript].EconomypriGroup	= v_DrugsBuf.Durgs[DrugNum].EconomypriGroup;
					PriorSales[PriorSaleSubscript].OP				= v_DrugsBuf.Durgs[DrugNum].Op;
					PriorSales[PriorSaleSubscript].Units			= v_DrugsBuf.Durgs[DrugNum].Units;
				}	// Need to store prior-sale info in output array.
			}	// Loop through buffer of previously-bought drugs.
		}	// Member is a real member, not a secret investigator.

		else
		{
			NumPriorSales = 0;
		}	// This is an investigator rather than a real member - DonR 23Jan2018 CR #13937 end.


		// Retry if we hit a DB problem.
		if (reStart != MAC_FALS)	// DB errors - do a retry.
		{
			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogReturn (GerrId, "Table is locked for the <%d> time", tries);
			
			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}	// DB error occurred.

	}	// End of Database Retries loop.
	
	
	// See if we've exceeded the maximum retry count.
	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}

	// DonR 11Jun2018 Online orders (SuperPharm): For Request Type 3, if DigitalStatus is
	// non-zero (which should always be the case, since we don't check the member's card
	// date in Online Order mode), send 3 instead of 1 for Digital Status.
	if (OnlineOrder && (DigitalStatus > 0))
		DigitalStatus = 3;

	// DonR 10Dec2025 User Story #441076: Set a couple of new output flags.
	for (DrugNum = 0; DrugNum < DrugCount; DrugNum++)
	{
		DL = &SPres[DrugNum].DL;			// Just for brevity.
		Rx = &SPres[DrugNum].Rx;			// Just for brevity.

		SPres[DrugNum].IsCannabis		= (DL->drug_type		== 'K'	) ? 1 : 0;
		SPres[DrugNum].IsPreparation	= (DL->preparation_type	>  0	) ? 1 : 0;
		SPres[DrugNum].NumMessageLines	= (*Rx->internal_comments		) ? 1 : 0;
	}

	// Prepare and send Response Message (Transaction 6002).
	// DonR 21Apr2021: Enable JSON output.
	if (JSON_Mode)
	{
		JSON_OutputObject = cJSON_CreateObject ();

		if (JSON_OutputObject == NULL)
		{
			GerrLogMini (GerrId, "Couldn't create JSON_OutputObject!");
			// We should obviously do something more than log an error here -
			// but I'm not yet sure just what. In any case, creating the object
			// should never fail in real life - I hope!
		}
		else
		{
			// There's no point in sending trailing spaces in JSON.
			StripAllSpaces (v_MemberFamilyName);
			StripAllSpaces (v_MemberFirstName);

			// Create and populate Response Header object.
			JSON_OutputHeader = cJSON_AddObjectToObject (JSON_OutputObject, "header");

			if (TransactionID_in == 6101)
			{	// "Chanut Virtualit" response header.
				if (SetErrorVar (&v_ErrorCode, v_ErrorCode))
				{
					// We hit a severe error.
					cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "E"				);
					cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "mac_error_code",		v_ErrorCode		);

					// We previously set HTTP_response_status = 404 for Technical ID not found. If that's what
					// went wrong, preserve this status; otherwise send HTTP Response Status Code 500 (= internal
					// server error) for everything else.
					// DonR 14Jun2021: In fact, we're returning HTTP 500 for all errors.
					if (TranslateTechIdHttpStatus == 404)
					{
						mac_status_code = -97;	// The Technical ID translation service threw a 404 error, which means the Technical ID was not found.
					}
					else
					{
						// If we've already set mac_status_code to something, keep that value; otherwise set it to report a generic -99 error.
						if (mac_status_code == 0)
							mac_status_code = -99;	// Any other fatal error.
					}

					HTTP_response_status = 500;	// Any fatal error occurred.
// mac_notification
// Add an additional tag for the error text from pc_error_message?
				}
				else
				{
					// No severe error.
					HTTP_response_status = 200;	// Already defaulted, but paranoia is our friend!

					if (DrugCount < 1)
					{
						cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "W"	);
						mac_status_code = -96;
					}
					else
					{
						cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "S"	);
						mac_status_code = 0;
					}
				}

				if (mac_status_code)
				{
					cJSON_AddAnyNumberToObject (JSON_OutputHeader, "mac_status_code",		mac_status_code);

					switch (mac_status_code)
					{
//						case 0:		cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "Success"			);	break;
						case -96:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "NoPrescriptions"	);	break;
						case -97:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "NoTechId"			);	break;
						case -98:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "RequestError"		);	break;
						case -99:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "InternalError"		);	break;
						default:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "UnknownError"		);	break;
					}
				}

				cJSON_AddAnyNumberToObject (JSON_OutputHeader, "HTTP_response_status",	HTTP_response_status);

			}	// Transaction 6101 header fields.
			else
			{	// Trn. 6001 JSON response header.
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "ResponseTransactionID",	6002				);
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "CommError",				MAC_OK				);	// Is this really necessary?
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "PharmacyCode",				v_PharmNum			);
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "InstituteCode",			v_InstituteCode		);
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "TerminalNum",				v_TerminalNum		);
				cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "ErrorCode",				v_ErrorCode			);
			}
			// Generate response header.


			// Create and populate Response Payload object.
			JSON_OutputData = cJSON_AddObjectToObject (JSON_OutputObject, "_data");

			// Member/status fields *not* sent for "Chanut Virtualit".
			if (TransactionID_in == 6101)
			{
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "technical_id",			Member.TechnicalID	);
			}
			else
			{	// Member/status fields *not* sent for "Chanut Virtualit".
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "member_id",				Member.ID				);
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "member_id_code",			Member.ID_code			);
				cJSON_AddStringToObject		(JSON_OutputData, "MemberFamilyName",		v_MemberFamilyName		);
				cJSON_AddStringToObject		(JSON_OutputData, "MemberFirstName",		v_MemberFirstName		);
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "MemberDateOfBirth",		Member.date_of_bearth	);
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "MemberGender",			Member.sex				);
				cJSON_AddStringToObject		(JSON_OutputData, "MemberDefaultPhone",		MemberDefaultPhone		);
				cJSON_AddStringToObject		(JSON_OutputData, "MemberLatestPhone",		LatestMemberPhone		);	// Always blank as of 03Feb2015.
				cJSON_AddStringToObject		(JSON_OutputData, "MemberAddress",			MemberAddress			);
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "OpioidLimitExempt",		Member.NarcoLimitExempt	);
				cJSON_AddAnyNumberToObject	(JSON_OutputData, "DigitalStatus",			DigitalStatus			);
			}	// Response header fields for Trn. 6001.

			// Do not output NumDoctorVisits - we're using standard JSON style, where we just send
			// arrays and the receiver derives their size when parsing.

			// Output is organized as visit followed by relevant prescriptions,
			// followed by the next visit and its prescriptions.
//GerrLogMini (GerrId, "6001: Sending %d drugs to Pharmacy %d.", DrugCount, v_PharmNum);
			for (DrugNum = 0; DrugNum < DrugCount; DrugNum++)
			{
				Rx = &SPres[DrugNum].Rx;			// Just for brevity.
				DL = &SPres[DrugNum].DL;			// Just for brevity.
				DP = &SPres[DrugNum].DL_prescribed;	// Just for brevity.
				PL = &SPres[DrugNum];				// Just for brevity.

				// If we've finished with prescriptions from doctor_presc, exit the loop. The "extra"
				// drugs will be reported separately.
				if (PL->IsExtraLargo > 0)
					break;

				// If this array entry is a "visit header", output the visit information.
				if (SPres[DrugNum].NumRxInVisit > 0)
				{
					// For the first visit, create the visit array and the visit object.
					if (FirstDoctorVisit)
					{
						FirstDoctorVisit = 0;

						JSON_OutputVisitsArray = cJSON_AddArrayToObject(JSON_OutputData, "visits_list");
					}

					// Note: After looking at the cJSON code, I *think* doing cJSON_AddItemToArray()
					// before adding stuff to the JSON_OutputVisit object will work OK; if it doesn't,
					// move the cJSON_AddItemToArray() call to the end of the visit's prescriptions
					// (in other words, to the beginning of the *next* visit).
					JSON_OutputVisit = cJSON_AddNewObjectToArray (JSON_OutputVisitsArray);

					StripAllSpaces (PL->DoctorFamilyName);
					StripAllSpaces (PL->DoctorFirstName);
					StripAllSpaces (PL->DocContactPhone);
					StripAllSpaces (PL->ProfDescription);
					StripAllSpaces (Rx->PharmacistAuthorization);

					// Common Visit Header output fields for 6001/6101.
					cJSON_AddAnyNumberToObject	(JSON_OutputVisit, "doctor_id",			Rx->doctor_id			);
					cJSON_AddStringToObject		(JSON_OutputVisit, "doctor_prof",		Rx->speciality_desc		);
					cJSON_AddAnyNumberToObject	(JSON_OutputVisit, "dr_visit_date",		Rx->visit_date			);
					cJSON_AddAnyNumberToObject	(JSON_OutputVisit, "visit_number",		Rx->visit_number		);

					if (TransactionID_in == 6101)
					{	// "Chanut Virtualit" visit header fields.
						sprintf (DoctorName, "%s %s", PL->DoctorFirstName, PL->DoctorFamilyName);

						cJSON_AddStringToObject		(JSON_OutputVisit, "doctor_name",		DoctorName		);
					}	// "Chanut Virtualit" visit header fields.
					else
					{	// Trn. 6001 JSON visit header fields.
						cJSON_AddStringToObject		(JSON_OutputVisit, "DoctorFamilyName",	PL->DoctorFamilyName	);
						cJSON_AddStringToObject		(JSON_OutputVisit, "DoctorFirstName",	PL->DoctorFirstName		);

						// DonR 03Feb2015: Once the new "Clinic Phone" column in doctor_presc is populated, send
						// that rather than the phone number from the Doctors table.
						cJSON_AddStringToObject		(JSON_OutputVisit, "DoctorPhone",		PL->DoctorPhone			);

						cJSON_AddStringToObject		(JSON_OutputVisit, "ClinicAddress",		Rx->clinic_address		);

						// DonR 07Apr2020 CR #32518 - Coronavirus narcotics enhancement.
						// Note that the Doctor Contact Phone(s) field is sent *only* to Maccabi pharmacies.
						// (Note also that the Doctor Contact Phone(s) field is not actually relevant to
						// the coronavirus narcotics enhancement - it's from a previous functionality request.)
						cJSON_AddAnyNumberToObject	(JSON_OutputVisit, "DoctorLicenseNum",	PL->DoctorLicense		);

						if (MACCABI_PHARMACY)
							cJSON_AddStringToObject		(JSON_OutputVisit, "DoctorContactPhone",	PL->DocContactPhone	);

						// DonR 10Dec2025 User Story #441076: Add some new fields here.
						cJSON_AddAnyNumberToObject	(JSON_OutputVisit, "PrescriberProfessionCode",	PL->ProfCodeToPharmacy		);
						cJSON_AddStringToObject		(JSON_OutputVisit, "PrescriberProfessionDesc",	PL->ProfDescription			);
						cJSON_AddStringToObject		(JSON_OutputVisit, "PharmacistAuthorization",	Rx->PharmacistAuthorization	);

					}	// Trn. 6001 JSON visit header fields.

					// DonR 27Nov2017: If pharmacy requested a particular Doctor Prescription ID
					// and/or Visit Number, we send prescriptions conditionally: if *all* the matching
					// prescriptions are expired, we send them all; but if at least one is still valid
					// for sale, we send *only* what's valid. Since we don't know exactly what to send
					// until after we've read all the prescriptions, we need to make some adjustments
					// after the fact and suppress the expired prescriptions if there are non-expired
					// prescriptions. We also need to adjust the "Number of Prescriptions in Visit"
					// to account for these suppressed prescriptions. Note also that we need to output
					// the visit data from the first prescription in the visit, even though that
					// prescription may be one of the suppressed ones.
					if ((Rx->visit_number == VisitNumberToAdjust) && (NumRequestedValid > 0))
					{
						PL->NumRxInVisit -= NumRequestedExpired;		// Note that we may be subtracting zero - which is perfectly OK
																		// if everything that matches the pharmacy request is currently
																		// valid for sale.
						SubtractFromAuditCount = NumRequestedExpired;
					}

					// Do not output NumRxInVisit - we're using standard JSON style, where we just send
					// arrays and the receiver derives their size when parsing.

					JSON_OutputRxArray	= cJSON_AddArrayToObject(JSON_OutputVisit, "items_list");

				}	// Output visit-header-level data.

				// DonR 27Nov2017: Suppress output of expired prescriptions matching the Doctor
				// Prescription ID / Visit Number requested by the pharmacy - IF there is at least
				// one matching *non*-expired prescription.
				if ((NumRequestedValid > 0) && (PL->SuppressOutputToPharmacy > 0))
					continue;

				// Now output the relevant prescriptions for this visit.
				JSON_OutputRx = cJSON_AddNewObjectToArray (JSON_OutputRxArray);

				// DonR 26Jan2022: Note that these StripAllSpaces() are *not* redundant - these strings
				// may have been trimmed of leading/trailing spaces up above, but not necessarily, since
				// the earlier StripAllSpaces() calls are conditional and may not have executed.
				StripAllSpaces (Rx->course_len_units);
				StripAllSpaces (Rx->treatment_side);

//GerrLogMini (GerrId, "6001: PrID %06d, Largo %05d/%05d, FromDate %d.", Rx->doctor_presc_id, Rx->largo_prescribed, DL->largo_code, Rx->valid_from_date);

				// Common Doctor Prescription output fields for 6001/6101.
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "prescription_id",		Rx->doctor_presc_id				);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "presc_start",			Rx->valid_from_date				);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "presc_stop",			Rx->valid_until_date			);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "orig_largo_code",		Rx->largo_prescribed			);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "dispense_largo",		DL->largo_code					);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "delivered_flg",		Rx->sold_status					);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "digital_flg",			Rx->digital_presc_flag			);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "pr_date_ok_to_sell",	PL->PrDateValidForSale			);
//				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "units_prescribed",		Rx->total_units					);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "units_prescribed",		PL->TotalUnitsPrescribed		);
//				cJSON_AddStringToObject		(JSON_OutputRx, "measure_unit_code",	Rx->unit_abbreviation			);
				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "line_no",				Rx->line_number					);

				// PL->DeliveryPermitted is the value set up for the earlier Transaction 6001 online-ordering
				// mechanism. Chanut Virtualit requires a more detailed set of flags to permit or forbid
				// online ordering, delivery, and pickup.
//				cJSON_AddAnyNumberToObject	(JSON_OutputRx, "delivery_flg",			PL->DeliveryPermitted			);

				if (TransactionID_in == 6101)
				{	// "Chanut Virtualit" Doctor Prescription fields.
					cJSON_AddStringToObject		(JSON_OutputRx, "orig_long_name",				DP->long_name				);
					cJSON_AddStringToObject		(JSON_OutputRx, "dispense_long_name",			DL->long_name				);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "units_unsold",					PL->TotalUnitsToSell		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "units_sold",					PL->UnitsAlreadySold		);

					// According to the specification as of 03May2021, Chanut Virtualit wants Package Size = 1 for things
					// like ointments and bottles of solution/suspension. Maybe it would be a good idea to add a separate
					// tag for effective_package_size?
//					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "package_size",					DL->effective_package_size	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "package_size",					DL->package_size			);

					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "shape_code",					DL->shape_code_new			);
					cJSON_AddStringToObject		(JSON_OutputRx, "shape_name_eng",				PL->ShapeName				);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "openable_pkg",					DL->openable_pkg			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "ortho_flg",					DL->is_orthopedic_device	);

					// As of 27Apr2021, usage_instructions is supposed to be returned blank (although it's not mandatory,
					// so it would make the most sense not to send it at all. For now, I'll leave it in since I believe
					// the new "service" that they're supposed to use to get this information from CDS doesn't exist yet.
					// As of 18May2021, usage_instructions is *not* part of the output to Chanut Virtualit.
//					cJSON_AddStringToObject		(JSON_OutputRx, "usage_instructions",			Rx->usage_instructions		);

					// DonR 12Dec2021: Per Iris Shaya, output participation amounts in shekels, *not* agorot.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "pkg_member_ptn_amt",			((double)PL->MemberPtnPerPackage	/ (double)100)	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "member_ptn_amt",				((double)PL->TotalMemberPtn			/ (double)100)	);
//GerrLogMini (GerrId, "MemberPtnPerPackage = %d, sending %f; TotalMemberPtn = %d, sending %f.",
//	PL->MemberPtnPerPackage, ((double)PL->MemberPtnPerPackage	/ (double)100), PL->TotalMemberPtn, ((double)PL->TotalMemberPtn			/ (double)100));
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "online_sale_flg",				PL->OnlineSalePermitted		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "pickup_flg",					PL->PickupPermitted			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "delivery_flg",					PL->DeliveryPermitted		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "reason_forbidden_code",		PL->ReasonForbiddenCode		);	// JUST FOR TESTING.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "conversation_reason_code",		PL->ConversationReasonCode	);	// JUST FOR TESTING.

					if (PL->ReasonForbiddenCode > 0)
					{
						cJSON_AddStringToObject		(JSON_OutputRx, "sale_reason",				PL->ReasonForbiddenDesc		);
						cJSON_AddAnyNumberToObject	(JSON_OutputRx, "disp_sale_reason_flg",		PL->DisplayReasonForbidden	);
					}

					if (PL->ConversationReasonCode > 0)
					{
						cJSON_AddAnyNumberToObject	(JSON_OutputRx, "conversation_flg",				PL->ConversationRequired		);	// Non-mandatory - output only if there's a "conversation reason".
						cJSON_AddStringToObject		(JSON_OutputRx, "conversation_reason",			PL->ConversationReasonDesc		);
//						cJSON_AddAnyNumberToObject	(JSON_OutputRx, "disp_conversation_reason",		PL->DisplayConversationReason	);	// Not in spec - but maybe someone will change their mind!
					}

				}	// "Chanut Virtualit" Doctor Prescription fields.
				else
				{	// Trn. 6001 JSON Doctor Prescription fields.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "DoseNumber",			Rx->dose_number			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "MemberPriceCode",		PL->PriceCode			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "FixedPriceFlag",		PL->FixedPriceFlag		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "PriceMessageCode",		PL->PriceMessageCode	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "DeletedStatus",		Rx->deleted_status		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "OrderNumber",			Rx->order_number		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "OP_Prescribed",		Rx->op					);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "QtyMethod",			Rx->qty_method			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "OP_ToSell",			PL->OPToSell			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "UnitsToSell",			PL->UnitsToSell			);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "PrType",				Rx->prescription_type	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "UsageCode",			Rx->usage_method_code	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "DoseTimes100",			PL->dose_times_100		);	// Change to decimal?
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "DosesPerDay",			Rx->doses_per_day		);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "TreatmentLength",		Rx->treatment_length	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "CourseTreatDays",		Rx->course_treat_days	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "CourseLength",			Rx->course_len			);
					cJSON_AddStringToObject		(JSON_OutputRx, "CourseLenUnits",		Rx->course_len_units	);
					cJSON_AddStringToObject		(JSON_OutputRx, "DaysPerWeek",			Rx->days_per_week		);
					cJSON_AddStringToObject		(JSON_OutputRx, "TimesOfDay",			Rx->morning_evening		);
					cJSON_AddStringToObject		(JSON_OutputRx, "SideOfBody",			Rx->treatment_side		);
					cJSON_AddStringToObject		(JSON_OutputRx, "usage_instructions",	Rx->usage_instructions	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "RuleNumber",			Rx->rule_number			);

					// This is the "old" Delivery Permitted flag - as opposed to the more detailed fields that are
					// sent for Chanut Virtualit.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "delivery_flg",			PL->SuperPharmDeliveryPermitted	);

					// NOTE: For now at least, special logic for Largo 99999 (where the doctor provides
					// a text description of what is to be dispensed) is not implemented. If this logic
					// is eventually implemented, it will require two new fields after Number of Courses;
					// the second field will be a zero-or-more repeating text field.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "NumberOfCourses",		Rx->num_courses			);

					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "OtherValidPrExists",	PL->OtherValidRxExists	);	// CR #13141.

					// DonR 21Nov2017: At least for now, the Drug-List is_out_of_stock field is not getting
					// populated - so there is no point in sending it to pharmacies.
//					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "DrugOutOfStock",		DL->is_out_of_stock		);

					// DonR 11Jun2018 Online Order (SuperPharm): Send new Delivery Permitted and Prati plus flags.
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "PtnNeedsPratiPlus",	PL->PtnRequiresPratiPlus);

					// DonR 07Apr2020 CR #32518 - Coronavirus narcotics enhancement.
					// Pharmacy must print a paper copy of the presciption if this is a digital
					// prescription for a narcotic. If the member has a non-digital narcotic
					// prescription, s/he has to have the paper prescription in hand.
					// Marianna 30Jan2024 User Story #540234  -for Cannabis products, pharmacy needs print a paper copy.
					// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
//					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "PrintNarcoticPr",	(((DL->drug_type == 'N')	|| (DL->drug_type == 'K')) && (Rx->digital_presc_flag > 0)) ? 1 : 0	);
					cJSON_AddAnyNumberToObject	(JSON_OutputRx, "PrintNarcoticPr",	(((DL->is_narcotic)	|| (DL->drug_type == 'K')) && (Rx->digital_presc_flag > 0)) ? 1 : 0	);
					
					// Marianna 4Nov2021 new output lines 68-73 from fixed-format version.
					// NOTE: When we actually start implementing a JSON version of Transaction 6001, we'll need
					// to go over what is and is not mandatory; for now, output everything.
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "online_sale_flg",				PL->OnlineSalePermitted				);
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "pickup_flg",					PL->PickupPermitted					);
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "chanut_delivery_flg",			PL->DeliveryPermitted				); // given new different tag name 
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "reason_forbidden_code",			PL->ReasonForbiddenCode				);
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "conversation_flg",				PL->ConversationRequired			);	// Non-mandatory - output only if there's a "conversation reason".
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "conversation_reason_code",		PL->ConversationReasonCode			);

					// DonR 10Dec2025 User Story #441076: Add some new fields.
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "IsCannabis",					PL->IsCannabis						);
					cJSON_AddAnyNumberToObject (JSON_OutputRx, "IsPreparation",					PL->IsPreparation					);

					if (PL->NumMessageLines > 0)
						cJSON_AddStringToObject	(JSON_OutputRx, "MessageToPharmacist",			Rx->internal_comments				);

				}	// Trn. 6001 JSON Doctor Prescription fields.

			}	// Loop through drugs prescribed.

			// Output prior drug sales.
			// Do not output NumDoctorVisits - we're using standard JSON style, where we just send
			// arrays and the receiver derives their size when parsing.
			if (NumPriorSales > 0)
			{
				JSON_PriorSalesArray = cJSON_AddArrayToObject(JSON_OutputData, "PriorSales");

				for (DrugNum = 0; DrugNum < NumPriorSales; DrugNum++)
				{
					JSON_PriorSale = cJSON_AddNewObjectToArray (JSON_PriorSalesArray);

					cJSON_AddAnyNumberToObject	(JSON_PriorSale, "LargoSold",		PriorSales[DrugNum].LargoCode		);
					cJSON_AddAnyNumberToObject	(JSON_PriorSale, "PreferenceGroup",	PriorSales[DrugNum].EconomypriGroup	);
					cJSON_AddAnyNumberToObject	(JSON_PriorSale, "LastSaleDate",	PriorSales[DrugNum].LastSaleDate	);
					cJSON_AddAnyNumberToObject	(JSON_PriorSale, "OP_Sold",			PriorSales[DrugNum].OP				);
					cJSON_AddAnyNumberToObject	(JSON_PriorSale, "UnitsSold",		PriorSales[DrugNum].Units			);
				}	// Loop through prior drug sales.
			}	// There are prior drug sales to report.


			// Output participation information for "extra" largos (representing on-paper
			// prescriptions presented by Member).
			// Do not output NumExtraLargos - we're using standard JSON style, where we just send
			// arrays and the receiver derives their size when parsing.
			if (NumRxFromDB < DrugCount)
			{
				JSON_PaperPrescArray = cJSON_AddArrayToObject(JSON_OutputData, "PaperPrescriptions");

				// Note that we start from the first entry in the SPres array that was NOT read from the doctor_presc
				// table! Note also that we report the Largo Code sent by the pharmacy, even though participation
				// calculations may have been based on a generic substitution of another drug.
				for (DrugNum = NumRxFromDB; DrugNum < DrugCount; DrugNum++)
				{
					JSON_PaperPrescription = cJSON_AddNewObjectToArray (JSON_PaperPrescArray);

					Rx = &SPres[DrugNum].Rx;	// Just for brevity.
					DL = &SPres[DrugNum].DL;	// Just for brevity. (This one isn't being used, but I'll leave it here just in case.)
					PL = &SPres[DrugNum];		// Just for brevity.

					cJSON_AddAnyNumberToObject	(JSON_PaperPrescription, "LargoPrescribed",		Rx->largo_prescribed	);
					cJSON_AddAnyNumberToObject	(JSON_PaperPrescription, "MemberPriceCode",		PL->PriceCode			);
					cJSON_AddAnyNumberToObject	(JSON_PaperPrescription, "FixedPriceFlag",		PL->FixedPriceFlag		);
					cJSON_AddAnyNumberToObject	(JSON_PaperPrescription, "PriceMessageCode",	PL->PriceMessageCode	);
				}	// Loop through paper prescriptions ("extra largos").
			}	// Pharmacy gave a list of "extra largos" from paper prescriptions.


			// DonR 10Dec2025 CR #441076 - Add a list of the member's ishur Largo Codes.
			if (NumIshurLargos > 0)
			{
				JSON_IshurLargoArray = cJSON_AddArrayToObject(JSON_OutputData, "IshurLargoCodes");

				for (DrugNum = 0; DrugNum < NumIshurLargos; DrugNum++)
				{
					// Trying this with a blank tag - what I want is a plain array of Largo Codes.
					cJSON_AddAnyNumberToObject	(JSON_IshurLargoArray,	"",						IshurLargos [DrugNum]	);
				}
			}


			// Send the output JSON hierarchy to file and delete it from memory.
			cJSON_PrintToFP (JSON_OutputObject, outFP);
//			cJSON_PrintUnformattedToFP (JSON_OutputObject, outFP);
			cJSON_Delete (JSON_OutputObject);
		}	// JSON_OutputObject is NOT NULL.

	}	// JSON output mode.

	else
	{	// Non-JSON mode - send fixed-position output values to output file.
		fprintf (outFP, "%0*d",		 5,		6002									);	//		Length =   5
		fprintf (outFP, "%0*d",		 4,		MAC_OK									);	//		Length =   9
		fprintf (outFP, "%0*d",		 7,		v_PharmNum								);	//  1	Length =  16
		fprintf (outFP, "%0*d",		 2,		v_InstituteCode							);	//  2	Length =  18
		fprintf (outFP, "%0*d",		 2,		v_TerminalNum							);	//  3	Length =  20
		fprintf (outFP, "%0*d",		 4,		v_ErrorCode								);	//  4	Length =  24
		fprintf (outFP, "%0*d",		 9,		Member.ID								);	//  5	Length =  33
		fprintf (outFP, "%0*d",		 1,		Member.ID_code							);	//  6	Length =  34
		fprintf (outFP, "%-*.*s",	14, 14,	v_MemberFamilyName						);	//  7	Length =  48
		fprintf (outFP, "%-*.*s",	 8,  8,	v_MemberFirstName						);	//  8	Length =  56
		fprintf (outFP, "%0*d",		 8,		Member.date_of_bearth					);	//  9	Length =  64
		fprintf (outFP, "%0*d",		 1,		Member.sex								);	// 10	Length =  65
		fprintf (outFP, "%*.*s",	10, 10,	MemberDefaultPhone						);	// 11	Length =  75
		fprintf (outFP, "%*.*s",	10, 10,	LatestMemberPhone						);	// 12 - always blank as of 03Feb2015.Length =  85
		fprintf (outFP, "%-*.*s",	50, 50,	MemberAddress							);	// 13	Length = 135
		fprintf (outFP, "%0*d",		 1,		DigitalStatus							);	// 14	Length = 136

		// DonR 07Apr2020 CR #32518 - Coronavirus narcotics enhancement.
		if (VersionNumber > 2)
		{
			fprintf (outFP, "%0*d",		 1,			Member.NarcoLimitExempt			);	// 15	Length = 137
			fprintf (outFP, "%*.*s",	 9,    9,	""								);	// 16 (Reserved) Length = 146
		}

		fprintf (outFP, "%0*d",		 3,		NumDoctorVisits							);	// 17	Length = 149
//if (!TikrotProductionMode)
//GerrLogMini (GerrId, "6001: NumDoctorVisits = %d.", NumDoctorVisits);
		// Header length = 135.

		// Output is organized as visit followed by relevant prescriptions,
		// followed by the next visit and its prescriptions.
//GerrLogMini (GerrId, "6001: Sending %d drugs to Pharmacy %d.", DrugCount, v_PharmNum);
		for (DrugNum = 0; DrugNum < DrugCount; DrugNum++)
		{
			Rx = &SPres[DrugNum].Rx;	// Just for brevity.
			DL = &SPres[DrugNum].DL;	// Just for brevity.
			PL = &SPres[DrugNum];		// Just for brevity.

			// If we've finished with prescriptions from doctor_presc, exit the loop. The "extra"
			// drugs will be reported separately.
			if (PL->IsExtraLargo > 0)
				break;
//if (!TikrotProductionMode)
//GerrLogMini (GerrId, "6001: Line %d/%d Largo to sell %d NumRxInVisit %d.", DrugNum, DrugCount, DL->largo_code, SPres[DrugNum].NumRxInVisit);

			// If this array entry is a "visit header", output the visit information.
			if (SPres[DrugNum].NumRxInVisit > 0)
			{
				fprintf (outFP, "%0*d",		 9,		Rx->doctor_id					);	// 18
				fprintf (outFP, "%-*.*s",	14, 14,	PL->DoctorFamilyName			);	// 19
				fprintf (outFP, "%-*.*s",	 8,  8,	PL->DoctorFirstName				);	// 20
				fprintf (outFP, "%-*.*s",	25, 25,	Rx->speciality_desc				);	// 21

				// DonR 03Feb2015: Once the new "Clinic Phone" column in doctor_presc is populated, send
				// that rather than the phone number from the Doctors table.
				fprintf (outFP, "%*.*s",	10, 10,	PL->DoctorPhone					);	// 22

				fprintf (outFP, "%0*d",		 8,		Rx->visit_date					);	// 23
				fprintf (outFP, "%0*ld",	11,		Rx->visit_number				);	// 24

				// DonR 21Nov2016: Add Clinic Address if Transaction Version Number is 2 or greater.
				// DonR 10Jan2017: Possible additional change: also add Doctor Phone Number. This
				// should be a mobile phone number once we can get it. For now, it's commented out.
				if (VersionNumber > 1)
				{
					fprintf (outFP, "%-*.*s",	60, 60,	Rx->clinic_address			);	// 25
				}

				// DonR 07Apr2020 CR #32518 - Coronavirus narcotics enhancement.
				// Note that the Doctor Contact Phone(s) field is sent *only* to Maccabi pharmacies.
				// (Note also that the Doctor Contact Phone(s) field is not actually relevant to
				// the coronavirus narcotics enhancement - it's from a previous functionality request.)
				if (VersionNumber > 2)
				{
					fprintf (outFP, "%0*d",		 6,		PL->DoctorLicense								);	// 26
					fprintf (outFP, "%*.*s",	40, 40,	(MACCABI_PHARMACY) ? PL->DocContactPhone : ""	);	// 27

					// DonR 10Dec2025 User Story #441076: This "filler" field is not used for Version Number >= 6.
					// NOTE: By mistake, Yarpa moved to Version 5 even though nothing had changed after Version 3.
					// So we have to treat Version 5 from the pharmacy as if they had sent 3. (Nobody is sending 4.)
					if (VersionNumber < 6)	// 3, 4, or 5.
						fprintf (outFP, "%*.*s",	10, 10,	""											);	// 28 (Reserved)
				}

				// DonR 10Dec2025 User Story #441076: Add some new fields here.
				if (VersionNumber > 5)
				{
					fprintf (outFP, "%0*d",		 1,		PL->ProfCodeToPharmacy							);	// 28 (ignoring Version 3's "reserved")
					fprintf (outFP, "%-*.*s",	25, 25,	PL->ProfDescription								);	// 29
					fprintf (outFP, "%-*.*s",	20, 20,	Rx->PharmacistAuthorization						);	// 30
				}



				// DonR 27Nov2017: If pharmacy requested a particular Doctor Prescription ID
				// and/or Visit Number, we send prescriptions conditionally: if *all* the matching
				// prescriptions are expired, we send them all; but if at least one is still valid
				// for sale, we send *only* what's valid. Since we don't know exactly what to send
				// until after we've read all the prescriptions, we need to make some adjustments
				// after the fact and suppress the expired prescriptions if there are non-expired
				// prescriptions. We also need to adjust the "Number of Prescriptions in Visit"
				// to account for these suppressed prescriptions. Note also that we need to output
				// the visit data from the first prescription in the visit, even though that
				// prescription may be one of the suppressed ones.
				if ((Rx->visit_number == VisitNumberToAdjust) && (NumRequestedValid > 0))
				{
					PL->NumRxInVisit -= NumRequestedExpired;		// Note that we may be subtracting zero - which is perfectly OK
																	// if everything that matches the pharmacy request is currently
																	// valid for sale.
					SubtractFromAuditCount = NumRequestedExpired;
				}

				fprintf (outFP, "%0*d",		 3,		PL->NumRxInVisit				);	// 31
				// Visit length = 148 (88 for Version < 2).
			}	// Output visit-level data.

			// DonR 27Nov2017: Suppress output of expired prescriptions matching the Doctor
			// Prescription ID / Visit Number requested by the pharmacy - IF there is at least
			// one matching *non*-expired prescription.
			if ((NumRequestedValid > 0) && (PL->SuppressOutputToPharmacy > 0))
				continue;

			// Now output the relevant prescriptions for this visit.
//GerrLogMini (GerrId, "6001: PrID %06d, Largo %05d/%05d, FromDate %d.", Rx->doctor_presc_id, Rx->largo_prescribed, DL->largo_code, Rx->valid_from_date);
			fprintf (outFP, "%0*d",		  6,		Rx->doctor_presc_id				);	// 32
			fprintf (outFP, "%0*d",		  1,		Rx->dose_number					);	// 33
			fprintf (outFP, "%0*d",		  8,		Rx->valid_from_date				);	// 34
			fprintf (outFP, "%0*d",		  8,		Rx->valid_until_date			);	// 35
			fprintf (outFP, "%0*d",		  9,		Rx->largo_prescribed			);	// 36
			fprintf (outFP, "%0*d",		  9,		DL->largo_code					);	// 37
			fprintf (outFP, "%0*d",		  4,		PL->PriceCode					);	// 38
			fprintf (outFP, "%0*d",		  1,		PL->FixedPriceFlag				);	// 39
			fprintf (outFP, "%0*d",		  3,		PL->PriceMessageCode			);	// 40
			fprintf (outFP, "%0*d",		  1,		Rx->sold_status					);	// 41
			fprintf (outFP, "%0*d",		  1,		Rx->deleted_status				);	// 42
			fprintf (outFP, "%0*d",		  1,		Rx->digital_presc_flag			);	// 43
			fprintf (outFP, "%0*d",		 10,		Rx->order_number				);	// 44
			fprintf (outFP, "%0*d",		  1,		PL->PrDateValidForSale			);	// 45
			fprintf (outFP, "%0*d",		  5,		Rx->op							);	// 46
			fprintf (outFP, "%0*d",		  5,		Rx->total_units					);	// 47
			fprintf (outFP, "%0*d",		  1,		Rx->qty_method					);	// 48
			fprintf (outFP, "%0*d",		  5,		PL->OPToSell					);	// 49
			fprintf (outFP, "%0*d",		  5,		PL->UnitsToSell					);	// 50
			fprintf (outFP, "%0*d",		  1,		Rx->prescription_type			);	// 51
			fprintf (outFP, "%0*d",		  3,		Rx->usage_method_code			);	// 52
			fprintf (outFP, "%0*d",		  6,		PL->dose_times_100				);	// 53
			fprintf (outFP, "%-*.*s",	  3,   3,	Rx->unit_abbreviation			);	// 54
			fprintf (outFP, "%0*d",		  1,		Rx->doses_per_day				);	// 55
			fprintf (outFP, "%0*d",		  3,		Rx->treatment_length			);	// 56
			fprintf (outFP, "%0*d",		  3,		Rx->course_treat_days			);	// 57
			fprintf (outFP, "%0*d",		  2,		Rx->course_len					);	// 58
			fprintf (outFP, "%-*.*s",	  6,   6,	Rx->course_len_units			);	// 59
			fprintf (outFP, "%-*.*s",	 20,  20,	Rx->days_per_week				);	// 60

			fprintf (outFP, "%-*.*s",	(VersionNumber == 0) ? 40 : 200,
										(VersionNumber == 0) ? 40 : 200,
													Rx->morning_evening				);	// 61

			fprintf (outFP, "%-*.*s",	 10,  10,	Rx->treatment_side				);	// 62
			fprintf (outFP, "%-*.*s",	100, 100,	Rx->usage_instructions			);	// 63

			if (VersionNumber > 0)
			{
				fprintf (outFP, "%0*d",	  9,		Rx->rule_number					);	// 64
				fprintf (outFP, "%0*d",	  3,		Rx->line_number					);	// 65
			}

			// DonR 07Dec2016: Add Number of Courses if Transaction Version Number is 2 or greater.
			// NOTE: For now at least, special logic for Largo 99999 (where the doctor provides
			// a text description of what is to be dispensed) is not implemented. If this logic
			// is eventually implemented, it will require two new fields after Number of Courses;
			// the second field will be a zero-or-more repeating text field.
			if (VersionNumber > 1)
			{
				fprintf (outFP, "%0*d",	  3,		Rx->num_courses					);	// 66
			}

			if (VersionNumber > 0)
			{
				fprintf (outFP, "%0*d",	  1,		PL->OtherValidRxExists			);	// 67 (CR #13141).

				// DonR 21Nov2017: At least for now, the Drug-List is_out_of_stock field is not getting
				// populated - so there is no point in sending it to pharmacies.
//				fprintf (outFP, "%0*d",	  1,		DL->is_out_of_stock				);	// 61
//				fprintf (outFP, "%*.*s",  5,   5,	""								);	// 62 (Reserved)

				// DonR 11Jun2018 Online Order (SuperPharm): Send new Delivery Permitted and Prati plus flags.
				// DonR 17Aug2021 "Chanut Virtualit": Split Delivery Permitted into two flags: the original
				// one based on the SuperPharm specification is SuperPharmDeliveryPermitted, and is sent as
				// part of the Transaction 6001 output; and the new one is stored as DeliveryPermitted, and
				// is sent in the Transaction 6101 output.
				fprintf (outFP, "%0*d",	  1,		PL->SuperPharmDeliveryPermitted	);	// 68
				fprintf (outFP, "%0*d",	  1,		PL->PtnRequiresPratiPlus		);	// 69

				// DonR 07Apr2020 CR #32518 - Coronavirus narcotics enhancement.
				if (VersionNumber > 2)
				{
					// Pharmacy must print a paper copy of the presciption if this is a digital
					// prescription for a narcotic. If the member has a non-digital narcotic
					// prescription, s/he has to have the paper prescription in hand.
					// Marianna 30Jan2024 User Story #540234  -for Cannabis products, pharmacy needs print a paper copy.
					// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
//					fprintf (outFP, "%0*d",		 1,	(((DL->drug_type == 'N')	|| (DL->drug_type == 'K')) && (Rx->digital_presc_flag > 0)) ? 1 : 0	);	// 67
					fprintf (outFP, "%0*d",		 1,	(((DL->is_narcotic)	|| (DL->drug_type == 'K')) && (Rx->digital_presc_flag > 0)) ? 1 : 0	);	// 70

					// Marianna 01Nov2021: Changed "filler" to permitted flags, Reason Forbidden Code, and Conversation Reason Code.
//					fprintf (outFP, "%*.*s",	10, 10,	""							);	// 68 (Reserved)
					fprintf (outFP, "%0*d",    	1,		PL->OnlineSalePermitted		);  // 71 Marianna new line 01Nov2021  
					fprintf (outFP, "%0*d",    	1,      PL->DeliveryPermitted		);  // 72 Marianna new line 01Nov2021
					fprintf (outFP, "%0*d",    	1,      PL->PickupPermitted			);  // 73 Marianna new line 01Nov2021
					fprintf (outFP, "%0*d",    	3,      PL->ReasonForbiddenCode		);  // 74 Marianna new line 01Nov2021
					fprintf (outFP, "%0*d",    	1,      PL->ConversationRequired	);  // 75 Marianna new line 01Nov2021
					fprintf (outFP, "%0*d",    	3,      PL->ConversationReasonCode	);  // 76 Marianna new line 01Nov2021
				}	// Version Number >= 3.
				else
				{
					fprintf (outFP, "%*.*s",  4,   4,	""							);	// 71 (Reserved)
				}	// Version Number = 1 or 2.

				// DonR 10Dec2025 CR #441076 - Add some more new fields.
				if (VersionNumber > 5)
				{
					fprintf (outFP, "%0*d",    	1,      PL->IsCannabis				);  // 77
					fprintf (outFP, "%0*d",    	1,      PL->IsPreparation			);  // 78
					fprintf (outFP, "%0*d",    	2,      PL->NumMessageLines			);  // 79

					if (PL->NumMessageLines > 0)
						fprintf (outFP, "%-*.*s",	500, 500,	Rx->internal_comments	);	// 80
				}
			}

			// Prescription length (version > 0) = 464 (461 for Version 1).
		}	// Loop through drugs prescribed.

		// Output prior drug sales.
		fprintf			(outFP, "%0*d",	  3,	NumPriorSales						);	// 81
		for (DrugNum = 0; DrugNum < NumPriorSales; DrugNum++)
		{
			fprintf (outFP, "%0*d",		  9,	PriorSales[DrugNum].LargoCode		);	// 82
			fprintf (outFP, "%0*d",		  6,	PriorSales[DrugNum].EconomypriGroup	);	// 83
			fprintf (outFP, "%0*d",		  8,	PriorSales[DrugNum].LastSaleDate	);	// 84
			fprintf (outFP, "%0*d",		  5,	PriorSales[DrugNum].OP				);	// 85
			fprintf (outFP, "%0*d",		  5,	PriorSales[DrugNum].Units			);	// 86
			// Prior sale length = 33.
		}	// Loop through prior drug sales.


		// Output participation information for "extra" largos (representing on-paper prescriptions
		// presented by Member).
		fprintf			(outFP, "%0*d",	  3,	NumExtraLargos						);	// 87

		// Note that we start from the first entry in the SPres array that was NOT read from the doctor_presc
		// table! Note also that we report the Largo Code sent by the pharmacy, even though participation
		// calculations may have been based on a generic substitution of another drug.
		for (DrugNum = NumRxFromDB; DrugNum < DrugCount; DrugNum++)
		{
			Rx = &SPres[DrugNum].Rx;	// Just for brevity.
			DL = &SPres[DrugNum].DL;	// Just for brevity.
			PL = &SPres[DrugNum];		// Just for brevity.

			fprintf (outFP, "%0*d",		  9,	Rx->largo_prescribed				);	// 88
			fprintf (outFP, "%0*d",		  4,	PL->PriceCode						);	// 89
			fprintf (outFP, "%0*d",		  1,	PL->FixedPriceFlag					);	// 90
			fprintf (outFP, "%0*d",		  3,	PL->PriceMessageCode				);	// 91
		}

		// DonR 10Dec2025 CR #441076 - Add a list of the member's ishur Largo Codes.
		if (VersionNumber > 5)
		{
			fprintf (outFP, "%0*d",		  3,	NumIshurLargos						);	// 92

			for (DrugNum = 0; DrugNum < NumIshurLargos; DrugNum++)
			{
				fprintf (outFP, "%0*d",	  9,	IshurLargos [DrugNum]				);	// 93
			}
		}
	}	// Non-JSON mode - send fixed-position output values to output file.


	fclose (outFP);

	// Write the name of output-file on string for T-SWITCH.
	*p_outputWritten = sprintf (OBuffer, "%s", fileName);
	*output_type_flg = ANSWER_IN_FILE;

	// DonR 27Jun2018: Up to now, we weren't saving the error code for this transaction. Now we are!
	// DonR 31May2020: Added assignment of Terminal ID to ssmd_data_ptr structure, so it'll be
	// recorded properly in messages_details.
	ssmd_data_ptr->error_code	= v_ErrorCode;
	ssmd_data_ptr->terminal_num	= v_TerminalNum;

	// DonR 23Nov2017: Store numberbar of prescription rows read from DB in audit variable;
	// leave "extra" largos out of the picture.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = (NumRxFromDB - SubtractFromAuditCount);

	RESTORE_ISOLATION;

	return  RC_SUCCESS;
}	// End of 6001/6101 handler.



/*=======================================================================
||																		||
||			 HandlerToMsg_6003											||
||	Message handler for message 6003:									||
||     Drugs Sale Request - "Mersham Digitali" version					||
||																		||
 =======================================================================*/

int HandlerToMsg_6003 (	int			TrNum,
						char		*IBuffer,
						int			TotalInputLen,
						char		*OBuffer,
						int			*p_outputWritten,
						int			*output_type_flg,
						SSMD_DATA	*ssmd_data_ptr,
						int			*NumProcessed_out)
{
	// Local declarations.
	int					retries;
	int					reStart;
	int					ErrOverflow;
	int					i;
	int					j;
	int					ingred;
	int					is;
	int					flg	= 0;
	int					UnitsSold;
	int					ErrorCodeToAssign		= 0;
	int					MaxFutureDate;			// DonR 11Sep2012.
	int					HoldLargo;
	int					DrugStartDate;
	int					HoldSpecialistDrug;
	int					HoldParentGroupCode;
	int					PtnOpPrice;
	int					PreparationLinkLargo;	// DonR 07Dec2010 for new "preparation" consistency check.
	int					TestLinkLargo;			// DonR 07Dec2010 for new "preparation" consistency check.
	int					FullPriceTotal	= 0;	// DonR 12Mar2012
	short				HoldRuleStatus;
	short				TypeCheckSpecPr;
	short				v_Message;
	short				DispenseAsWritten;
	short				MajorDrugIndex [MAX_REC_ELECTRONIC];
	short				err;
	short				PharmacyOpenErr;		// Marianna 17Mar2024 User Story #540234
	short				FunctionError;
	short				percent1;
	short				percent2;
	short				percents;
	short				DeletionValid			= 1;
	short				DrugPriceMemHospTrigger	= 0;
	short				Agorot;					// DonR 16Dec2013;
	short				Permit100PercentSale;
	short				MaxRx					= 1;	// DonR 25May2015: Position 0 represents a blank Doctor Prescription - for lines with no corresponding prescriptions.
	short				DoctorInList			= 0;
	short				found_partially_sold_rx	= 0;
	short				rx_already_checked		= 0;
	short				ForceCardExpiredErr		= 0;
	short				FirstPurchaseOfDrug		= 0;
	double				PtnWorkVar;
	double				OverseasWorkVar;
	char				filler [256];
	bool				GoToMeishar;

	// "Nihul Tikrot" remote procedure call buffers and related fields.
	char				DrugTikraType		[MAX_REC_ELECTRONIC];
	char				DrugCoupon			[MAX_REC_ELECTRONIC];
	int					DrugRefundOffset	[MAX_REC_ELECTRONIC];
	char				TikrotHeader		[RPC_INP_HEADER_LEN];
	char				TikrotCurrentSale	[RPC_INP_CURRSALE_LEN];
	char				TikrotPriorSales	[RPC_INP_PRIORSALES_LEN];
	char				TikraType			[MAX_TIKRA_TIKROT_OUT];
	char				TikraPeriodDesc		[MAX_TIKRA_TIKROT_OUT] [7];
	short				TikraBasket			[MAX_TIKRA_TIKROT_OUT];
	short				TikraInsurance		[MAX_TIKRA_TIKROT_OUT];
	int					TikraAggPrevPtn		[MAX_TIKRA_TIKROT_OUT];
	int					TikraAggPrevWaived	[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrPtn		[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrWaived		[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrLevel		[MAX_TIKRA_TIKROT_OUT];
	short				TikraCouponCode		[MAX_TIKRA_COUPONS_OUT];
	int					TikraCouponAmt		[MAX_TIKRA_COUPONS_OUT];
	int					FamilyMemberTZ		[MAX_FAMILY_SIZE];
	short				FamilyMemberTZCode	[MAX_FAMILY_SIZE];
	short				FamilySize;
	short				FamilySalePrID_count;
	char				*HeaderRtn;
	char				*TikrotRtn;
	char				*CurrentSaleRtn;
	char				*CouponsRtn;
	short				NumTikrotLines;
	short				NumSaleLines;
	short				NumCouponLines;
	Tmember_price_row	PriceRow;
	char				*WritePtr;

	ISOLATION_VAR;

	// Variables for retrieving error count and array.
	int					ErrorCount;
	TErrorArray			*ErrorArray;

	// Return variables for AS400 Gadget participation check routine.
	int					i_dummy;
	int					l_dummy;
	int					UnitPrice;
	int					QuantityPermitted;
	int					RequestNum;
	int					PtnPrice;
	int					Insurance;
	int					MeisharInfoCode;


	// SQL variables.

	// Arrays to hold drugs prescribed data.
	TPresDrugs		SPres					[MAX_REC_ELECTRONIC];
	TDocRx			DocRx					[1001];
	short			PR_WhyNonPreferredSold	[MAX_REC_ELECTRONIC];
	short			PR_ExtendAS400IshurDays	[MAX_REC_ELECTRONIC];
	short			preferred_mbr_prc_code	[MAX_REC_ELECTRONIC];
	short			gadget_svc_number		[MAX_REC_ELECTRONIC];
	short			gadget_svc_type			[MAX_REC_ELECTRONIC];
	short			PR_AsIf_Preferred_SpDrug[MAX_REC_ELECTRONIC];
	short			PR_AsIf_Preferred_Basket[MAX_REC_ELECTRONIC];
	short			PR_AsIf_RuleStatus		[MAX_REC_ELECTRONIC];
	short			Delete_LineNumber		[MAX_REC_ELECTRONIC];;
	int				gadget_svc_code			[MAX_REC_ELECTRONIC];
	int				PR_Original_Largo_Code	[MAX_REC_ELECTRONIC];
	int				PR_AsIf_Preferred_Largo	[MAX_REC_ELECTRONIC];
	int				PR_AsIf_ParentGroupCode	[MAX_REC_ELECTRONIC];
	int				PharmIshurProfession	[MAX_REC_ELECTRONIC];
	int				MemberPtnAmount			[MAX_REC_ELECTRONIC];

	// Input message variables.
	PHARMACY_INFO	Phrm_info;
	TDrugListRow	DL_prescribed;
	int				v_PharmNum;
	short			v_InstituteCode;
	short			v_TerminalNum;
	short			v_ActionType;
	short			SALE_ACTION	= DRUG_SALE;
	int				v_MemberIdentification;
	short			v_IdentificationCode;
	short			v_IdentificationCode_s;
	short			v_MemberBelongCode;
	short		 	v_MoveCard;
	short			v_in_hospital;	// DonR 02Aug2011 - Member Hospitalization Warning enhancement.
	short			v_TypeDocID;	// REPLACE SPres[i].DocIDType
	int				DocID;			// REPLACE SPres[i].DocID
	short			Rx;

	int				v_DoctorLocationCode;
	int				v_ClientLocationCode;
	char			first_center_type [5];
	short			FirstCenterTypeNum;
	short			v_NumOfDrugLinesRecs;
	short			v_NumValidDrugLines;
	short			v_NumDrugLinesSent;
	short			v_MsgExistsFlg;
	short			v_MsgIsUrgentFlg;
	short			OriginCode		= TrNum;
	int				OriginCodeInt	= TrNum;	// For compatibility with UPD_members_ClearAuthorizeAlways.

	// Remote order variables.
	long			online_order_num	= 0L;
	int				OO_member_id;
	short			OO_member_id_code;
	int				OO_made_date;
	int				OO_made_time;
	int				OO_start_work_date;
	int				OO_start_work_time;
	int				OO_min_made_date;
	int				OO_min_work_date;
	int				OO_min_work_time;

	// "Nihul Tikrot" variables.
	short			DL_TikratMazonFlag;
	short			MemberBuyingTikMazon;
	short			MemberBuyingLH_FSH;			// DonR 11Feb2025 User Story #376480
	short			CheckThisDrugPiryonTikra;	// DonR 11Feb2025 User Story #376480
	short			CheckMonthlyPiryonTikra;	// DonR 11Feb2025 User Story #376480
	short			ThisIshurHasTikra;
	short			AnIshurHasTikra;
	short			TikrotRPC_Called;
	short			TikrotRPC_Error;
	short			TikrotStatus;
	int				FamilySalePrID;
	int				Yesterday;
	int				FamilyMemberID;
	short			FamilyMemberIDCode;
	char			v_DrugTikraType [2];
	short			v_DrugSubsidized;
	int				MemberPtnAmt;
	int				ChemicalPrice;
	int				tikra_discount	= 0;
	int				subsidy_amount	= 0;

	// Variables for deletion/refund of previous sales.
	int				v_DeletedPrID;
	int				v_DeletedPrDate;
	int				v_DeletedPrPharm;
	int				v_DeletedPrSubAmt;
	short			v_DeletedPrYYMM;
	int				v_DeletedPrPhID;
	short			v_DeletedPrDelFlg;
	short			v_DeletedPrTkMazon;
	short			v_DeletedPrPrcCode;
	int				v_DeletedPrOP;
	int				v_DeletedPrUnits;
	int				v_DeletedPrPtn;
	int				v_DeletedPrIshNum;
	short			v_DeletedPrIshSrc;
	short			v_DeletedPrIshTik;
	short			v_DeletedPrIshTkTp;
	short			v_DeletedPrPrtMeth;
	short			v_DeletedPrBasket;
	short			v_DeletedPrCredit;
	int				v_DeletedPrMemPrc;
	int				v_DeletedPrSupPrc;
	int				v_DeletedPrDscPcnt;
	int				v_DeletedPrFixPrc;
	int				v_DeletedPrRuleNum;
	int				v_DeletedPrRxLargo;

	// Variables for Generic Drug Substitution.
	int				EP_LargoCode;

	// Variables for Purchase Limit checking.
	int				PL_IshurNum = 0;
	int				PL_Units;
	short			PL_Months;
	short			PL_Type;
	int				PL_OpenDate;
	int				PL_CloseDate;
	int				PL_CloseDate_Min;

	int				AlreadyBoughtToday;

	// Pharmacy Special Confirmation. (DonR 06Dec2022: I'm not sure how often pharmacies actually send these nowadays.)
	int				v_SpecialConfNum;
	short			v_SpecialConfSource;

	short			v_authorizealways;	/* from MEMBERS  *//*20001022*/

	// Pharmacy data.
	short			v_pharm_card		= 0;
	short			v_leumi_permission	= 0;
	short			v_CreditPharm		= 0;
	short			vat_exempt			= 0;

	// Maccabi Centers
	short			v_MacCent_cred_flg	= 0;

	// Individual Drugs prescribed
	TPresDrugs		*PrsLinP;
	int				v_DrugCode;
	int				v_Units;
	short			v_ArrayErrCode;		// DonR 11Apr2013 - to write to prescription_msgs.
	short			v_ArraySeverity;	// DonR 06Jun2013 - added new field to prescription_msgs.
	short			v_ArrayLineNo;		// DonR 10Jun2013 - added new field to prescription_msgs.
	short			ReqIncludesTreatment	= 0;
	short			digital_presc_flag;

	// Return message header fields.
	int				v_FamilyHeadTZ;
	short			v_FamilyHeadTZCode;
	int				v_FamilyCreditUsed;
	int				v_CreditToBeUsed;
	int				v_CreditThisDrug;
	TSqlInd			v_FamilyCreditInd;
	int				v_FirstOfMonth;
	int				v_RecipeIdentifier;
	char			v_MemberFamilyName	[14 + 1];
	char			v_MemberFirstName	[ 8 + 1];
	short			v_MemberGender;
	short			ExternalRx_origin;
	char			v_DoctorFamilyName	[14 + 1];
	char			v_DoctorFirstName	[ 8 + 1];
	TDoctorInfo		Doctors [99];
	short			NumDoctors	= 0;
	short			v_ErrorCode;
	short			v_MemberDiscPercent;
	short			v_CreditYesNo;
	short			v_insurance_status; 
	short			v_MemberSpecPresc;
	int				v_MaxLargoVisible;

	// Member fields that aren't used in this transaction - added so we can
	// use a common read-member ODBC operation.
	int				MemberZipCode;
	char			MemberDefaultPhone		[10 + 1];
	char			MemberStreet			[12 + 1];
	char			MemberHouseNum			[ 4 + 1];
	char			MemberCity				[20 + 1];


	// Drug lines
	short			PW_SubstPermitted;
	int				PW_Pr_Date;
	int				PW_Doc_Largo_Code;
	int				PW_DoctorPrID;
	int				UnitsToSell;
	int				OPToSell;
	int				PtnBeforeDiscount;

	// Gadgets table.
	int				v_service_code;
	int				v_gadget_code;
	int				GadgetCodeFound;
	short			v_service_number;
	short			v_service_type;
	short			v_enabled_status;
	short			v_enabled_mac;
	short			v_enabled_hova;
	short			v_enabled_keva;
	short			enabled_pvt_pharm;
	short			enabled_without_rx;
	short			prescription_sale;
	short			GadgetPrevPurchaseClassCode;
	short			GadgetMinPrevPurchases;
	short			GadgetMaxPrevPurchases;

	// MemberPharm table - member/pharmacy purchase restrictions
	short			v_MemPharm_Exists;
	int				v_MemPharm_PhCode;
	short			v_MemPharm_PhType;
	int				v_MemPharm_FromDt;
	int				v_MemPharm_ToDt;
	int				v_MemPharm_PhCode2;
	short			v_MemPharm_PhType2;
	int				v_MemPharm_FromDt2;
	int				v_MemPharm_ToDt2;
	short			v_MemPharm_ResType;
	short			v_MemPharm_PermittedOwner;
	short			MemPharm_Result;

	// General SQL variables.
	char			PossibleInsuranceType[2];
	short			macabi_code;
	int				max_drug_date;
	int				illness_bitmap;
	int				SysDate;
	int				SysDate_copy;	// DonR 18Jun2020: Probably won't make any difference - just seeing if ODBC has problems with repeated input parameters.
	int				SysTime;
	int				StopUseDate;
	int				StopBloodDate;
	int				MaxRefillDate;
	int				ShortOverlapDate;	// DonR 19Apr2010 for new early-refill warning.
	int				LongOverlapDate;	// DonR 19Apr2010 for new early-refill warning.
	int				Yarpa_Price;
	int				Macabi_Price;
	int				Supplier_Price;	// 21NOV2002 Fee Per Service enh.
	short			v_PriceListCode;
	short			LineNum;
	int		      	v_TempMembIdentification;
	short			v_TempIdentifCode;
	int				v_TempMemValidUntil;
	short			RetPartCode;
	int				EarliestPrescrDate;
	int				LatestPrescrDate;
	int				EarliestPurchaseDate;
	int				LatestPurchaseDate;
	int				RowsFound;
	int				high_rules_found;
	int				low_rules_found;
	int				v_prw_id;
	int				MatchingDiagnosis;
	short			SomeRuleApplies			= 0;	// DonR 22Mar2011
	short			HeaderPrescSource		= 0;	// DonR 10Jun2015
	short			expiry_status;					// DonR 20Aug2018 CR #15260

	short			DRX_SoldOP				= 0;
	short			DRX_SoldUnits			= 0;
	short			DRX_Rx_OP				= 0;
	short			DRX_Rx_TotUnits			= 0;
	short			DRX_QtyMethod			= 0;
	short			UnitsPrescribed			= 0;
	short			UnitsAlreadySold		= 0;
	short			UnitsSellable			= 0;
	short			UnitsSoldNow			= 0;
	double			IngredSellable			= 0.0;
	double			IngredSoldNow			= 0.0;
	char			InsuranceTypeToCheck	[1 + 1];
	int				OneYearAgo;			// DonR 29Jun2020 CR #29682. DonR 06Sep2020 changed from 6 months to 1 year.
	int				LastSubLargo;		// DonR 29Jun2020 CR #29682.
	short			LastSubShapeCode;	// DonR 29Jun2020 CR #29682.

	bool			IsCannabisSale 			= false;	// Marianna 11Feb2024 User Story #540234
	bool			CannabisForce100Percent;
	int				MaxCannabisDate;

	// Body of function
 
	// Initialize variables.
	REMEMBER_ISOLATION;
	PosInBuff				= IBuffer;
	v_ErrorCode				= NO_ERROR;
	SysDate					= GetDate ();
	SysTime					= GetTime ();
	v_MsgExistsFlg			= 0;
	v_MsgIsUrgentFlg		= 0;
	v_NumOfDrugLinesRecs	= 0;
	EarliestPrescrDate		= AddDays (SysDate, (0 - PRESCR_VALID_DAYS));
	LatestPrescrDate		= AddDays (SysDate, SELECT_PRESC_EARLY_DAYS);
	MaxFutureDate			= AddDays (SysDate, SaleOK_EarlyDays);	// DonR 21Aug2023: Move to a single early-sale tolerance variable rather than two of them.
	v_DrugsBuf.max			= 0;	// DonR 16Feb2006: Initialize global buffer.
	FamilySize				= 0;
	tikra_discount			= 0;
	subsidy_amount			= 0;

	// Force zero values; these fields are still written to the prescriptions table, at
	// least for now.
	v_TypeDocID				= 0;
	DocID					= 0;

	// Set "new style" error handling so (A) errors are stored in an array, and (B) drug-specific
	// errors do not stop processing for a given drug (and thus multiple errors can be reported
	// for each drug).
	SetErrorVarEnableArr ();

	// Vacation ishurim should be ignored for the last five days - so the member
	// can buy more drugs when s/he gets back from his/her trip.
	PL_CloseDate_Min = AddDays (SysDate, 5);

	// Marianna 22Feb2024 User Story #540234
	MaxCannabisDate = (AddDays(SysDate, CannabisSaleEarlyDays));

	// Initialize all elements of Prescription Data arrays.
	memset ((char *)SPres,		0, sizeof(SPres));
	memset ((char *)DocRx,		0, sizeof(DocRx));
	memset ((char *)Doctors,	0, sizeof(Doctors));


	// Read message fields data into variables.
	v_PharmNum					= GetInt	(&PosInBuff,  7					); CHECK_ERROR ();	//  1:  10,  7
	v_InstituteCode				= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	//  2:  17,  2
	v_TerminalNum				= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	//  3:  19,  2
	v_ActionType				= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	//  4:  21,  2
	v_DeletedPrID				= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	//  5:  23,  9
	v_DeletedPrPharm			= GetInt	(&PosInBuff,  7					); CHECK_ERROR ();	//  6:  32,  7
	v_DeletedPrYYMM				= GetShort	(&PosInBuff,  4					); CHECK_ERROR ();	//  7:  39,  4
	v_DeletedPrPhID				= GetInt	(&PosInBuff,  6					); CHECK_ERROR ();	//  8:  43,  6
	v_MemberIdentification		= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	//  9:  49,  9
	v_IdentificationCode		= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 10:  58,  1
	v_MemberBelongCode			= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 11:  59,  2
	v_MoveCard					= GetShort	(&PosInBuff,  4					); CHECK_ERROR ();	// 12:  61,  4
	VersionNumber				= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 13:  65,  2
	online_order_num			= GetLong	(&PosInBuff,  8					); CHECK_ERROR ();	// 14:  67,  8
	v_ClientLocationCode		= GetInt	(&PosInBuff,  7					); CHECK_ERROR ();	// 15:  75,  7
	v_SpecialConfSource			= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 16:  82,  1
	v_SpecialConfNum			= GetInt	(&PosInBuff,  8					); CHECK_ERROR ();	// 17:  83,  8
	ChemicalPrice				= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	// 18:  91,  9
	v_NumOfDrugLinesRecs		= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 19: 100,  2

	// Set identifying info for return message.
	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
	ssmd_data_ptr->member_id		= Member.ID			= v_MemberIdentification;
	ssmd_data_ptr->member_id_ext	= Member.ID_code	= v_IdentificationCode_s	= v_IdentificationCode;
	
	// Validate Number of Drugs sold.
	if ((v_NumOfDrugLinesRecs	<  1) && (v_ActionType != SALE_DELETION))
	{
		SET_ERROR (ERR_FILE_TOO_SHORT);
		RESTORE_ISOLATION;
		return (ERR_FILE_TOO_SHORT);
	}

	if (v_NumOfDrugLinesRecs > 99)
	{
		SET_ERROR (ERR_FILE_TOO_LONG);
		RESTORE_ISOLATION;
		return (ERR_FILE_TOO_LONG);
	}

	// Get repeating portion of message.
	// DonR 19Aug2010: If this is a sale deletion with 99/999 as the number of drug lines, we don't want
	// to read drug-line data from the incoming message; it's a request for full cancellation of the
	// sale without specifying what drugs were sold (perhaps because the pharmacy doesn't know).
	if ((v_ActionType != SALE_DELETION) || (v_NumOfDrugLinesRecs != 99))
	{
		for (i = 0; i < v_NumOfDrugLinesRecs; i++)	// Each line is 121 characters long.
		{
			/* line number = */			  GetShort	(&PosInBuff,  2			); CHECK_ERROR ();	// 20: 102,  2	Line Number - ignored.
			Delete_LineNumber		[i]	= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	// 21: 104,  3

			// DonR 02Mar2016: For now, Largo Codes are only five digits even though the message space for them
			// has expanded. Since six-digit Largo Codes blow up transmission of tables to AS/400 (and we've seen
			// this happen only for Doctor Largo Code), catch this problem right at the outset and reject the
			// transaction.
			// DonR 15Jul2024 User Story #349368: Largo Codes are being expanded to 6 digits on AS/400.
			// Accordingly, adjust the "sanity check" to allow one more digit.
			PR_Original_Largo_Code	[i]	= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	// 22: 107,  9
			if (PR_Original_Largo_Code [i] > 999999)
				SET_ERROR (ERR_WRONG_FORMAT_FILE);

			PR_WhyNonPreferredSold	[i]	= GetShort	(&PosInBuff,  2			); CHECK_ERROR ();	// 23: 116,  2
			SPres[i].DrugCode			= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	// 24: 118,  9	Drug actually dispensed.
			SPres[i].Units				= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	// 25: 127,  5	Units to be sold.
			SPres[i].Op					= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	// 26: 132,  5	OP to be sold.
			SPres[i].Duration			= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	// 27: 137,  3

			// Note that course_treat_days and course_len were previously derived fields;
			// routines that use them will need to be altered to use the reported values
			// when they are present.
			SPres[i].course_treat_days	= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	// 28: 140,  3
			SPres[i].course_len_days	= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	// 29: 143,  3

			SPres[i].LinkDrugToAddition	= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	// 30: 146,  9

			// Transaction 6003 has doctor stuff as part of the drug line; it also can include
			// multiple doctor prescriptions (from the same visit or from different visits) in a single drug line.
			SPres[i].DocIDType			= GetShort	(&PosInBuff,  1			); CHECK_ERROR ();	// 31: 155,  1
			SPres[i].DocID				= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	// 32: 156,  9
			SPres[i].PrescSource		= GetShort	(&PosInBuff,  2			); CHECK_ERROR ();	// 33: 165,  2
			SPres[i].DocFacility		= GetInt	(&PosInBuff,  7			); CHECK_ERROR ();	// 34: 167,  7

			// DonR 15Aug2018 CR #15804 / CR #15808
			if (VersionNumber > 1)
			{
				SPres[i].IsConsignment		= GetShort	(&PosInBuff,  1		); CHECK_ERROR ();	// 35: 174,  1 - DonR 16Apr2023 User Story #432608
				SPres[i].ph_OTC_unit_price	= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 36: 175,  9 - DonR 16Apr2023 User Story #432608
				SPres[i].BarcodeScanned		= GetShort	(&PosInBuff,  1		); CHECK_ERROR ();	// 37: 184,  1

				SPres[i].VisitNumber		= 0L;	// This will be overwritten by the first doctor prescription in the list - see below.

				// DonR 08Apr2024 User Story #540234: For Cannabis sales, the pharmacy sends us the *total*
				// member participation for this (aggregate) Largo Code in ph_OTC_unit_price. Save it to a
				// separate, new variable so we don't lose agorot dividing the number into multiple OP and
				// multiplying it back to the full quantity.
				SPres[i].CannabisParticipation = SPres[i].ph_OTC_unit_price;

				// DonR 11Dec2018: Pharmacies send the total price rather than the unit price - so if OP > 1,
				// we have to convert ph_OTC_unit_price to the actual per-unit price. (Note that if this is
				// a deletion and pharmacy has sent negative OP < -1, we do the same adjustment.)
				if ((SPres[i].Op > 1) || (SPres[i].Op < -1))
				{
					SPres[i].ph_OTC_unit_price /= SPres[i].Op;
				}

			}
			else
			{
				SPres[i].VisitNumber		= GetLong	(&PosInBuff, 11			); CHECK_ERROR ();	// (35: 174, 11)

				SPres[i].ph_OTC_unit_price	= 0;
				SPres[i].BarcodeScanned		= 0;
			}

			SPres[i].IsDigital			= GetShort	(&PosInBuff,  1			); CHECK_ERROR ();	// 38: 185,  1
			SPres[i].NumDocRxes			= GetShort	(&PosInBuff,  2			); CHECK_ERROR ();	// 39: 186,  2

			// Set starting point for this drug-line in the Doctor Prescription array. If there are
			// no correstponding prescriptions, set the starting point to zero (a blank array element).
			SPres[i].FirstRx = (SPres[i].NumDocRxes > 0) ? MaxRx : 0;

			// Read in the specific prescriptions that are combined in this drug-line.
			// NOTE: Length of one prescription is 223 - 188 = 35 bytes. So the second
			// prescription starts with its Visit Number at 223, 11.
			for (Rx = 0; Rx < SPres[i].NumDocRxes; Rx++)
			{
				if (VersionNumber > 0)
				{
					DocRx [MaxRx].VisitNumber	= GetLong	(&PosInBuff, 11		); CHECK_ERROR ();	// 40: 188, 11

					// DonR 27Mar2017: If necessary, copy first Visit Number to the parent SPres structure.
					// DonR 18Jun2018: The "parent" drug-line Visit Number field is going to be used for
					// other purposes, so we can remove the "SPres[i].VisitNumber == 0" condition.
//					if ((Rx == 0) && (SPres[i].VisitNumber == 0))
					if (Rx == 0)
						SPres[i].VisitNumber = DocRx [MaxRx].VisitNumber;
				}

				DocRx [MaxRx].PrID				= GetInt	(&PosInBuff,  6		); CHECK_ERROR ();	// 41: 199,  6
				DocRx [MaxRx].FromDate			= GetInt	(&PosInBuff,  8		); CHECK_ERROR ();	// 42: 205,  8
				DocRx [MaxRx].Units				= GetInt	(&PosInBuff,  5		); CHECK_ERROR ();	// 43: 213,  5
				DocRx [MaxRx].OP				= GetInt	(&PosInBuff,  5		); CHECK_ERROR ();	// 44: 218,  5

				SPres[i].Doctor_Op		+= DocRx [MaxRx].OP;	// Overdose routine gets the sum of all doctor prescriptions
				SPres[i].Doctor_Units	+= DocRx [MaxRx].Units;	// lumped together in this drug line - although, at least
																// for now, O/D is checked just based on what's being sold.

				// Keep track of the maximum doctor prescription date for this drug line
				// (for future-date validation).
				if (DocRx [MaxRx].FromDate > SPres [i].MaxPrDate)
					SPres [i].MaxPrDate = DocRx [MaxRx].FromDate;

				// DonR 20Nov2016: Copy the Doctor ID to the DocRX structure to simplify previous-partial-sale
				// lookup logic.
				// DonR 22Sep2019: Also copy the Original Largo Code. (Really, I should add that to the SPres structure...)
				DocRx [MaxRx].DocID				= SPres[i].DocID;
				DocRx [MaxRx].LargoPrescribed	= PR_Original_Largo_Code [i];

				// DonR 22Sep2019: Copy MaxRx to the otherwise-unused first element of the prescriptions array.
				// Note that I moved the "++" so MaxRx will be incremented *before* I copy it! The stored value
				// will thus be one *more* than the maximum subscript used.
				DocRx [0].OP = ++MaxRx;
			}	// Doctor-prescription reading loop.
		}	// Drug-line loop.
	}	// NOT a delete-entire-sale request.

	// Get amount of input not eaten.
	ChckInputLen (TotalInputLen - (PosInBuff - IBuffer));
	CHECK_ERROR ();


	// SQL Transaction Retry Loop.
	reStart = MAC_TRUE;

	for (tries = 0; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		// Initialize answer variables.
		v_ErrorCode					= NO_ERROR;
		reStart						= MAC_FALS;
		v_RecipeIdentifier			= 0;
		v_MemberGender				= 0;
		v_MemberDiscPercent			= 0;
		MemberBuyingTikMazon		= 0;
		MemberBuyingLH_FSH			= 0;
		CheckMonthlyPiryonTikra		= 0;
		ThisIshurHasTikra			= 0;
		AnIshurHasTikra				= 0;
		v_CreditYesNo				= 0;
		v_PriceListCode 			= 0;
		TypeCheckSpecPr				= 0;
		NumDoctors					= 0;
		ReqIncludesTreatment		= 0;
		v_MemberFamilyName	[0]		= 0;
		v_MemberFirstName	[0]		= 0;
		v_DoctorFamilyName	[0]		= 0;
		v_DoctorFirstName	[0]		= 0;
		SysDate						= GetDate ();
		strcpy (first_center_type,	"02");	// Default for Maccabi Center Type.
		FirstCenterTypeNum			= 2;	// Default for Maccabi Center Type.

		// Marianna 17Mar2024 User Story #540234 - changed place of IS_PHARMACY_OPEN() and set of v_MaxLargoVisible
		// Read pharmacy and set various pharmacy-related flags.
		PharmacyOpenErr = IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);

		// DonR 19Feb2008: Drugs with Largo Code >= 90000 are visible only
		// to Maccabi pharmacies.
		// DonR 20Apr2023 User Story #432608: "Consignatzia" pharmacies can also see Largo Codes >= 90000.
		v_MaxLargoVisible = (MACCABI_PHARMACY || CONSIGNMENT_PHARMACY) ? NO_MAX_LARGO : 89999;

		// DonR 25Mar2024 BUG FIX: We're now reading drug_list *before* we read the Members table; this
		// creates a problem, since various flags for the member have not been set yet, and all still have
		// their default values of zero at this point. The important one here is MemberMaccabi; having a
		// value of zero for this flag disables all non-100% member-price-code values from drug_list (see
		// the read_drug() function). In reality, this flag is always going to be 1 since we are no longer
		// dealing with IDF members (maccabi_code = 33 or 34). (See the function SetMemberFlags() for more
		// information about these flags.) One way to fix the problem would be to do yet another code reshuffle
		// and move the member-reading code up here; but it's far simpler just to set MemberMaccabi TRUE as a
		// default. If we ever revive the "Tzahal" feature, we'll have to do something more elaborate since we
		// will actually have people in the Members table whose MemberMaccabi flag is supposed to be FALSE; but
		// it's been quite a few years since the feature has been used and there's no sign of its being revived.
		Member.MemberMaccabi = 1;

		// Initialize drug-level arrays, including those relating to Pharmacy Ishur.
		// DonR 28Mar2011: Moved this loop to execute unconditionally before the deletion section,
		// because otherwise DrugTikraType wasn't getting initialized and we got frequent database
		// errors (-391) trying to write to prescription_drugs as the column is set to NOT NULL.
		for (i = 0; i < v_NumOfDrugLinesRecs; i++)
		{
			SPres[i].DL.package_size				= 1;	// Set default to avoid division by zero.
			PR_AsIf_Preferred_Largo	[i]				= 0;
			PR_AsIf_Preferred_SpDrug[i]				= 0;
			PR_AsIf_Preferred_Basket[i]				= 0;
			PR_AsIf_ParentGroupCode	[i]				= 0;
			PR_AsIf_RuleStatus		[i]				= 0;
			preferred_mbr_prc_code	[i]				= 0;
			MajorDrugIndex			[i]				= -1;	// Default - no major drug found.
															// (Zero is a valid index value.)
			gadget_svc_number		[i]				= 0;
			gadget_svc_type			[i]				= 0;
			gadget_svc_code			[i]				= 0;
			DrugTikraType			[i]				= ' ';
			DrugCoupon				[i]				= '0';
			DrugRefundOffset		[i]				= 0;
			PR_ExtendAS400IshurDays	[i]				= 0;
			PharmIshurProfession	[i]				= 0;
			MemberPtnAmount			[i]				= 0;
			SPres[i].ret_part_source.insurance_used	= BASIC_INS_USED;
			SPres[i].DocChkInteractions				= 1;	// Interactions are checked *unless* a specific doctor has been flagged.

			// DonR 10Jun2015: Set up header-level Prescription Source variable. If the drug lines all
			// have the same Prescription Source, we'll just replicate that in the header (prescriptions/
			// RK9021P); otherwise, we'll write a generic "mixed prescription sources" value of 99.
			// The ternary operator below works as follows: the first time we see a non-zero Prescription
			// Source, we set HeaderPrescSource equal to that value. After that, if we see any *other*
			// non-zero Prescription Source, we'll assign the value 99.
			if ((SPres[i].PrescSource != HeaderPrescSource) && (SPres[i].PrescSource > 0))
				HeaderPrescSource = (HeaderPrescSource) ? RECIP_SRC_MIXED_SOURCES : SPres[i].PrescSource;

			// Marianna 17Mar2024 User Story #540234 - changed place of read_drug()
			// DonR 08Apr2018: Added new parameter to read_drug() to indicate whether logically deleted drugs
			// can be "seen". This needs to be TRUE for sale deletions, since we need to be able to delete a
			// prior sale even if the drug in question has been logically deleted in the interim.
			if	(!read_drug (	SPres[i].DrugCode,	v_MaxLargoVisible,	&Phrm_info,
								(v_ActionType == SALE_DELETION),	// Deleted drugs are "visible" if we're deleting prior sales.
								NULL,				&SPres[i]
							)	)
			{
				Conflict_Test (reStart);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					// DonR 27Feb2008: Provide some defaults when drug isn't read.
					// DonR 11Jul2011: Although it shouldn't make any difference, moved the defaults outside
					// the "if drug-not-found is a fatal error" block - just in case someone decides to make
					// it a non-fatal error.
					SPres[i].BasePartCode		= 1;
					SPres[i].RetPartCode		= 1;
					SPres[i].part_for_discount	= 1;
					SPres[i].in_health_pack		= 0;

					if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DRUG_CODE_NOT_FOUND, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						continue;
					}
				}	// Drug not found.
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						break;
					}
				}
			}	// read_drug() returned zero (i.e. something went wrong).

			// If we get here, we have successfully read the drug_list row.

		}	// First drug loop.

		// Marianna User Story #540234 Set flags for cannabis sales.
		IsCannabisSale = (SPres[0].DL.drug_type == 'K'); // Marianna: If the *first* drug is cannabis, set the flag TRUE.
		CannabisForce100Percent = ((IsCannabisSale) && (!CannabisAllowDiscounts));

		// Test temporary Maccabi cards.
		// DonR 29Sep2013: Moved this code up here, since if the current transaction is a
		// deletion request, we need to know the member's real T.Z. Number *before* checking
		// the original sale.
		if (v_IdentificationCode == 7)
		{
			SET_ISOLATION_DIRTY;

			ExecSQL (	MAIN_DB, READ_tempmemb,
						&v_TempIdentifCode,			&v_TempMembIdentification,	&v_TempMemValidUntil,
						&v_MemberIdentification,	END_OF_ARG_LIST										);

			Conflict_Test (reStart);

			if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
			{
				SetErrorVarArr (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG, 0, 0, &err, &ErrOverflow);
			}	// Temporary card data not found in tempmemb.

			else	// Either a good read or a serious DB error.
			{
				if (SQLERR_error_test ())
				{
					SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, &err, &ErrOverflow);
				}

				// DonR 20Feb2005: Added "else" so we use the values from
				// tempmemb only if row was actually read from the database.
				// DonR 20Oct2013: If the current action is a sale deletion, an expired
				// temporary card is still usable.
				else
				{
					// If we get here, we managed to read the temporary card.
					// DonR 05Apr2017 CR #11541: Assign the member ID/Code even if the temporary
					// card has expired - but force a "card expired" error.
					v_IdentificationCode	= v_TempIdentifCode;
					v_MemberIdentification	= v_TempMembIdentification;
					ForceCardExpiredErr		= ((v_TempMemValidUntil < SysDate) && (v_ActionType != SALE_DELETION));
				}	// Successful read of tempmemb.
			}	// Something other than not-found reading tempmemb.
		}	// Temporary Member test.


		// If this is a deletion, find the sale to be deleted; otherwise make sure
		// Deleted Pr. ID is zero.
		// DonR 05Sep2010: If the sale to be deleted isn't found, force v_NumOfDrugLinesRecs to zero; this
		// will prevent bogus drug-line information from being returned to the pharmacy.
		if (v_ActionType == SALE_DELETION)
		{
			gettimeofday (&EventTime[EVENT_DELETE_START], 0);	// For performance tuning.

			do	// Dummy loop for deletion-handling stuff.
			{
				SET_ISOLATION_DIRTY;

				DeletionValid = 1;	// Assume everything's OK until proven otherwise. 

				// If pharmacy didn't supply a Presciption ID to delete, try to identify the original
				// sale from the other parameters supplied.
				// DonR 30Jun2016: Added del_flg to WHERE clause, since there may be duplicate rows when
				// sales have arrived via spool.
				if (v_DeletedPrID == 0)
				{
					ExecSQL (	MAIN_DB, READ_Find_Prescription_ID_to_delete,
								&v_DeletedPrID,
								&v_MemberIdentification,	&v_DeletedPrPharm,
								&v_DeletedPrYYMM,			&v_DeletedPrPhID,
								&DRUG_DELIVERED,			&v_IdentificationCode,
								&v_MemberBelongCode,		END_OF_ARG_LIST				);
// GerrLogMini (GerrId, "6003 deletion: Pharmacy didn't supply sale Pr ID; found %d, SQLCODE %d.", v_DeletedPrID, SQLCODE);

					Conflict_Test (reStart);

					if ((SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE) || (v_DeletedPrID < 1) || (v_DeletedPrID > 999999999))
					{
						v_DeletedPrID = 0;	// To get rid of NULL value.
						SetErrorVarArr (&v_ErrorCode, ERR_PRESCRIPTION_ID_NOT_FOUND, 0, 0, NULL, &ErrOverflow);
						DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
						v_NumOfDrugLinesRecs = 0; // So we don't return bogus drug-line stuff to pharmacy.
						break;
					}

					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
						v_NumOfDrugLinesRecs = 0; // So we don't return bogus drug-line stuff to pharmacy.
						break;
					}

					// If we get here, a prior sale was found - although it may have already been deleted.
				}	// Pharmacy did not supply original Prescription ID.


				// Read in some relevant fields from the prescriptions row to be deleted.
				ExecSQL (	MAIN_DB, READ_Get_X003_deleted_prescription_row_values,
							&v_DeletedPrDate,		&v_DeletedPrSubAmt,
							&v_DeletedPrCredit,		&v_DeletedPrDelFlg,
							&v_DeletedPrID,			&DRUG_DELIVERED,
							END_OF_ARG_LIST												);
// GerrLogMini (GerrId, "6003 deletion: read sale date %d for Pr ID %d, SQLCODE = %d.", v_DeletedPrDate, v_DeletedPrID, SQLCODE);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					SetErrorVarArr (&v_ErrorCode, ERR_PRESCRIPTION_ID_NOT_FOUND, 0, 0, NULL, &ErrOverflow);
					v_NumOfDrugLinesRecs = 0; // So we don't return bogus drug-line stuff to pharmacy.
					DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
					break;
				}
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
						v_NumOfDrugLinesRecs = 0; // So we don't return bogus drug-line stuff to pharmacy.
						break;
					}
					else
					{
						// Successful read - but if this sale has already been deleted, throw an error.
						if (v_DeletedPrDelFlg == ROW_DELETED)
						{
							SetErrorVarArr (&v_ErrorCode, ERR_PRESC_ALREADY_DELETED, 0, 0, NULL, &ErrOverflow);
							DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
							v_NumOfDrugLinesRecs = 0; // So we don't return bogus drug-line stuff to pharmacy.
							break;
						}
					}
				}	// Something other than not-found.

				// If we get here, we successfully read the prescriptions row to be deleted.


				// If pharmacy supplied a list of drugs to delete, read participation data from the
				// original drug sale. If quantity is different from the original sale, throw an error.
				if ((v_NumOfDrugLinesRecs > 0) && (v_NumOfDrugLinesRecs < 99))
				{
					for (i = 0; i < v_NumOfDrugLinesRecs; i++)
					{
						v_DrugCode = SPres[i].DrugCode;

						ExecSQL (	MAIN_DB, TR6003_READ_Get_deleted_prescription_drugs_row_values,
									&v_DeletedPrOP,			&v_DeletedPrUnits,		&v_DeletedPrPtn,
									&v_DeletedPrTkMazon,	&v_DeletedPrPrcCode,	&v_DeletedPrDelFlg,
									&v_DeletedPrPrtMeth,	&v_DeletedPrIshNum,		&v_DeletedPrIshSrc,

									&v_DeletedPrIshTik,		&v_DeletedPrIshTkTp,	&v_DeletedPrMemPrc,
									&v_DeletedPrSupPrc,		&v_DeletedPrDscPcnt,	&v_DeletedPrFixPrc,
									&v_DeletedPrRuleNum,	&v_DeletedPrBasket,		&v_DeletedPrRxLargo,

									&v_DeletedPrID,			&DRUG_DELIVERED,		&v_DrugCode,
									END_OF_ARG_LIST															);
// GerrLogMini (GerrId, "6003 deletion with largo list: Largo %d ptn method %d, SQLCODE = %d.", v_DrugCode, v_DeletedPrPrtMeth, SQLCODE);

						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							SetErrorVarArr (&SPres[i].DrugAnswerCode,	ERR_DRUG_NOT_IN_ORIG_SALE,		v_DrugCode,	i + 1,	NULL, &ErrOverflow);
							SetErrorVarArr (&v_ErrorCode,				ERR_CANT_DEL_PRESC_OR_DRUGS,	0,			0,		NULL, &ErrOverflow);
							SPres[i].DFatalErr = MAC_TRUE;
							DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
							break;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
								break;
							}
							else
							{
								// Successful read - but if this drug has already been deleted, throw an error.
								// Question: Should this drug be removed from the current deletion request?
								if (v_DeletedPrDelFlg == ROW_DELETED)
								{
									SetErrorVarArr (&SPres[i].DrugAnswerCode,	ERR_DRUG_ALREADY_DELETED,		v_DrugCode,	i + 1,	NULL, &ErrOverflow);
									SetErrorVarArr (&v_ErrorCode,				ERR_CANT_DEL_PRESC_OR_DRUGS,	0,			0,		NULL, &ErrOverflow);
									DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
									SPres[i].DFatalErr = MAC_TRUE;
								}

								// Compare quantities in deletion request with original sale; if there is
								// a discrepancy, throw an error.
								// DonR 30Jun2010: Pharmacy is supposed to send us negative units and OP -
								// so if they don't, it's an error.
								// DonR 05Jul2010: Pharmacy will send positive OP and Units; we will "flip"
								// them negative in a millisecond or so.
								if ((SPres[i].Op	!= v_DeletedPrOP)		||
									(SPres[i].Units	!= v_DeletedPrUnits))
								{
									SetErrorVarArr (&SPres[i].DrugAnswerCode,	ERR_QTY_DIFFERENT_IN_ORIG_SALE,	v_DrugCode,	i + 1,	NULL, &ErrOverflow);
									SetErrorVarArr (&v_ErrorCode,				ERR_CANT_DEL_PRESC_OR_DRUGS,	0,			0,		NULL, &ErrOverflow);
									DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
									SPres[i].DFatalErr = MAC_TRUE;
								}

								// Copy original-sale values into arrays.
								// DonR 28Jun2010: Deletion participation is negative.
								// DonR 05Jul2010: According to Iris Shaya, pharmacy will send positive numbers
								// for OP and Units, and we will "flip" them until just before we send the
								// response back to the pharmacy; at that point we will "flip" them back. Yuck.
								SPres[i].DL.tikrat_mazon_flag	= v_DeletedPrTkMazon;
								SPres[i].RetPartCode			= v_DeletedPrPrcCode;
								SPres[i].SpecPrescNum			= v_DeletedPrIshNum;
								SPres[i].SpecPrescNumSource		= v_DeletedPrIshSrc;
								SPres[i].IshurWithTikra			= v_DeletedPrIshTik;
								SPres[i].IshurTikraType			= v_DeletedPrIshTkTp;
								SPres[i].InsPlusPtnSource		= v_DeletedPrPrtMeth;
								SPres[i].in_health_pack			= v_DeletedPrBasket;	// DonR 11Jul2010
								SPres[i].RetOpDrugPrice			= v_DeletedPrMemPrc;	// DonR 20Jul2010
								SPres[i].SupplierDrugPrice		= v_DeletedPrSupPrc;	// DonR 20Jul2010
								SPres[i].AdditionToPrice		= v_DeletedPrDscPcnt;	// DonR 20Jul2010
								SPres[i].PriceSwap				= v_DeletedPrFixPrc;	// DonR 20Jul2010
								SPres[i].rule_number			= v_DeletedPrRuleNum;	// DonR 20Jul2010
								SPres[i].Op						= 0 - v_DeletedPrOP;	// DonR 05Jul2010
								SPres[i].Units					= 0 - v_DeletedPrUnits;	// DonR 05Jul2010
								MemberPtnAmount	[i]				= 0 - v_DeletedPrPtn;	// DonR 28Jun2010
								PR_Original_Largo_Code [i]		= v_DeletedPrRxLargo;	// DonR 16Jul2015

								// Participation method needs to be "deconstructed".
								SPres[i].ret_part_source.insurance_used	= (v_DeletedPrPrtMeth % 100) / 10;
								SPres[i].ret_part_source.table			= (v_DeletedPrPrtMeth %  10);
							}	// Successful read.
						}	// Something other than not-found.
					}	// Loop through drugs sent by pharmacy.
				}	// Pharmacy has sent a list of drugs to delete.

				else
				{
					// If pharmacy did not supply a list of drugs to delete, read in all the drugs from
					// the original sale. Note that if pharmacy sends zero for the number of drugs to
					// delete, we do NOT automatically delete the whole prior sale - instead, we just
					// throw an error.
					if (v_NumOfDrugLinesRecs == 99)	// Pharmacy has requested full deletion of prior sale.
					{
						v_NumOfDrugLinesRecs = 0;	// Re-initialize number of drugs.

						// Do we need to copy additional fields from original sale?
						// DonR 10Apr2011: Declare cursor only if it's needed.
						DeclareAndOpenCursorInto (	MAIN_DB, TR6003_deldrugs_cur,
													&v_DrugCode,			&v_DeletedPrOP,			&v_DeletedPrUnits,
													&v_DeletedPrPtn,		&v_DeletedPrTkMazon,	&v_DeletedPrPrcCode,
													&v_DeletedPrPrtMeth,	&v_DeletedPrIshNum,		&v_DeletedPrIshSrc,

													&v_DeletedPrIshTik,		&v_DeletedPrIshTkTp,	&v_DeletedPrMemPrc,
													&v_DeletedPrSupPrc,		&v_DeletedPrDscPcnt,	&v_DeletedPrFixPrc,
													&v_DeletedPrRuleNum,	&v_DeletedPrBasket,		&v_DeletedPrRxLargo,

													&v_DeletedPrID,			&DRUG_DELIVERED,		&ROW_NOT_DELETED,
													END_OF_ARG_LIST															);

						if (SQLERR_error_test ())
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
							DeletionValid	= 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
							break;
						}

						do
						{
							FetchCursor (	MAIN_DB, TR6003_deldrugs_cur	);

							Conflict_Test (reStart);

							if (SQLCODE == 0)	// Good read.
							{
								// Copy original-sale values into arrays.
								// DonR 28Jun2010: Deletion participation is negative.
								// DonR 30Jun2010: So are OP and Units.
								SPres[v_NumOfDrugLinesRecs].DrugCode				= v_DrugCode;
								SPres[v_NumOfDrugLinesRecs].RetPartCode				= v_DeletedPrPrcCode;
								SPres[v_NumOfDrugLinesRecs].DL.tikrat_mazon_flag	= v_DeletedPrTkMazon;
								SPres[v_NumOfDrugLinesRecs].SpecPrescNum			= v_DeletedPrIshNum;
								SPres[v_NumOfDrugLinesRecs].SpecPrescNumSource		= v_DeletedPrIshSrc;
								SPres[v_NumOfDrugLinesRecs].IshurWithTikra			= v_DeletedPrIshTik;
								SPres[v_NumOfDrugLinesRecs].IshurTikraType			= v_DeletedPrIshTkTp;
								SPres[v_NumOfDrugLinesRecs].InsPlusPtnSource		= v_DeletedPrPrtMeth;
								SPres[v_NumOfDrugLinesRecs].in_health_pack			= v_DeletedPrBasket;	// DonR 11Jul2010
								SPres[v_NumOfDrugLinesRecs].RetOpDrugPrice			= v_DeletedPrMemPrc;	// DonR 20Jul2010
								SPres[v_NumOfDrugLinesRecs].SupplierDrugPrice		= v_DeletedPrSupPrc;	// DonR 20Jul2010
								SPres[v_NumOfDrugLinesRecs].AdditionToPrice			= v_DeletedPrDscPcnt;	// DonR 20Jul2010
								SPres[v_NumOfDrugLinesRecs].PriceSwap				= v_DeletedPrFixPrc;	// DonR 20Jul2010
								SPres[v_NumOfDrugLinesRecs].rule_number				= v_DeletedPrRuleNum;	// DonR 20Jul2010
								SPres[v_NumOfDrugLinesRecs].Op						= 0 - v_DeletedPrOP;	// DonR 30Jun2010
								SPres[v_NumOfDrugLinesRecs].Units					= 0 - v_DeletedPrUnits;	// DonR 30Jun2010
								MemberPtnAmount			[v_NumOfDrugLinesRecs]		= 0 - v_DeletedPrPtn;	// DonR 28Jun2010
								PR_Original_Largo_Code	[v_NumOfDrugLinesRecs]		= v_DeletedPrRxLargo;	// DonR 16Jul2015

								// Participation method needs to be "deconstructed".
								SPres[v_NumOfDrugLinesRecs].ret_part_source.insurance_used	= (v_DeletedPrPrtMeth % 100) / 10;
								SPres[v_NumOfDrugLinesRecs].ret_part_source.table			= (v_DeletedPrPrtMeth %  10);

								v_NumOfDrugLinesRecs++;
// GerrLogMini (GerrId, "6003 deletion without largo list: Largo %d ptn method %d, SQLCODE = %d.", v_DrugCode, v_DeletedPrPrtMeth, SQLCODE);
							}	// Good read of drug-lines cursor.
							else
							{
								if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
								{
									break;	// No problem - we're finished reading drugs from original sale.
								}
								else
								{
									if (SQLERR_error_test ())
									{
										SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
										DeletionValid	= 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
										break;
									}
								}	// Something other than end-of-fetch.
							}	// Fetch failed.
						}
						while (1);	// End of cursor loop for reading prior-sale drugs.

						CloseCursor (	MAIN_DB, TR6003_deldrugs_cur	);
					}	// Pharmacy sent "99" to request full deletion of prior sale.
				}	// Pharmacy did not send a list of drugs to delete.

				// Validate Number of Drugs deleted.
				if (v_NumOfDrugLinesRecs < 1)
				{
					// This should never really happen, since if all drugs were already deleted the
					// prescriptions row should already be flagged as deleted - and we would have
					// detected the problem almost 200 lines of code ago.
					SetErrorVarArr (&v_ErrorCode, ERR_PRESC_ALREADY_DELETED, 0, 0, NULL, &ErrOverflow);
					DeletionValid = 0;	// So we don't contact AS/400 for "Shaban" or "Nihul Tikrot". 
					break;
				}
			}
			while (0);	// End of deletion-handling dummy loop.

			gettimeofday (&EventTime[EVENT_DELETE_END], 0);
		}	// Current transaction is a deletion request.


		// Process normal sale requests.
		else
		{
			v_DeletedPrID = v_DeletedPrDate = v_DeletedPrSubAmt = 0;
			
			// Marianna 22Feb2024 User Story #540234: for Cannabis Sale not need to check the sale request
			// against the Pharmacy Ishur Number.
			if (!CannabisForce100Percent)
			{
				// If pharmacy supplied a Pharmacy Ishur Number, check the sale request
				// against the Ishur. Initialize the PR_ExtendAS400IshurDays array
				// first, since check_sale_against_pharm_ishur() stores values there.
				err = check_sale_against_pharm_ishur (	v_PharmNum,
														v_MemberIdentification,
														v_IdentificationCode,
														SPres,
														v_NumOfDrugLinesRecs,
														v_SpecialConfNum,
														v_SpecialConfSource,
														PR_ExtendAS400IshurDays,
														PharmIshurProfession,
														&FunctionError);

				SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);

				if (err == 2)	// DB conflict.
				{
					reStart = MAC_TRUE;
				}
			}	// Not a cannabis sale.

		}	// Normal sale request.


		// Get prescription id (for Prescriptions/Prescription Drugs tables).
		err = GET_PRESCRIPTION_ID (&v_RecipeIdentifier);

		if (err != NO_ERROR)
		{
		    SetErrorVarArr (&v_ErrorCode, err, 0, 0, NULL, &ErrOverflow);
		    GerrLogReturn (GerrId, "Can't get PRESCRIPTION_ID error %d", err);
			continue;	// We're not in a dummy do-while loop here!
		}


		// DonR 27Apr2005: Avoid unnecessary lock errors by downgrading "isolation"
		// for this section.
		SET_ISOLATION_DIRTY;

		// DUMMY LOOP #1 TO PREVENT goto.
		do	// Exiting from LOOP jumps to the drug-handling stuff.
		{
			// Test member belong code. Assume no error to begin.
		    err = MAC_FALS;

		    switch (v_MemberBelongCode)
			{
				case MACABI_INSTITUTE:
				    break;

				default:
					// DonR 05Jun2005: To support MaccabiCare feature, permit non-Maccabi
					// members to purchase non-prescription drugs.
					// WORKINGPOINT: Shouldn't this be RX_SOURCE_OTHER_THAN???
					if (RX_SOURCE_IN_REQUEST (RECIP_SRC_NO_PRESC))
					{
						SetErrorVarArr (&v_ErrorCode, ERR_WORNG_MEMBERSHIP_CODE, 0, 0, &err, &ErrOverflow);
					}
				    break;
			}
		    if (err == MAC_TRUE)
				break;


			// Test pharmacy data.
			// Marianna 17Mar2024 User Story #540234 - moved the call to IS_PHARMACY_OPEN up to near the beginning of the transaction.
			// DonR 08Sep2009: Copy pharmacy data already read by IS_PHARMACY_OPEN() into local variables.
		    v_PriceListCode		= Phrm_info.price_list_num;
			v_pharm_card		= Phrm_info.pharm_card;
			v_leumi_permission	= Phrm_info.leumi_permission;
			v_CreditPharm		= Phrm_info.CreditPharm;
			vat_exempt			= Phrm_info.vat_exempt;

			// DonR 31Jul2013: Move error test to after we've loaded pharmacy values, since we still do things
			// like price-list lookups based on them even if the pharmacy hasn't done an open-shift.
			if (PharmacyOpenErr != MAC_OK)
		    {
				SetErrorVarArr (&v_ErrorCode, err, 0, 0, NULL, &ErrOverflow);
				break;
			}
			
			// Test prescription source.
			// DonR 23Feb2008: Added new Prescription Source 11, for "Home Visit" prescriptions.
			// DonR 24Sep2009: Added new Prescription Source 13, for "Affiliated Clinic" prescriptions.
		    err = MAC_FALS;

			// Private pharmacies with MaccabiCare flag non-zero *can* sell non-prescription drugs - 
			// but other private pharmacies cannot.
			if (RX_SOURCE_IN_REQUEST (RECIP_SRC_NO_PRESC) && (PRIVATE_PHARMACY) && (!MACCABICARE_PHARM))
			{
				SetErrorVarArr (&v_ErrorCode, ERR_PHARM_CANT_SALE_PRECR_SRC, 0, 0, &err, &ErrOverflow);
			}

			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// Check for unrecognized prescription source(s).
				if (!is_valid_presc_source (SPres[i].PrescSource, PRIVATE_PHARMACY, &ErrorCodeToAssign, &SPres[i].PurchaseLimitSourceReject))
				{
					SetErrorVarArr (&v_ErrorCode, ErrorCodeToAssign, 0, 0, &err, &ErrOverflow);

					if (err)
						break;	// Once we've found a severe problem, no need to keep checking for bad presc. sources.
				}
			}	// Loop through drug lines to check for valid prescription sources.

			if (err == MAC_TRUE)
				break;	// Exit from Dummy Loop #1.


			// Read and test Member information.
			// DonR 05Jun2005: For MaccabiCare, allow T.Z. of zero for non-Maccabi members.
		    if ((v_MemberIdentification == 0) && (v_MemberBelongCode == MACABI_INSTITUTE))
			{
				SetErrorVarArr (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
				break;
			}

			// Test member ID-CODE.
			// DonR 05Jun2005: For MaccabiCare, allow T.Z. of zero for non-Maccabi members.
			// Since we test for zero above, here we need test only for T.Z.'s between
			// 1 and 57 - which are invalid for anyone, Maccabi member or not.
		    if ((v_MemberIdentification > 0) & (v_MemberIdentification < 58))
		    {
				SetErrorVarArr (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
				err = MAC_TRUE;
			}

			// DonR 30Jun2005: If Member ID = 0, plug in appropriate values for a
			// non-Maccabi member.
			// DonR 05Sep2006: Moved this code up, so that we avoid looking up
			// non-existent data in the Members table.
			if (v_MemberIdentification == 0)
			{
				strcpy (v_MemberFamilyName,	"");
				strcpy (v_MemberFirstName,	"");
				v_CreditYesNo		= 0;
				v_MemberSpecPresc	= 0;				// DonR 24Jul2011: Prevent a meaningless special_prescs lookup for ID zero.
				Member.maccabi_until = Member.mac_magen_until = Member.keren_mac_until = Member.yahalom_until = 0;
				Member.date_of_bearth = SysDate;			// For lack of a more sensible default.
				strcpy (Member.insurance_type, "B");	// For lack of a more sensible default - or should we use "N"?

				// DonR 27Nov2011: For purposes of reading drug_extension and similar tables, set flags
				// for this non-member to enable reading of Maccabi rules but not IDF rules.
				Member.MemberMaccabi = 1;
				Member.MemberTzahal = Member.MemberHova = Member.MemberKeva = 0;

				// DonR 12Dec2021 BUG FIX: If the member ID is zero, set defaults for new member parameters.
				Member.VentilatorDiscount		=
				Member.darkonai_type			=
				Member.force_100_percent_ptn	=
				Member.darkonai_no_card			=
				Member.has_blocked_drugs		=
				Member.died_in_hospital			= 0;
			}

			else
			{	// Look up (hopefully) "real" member.
				// DonR 15Feb2011: For performance, got rid of WHERE condition for del_flg; we never set
				// del_flg to anything other than 0 for this table and the field isn't in the index.
				// DonR 13May2020 CR #31591: Add new Member-on-Ventilator flag. This is
				// currently stored in the old column "asaf_code" (which was sent from
				// AS/400 but never used for anything); when we switch to MS-SQL, the
				// column should be renamed.
				ExecSQL (	MAIN_DB, READ_members_full,
							&v_MemberFamilyName,		&v_MemberFirstName,				&Member.date_of_bearth,
							&Member.maccabi_code,		&v_MemberSpecPresc,				&Member.maccabi_until,
							&Member.payer_tz,			&Member.payer_tz_code,			&v_MemberGender,
							&MemberDefaultPhone,		&MemberHouseNum,				&MemberStreet,
							&MemberCity,				&MemberZipCode,					&Member.insurance_type,

							&Member.keren_mac_code,		&Member.keren_mac_from,			&Member.keren_mac_until,
							&Member.mac_magen_code,		&Member.mac_magen_from,			&Member.mac_magen_until,
							&Member.yahalom_code,		&Member.yahalom_from,			&Member.yahalom_until,
							&Member.carry_over_vetek,	&Member.keren_wait_flag,		&illness_bitmap,
							&Member.card_date,			&Member.update_date,			&Member.update_time,

							&Member.authorizealways,	&Member.updated_by,				&Member.check_od_interact,
							&v_CreditYesNo,				&max_drug_date,					&v_MemberDiscPercent,
							&v_insurance_status,		&v_FamilyHeadTZ,				&v_FamilyHeadTZCode,
							&Member.has_tikra,			&Member.has_coupon,				&v_in_hospital,
							&Member.VentilatorDiscount,	&Member.darkonai_type,			&Member.force_100_percent_ptn,

							&Member.darkonai_no_card,	&Member.has_blocked_drugs,		&Member.died_in_hospital,
							&Member.mahoz,				&Member.dangerous_drug_status,

							&v_MemberIdentification,	&v_IdentificationCode,			END_OF_ARG_LIST					);

				Conflict_Test (reStart);
				
				// DonR 04Dec2022 User Story #408077: Use a new function to set some Member flags and values.
				SetMemberFlags (SQLCODE);

				// DonR 02Nov2025 User Story #429086: For non-Hesder pharmacies, disable the narcotic
				// prescription duration/validity exception logic by forcing in the shorter, non-exempt
				// maximum value.
				if (!HESDER_MACCABI)
				{
					Member.NarcoMaxDuration	= default_narco_max_duration;
					Member.NarcoMaxValidity	= default_narco_max_validity;
				}

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					SetErrorVarArr (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
					err = MAC_TRUE;
				}
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						err = MAC_TRUE;
					}
					else
					{
						// Successful read of member data.

						// TEMPORARY FOR SUPERPHARM TESTING!
						// If the member's Card Date from the database is 5555, act as if
						// the pharmacy sent that date as well.
						// DonR 29May2022: Add a testing-system-only criterion to the "if".
						if ((Member.card_date == 5555) && (!TikrotProductionMode))
							v_MoveCard = 5555;

						// DonR 30Mar2014: For convenience, store some member stuff in a structure - this will make function
						// arguments simpler.
						Member.ID				= v_MemberIdentification;
						Member.ID_code			= v_IdentificationCode;
						Member.sex				= v_MemberGender;
						Member.in_hospital		= v_in_hospital;
						Member.discount_percent	= v_MemberDiscPercent;
						Member.illness_bitmap	= illness_bitmap;
					}	// Successful read of member data.
				}	// Something other than not-found: either success, or a DB problem.


				// Vacation ishurim and member-pharmacy restrictions aren't relevant to deletions.
				if (v_ActionType != SALE_DELETION)
				{
					// See if this member has an all-drug vacation limit-multiplier ishur.
					// DonR 15Feb2011: For performance, shuffled WHERE conditions to conform more closely to index.
					// DonR 25Mar2020: Don't bother with the lookup if we already know member doesn't have any ishurim.
					if (v_MemberSpecPresc)
					{
						ExecSQL (	MAIN_DB, READ_Largo_99997_ishur, Largo_99997_ishur_standard_WHERE,
									&Member.PL_99997_IshurNum,		&Member.PL_99997_OpenDate,
									&v_MemberIdentification,		&v_IdentificationCode,
									&SysDate,						&SysDate,
									END_OF_ARG_LIST															);
					}
					else
					{
						// If we already know member doesn't have any ishurim, just for a not-found error code.
						SQLCODE = 100;
					}

					if (SQLCODE == 0)
					{
						Member.Has_PL_99997_Ishur = 1;
					}
					else
					{
						Member.Has_PL_99997_Ishur = Member.PL_99997_IshurNum = Member.PL_99997_OpenDate = 0;
					}


					// See if this member has a pharmacy purchase restriction.
					// Question: Does this apply to transactions other than drug sales?
					ExecSQL (	MAIN_DB, READ_MemberPharm,
								&v_MemPharm_PhCode,			&v_MemPharm_PhType,		&v_MemPharm_FromDt,
								&v_MemPharm_ToDt,			&v_MemPharm_PhCode2,	&v_MemPharm_PhType2,
								&v_MemPharm_FromDt2,		&v_MemPharm_ToDt2,		&v_MemPharm_ResType,
								&v_MemPharm_PermittedOwner,

								&v_MemberIdentification,	&v_IdentificationCode,	&ROW_NOT_DELETED,
								&SysDate,					&SysDate,				&SysDate,
								&SysDate,					END_OF_ARG_LIST									);

					v_MemPharm_Exists = (SQLERR_code_cmp (SQLERR_ok) == MAC_TRUE);

					// If member has a pharmacy purchase restriction, see how it
					// applies to this sale.
					//
					// ASSUMPTIONS:
					// 1) Restriction is still operative on its "to-date".
					// 2) If there is a match on Pharmacy Code, we don't have to look at
					//    the Pharmacy Type - assume that the people entering this data
					//    know what they're doing and there won't be inconsistency.
					// 3) There is no such thing as a blanket permission - that is, either
					//    there will be a specific Pharmacy Code OR a Pharmacy Type of 1
					//    (sale permitted at all Maccabi pharmacies).
					// 4) Member is allowed to buy non-prescription drugs anywhere.
					//
					// DonR 07Sep2023 User Story #448931: Because there are now exceptions even
					// to all-drug member-pharmacy restrictions, ERR_MEMBER_PHARM_SALE_FORBIDDEN
					// is no longer assigned at the "header" level - it's only a per-drug error,
					// assigned later on in the code.
					// Marianna 25Feb2024 User Story #540234: member-pharmacy restrictions dont apply to cannabis sales
					if ((v_MemPharm_Exists) && (!IsCannabisSale))
					{
						// By default, assume that the sale is forbidden.
						MemPharm_Result = ERR_MEMBER_PHARM_SALE_FORBIDDEN;

						// Look at temporary fields first.
						if ((v_MemPharm_FromDt2 <= SysDate) && (v_MemPharm_ToDt2 >= SysDate))
						{
							if (((v_MemPharm_PhCode2 == v_PharmNum)	&& (v_PharmNum != 0)) ||
								((v_MemPharm_PhCode2 == 0) && (v_MemPharm_PhType2 == 1) && (MACCABI_PHARMACY)))
							{
								MemPharm_Result = ERR_MEMBER_PHARM_PERMITTED_TEMP;
							}
						}

						// Next look at "normal" restriction fields.
						if ((v_MemPharm_FromDt  <= SysDate) && (v_MemPharm_ToDt  >= SysDate))
						{
							if (((v_MemPharm_PhCode  == v_PharmNum)	&& (v_PharmNum != 0)) ||
								((v_MemPharm_PhCode  == 0) && (v_MemPharm_PhType  == 1) && (MACCABI_PHARMACY)))
							{
								MemPharm_Result = ERR_MEMBER_PHARM_PERMITTED;
							}
						}
//
//						// If the restriction applies to all prescription sales, apply it
//						// at the "header" level now.
//						if ((v_MemPharm_ResType == 9) && (RX_SOURCE_OTHER_THAN(RECIP_SRC_NO_PRESC)))
//						{
//							SetErrorVarArr (&v_ErrorCode, MemPharm_Result, 0, 0, &err, &ErrOverflow);
//						}
					}	// Member-pharmacy restriction exists, and this is not a cannabis sale.
				}	// NOT a deletion.


				// Build array of family members, NOT including the member for whom drugs are being bought.
				FamilySize = 0;	// Just to be paranoid.

				// DonR 16May2024 User Story #309736: In some cases, in order to decide if the member can
				// pay for stuff by Credit Line, we need to know whether the person who pays for the member's
				// drugs is also a member of the member's immediate family. First, we'll look at the member
				// him/herself; after that, we'll look at the member's family.
				Member.payer_is_in_family = ((Member.ID == Member.payer_tz) && (Member.ID_code == Member.payer_tz_code));

				DeclareAndOpenCursorInto (	MAIN_DB, READ_FamilyMembers_cur,
											&FamilyMemberID,			&FamilyMemberIDCode,
											&v_FamilyHeadTZ,			&v_FamilyHeadTZCode,
											&v_MemberIdentification,	END_OF_ARG_LIST			);

				if (!SQLERR_error_test ())
				{
					// Fetch data and store in buffer.
					// For now at least, no real error checking; just quit when we hit anything.
					// We're already in "dirty read" mode, so we should be more or less OK.
					for ( ; ; )
					{
						FetchCursor (	MAIN_DB, READ_FamilyMembers_cur	);

						if (SQLCODE == 0)
						{
							FamilyMemberTZ		[FamilySize] = FamilyMemberID;
							FamilyMemberTZCode	[FamilySize] = FamilyMemberIDCode;

							// DonR 16May2024 User Story #309736: See if this family member is the person
							// responsible for paying for the current member's drug purchases. (Note that
							// in this logic we set FamilyMemberTZ TRUE if the condition is met; we DO NOT
							// want to set it FALSE if there isn't a match, because another family member
							// may have been the account payer!)
							if ((FamilyMemberID == Member.payer_tz) && (FamilyMemberIDCode == Member.payer_tz_code))
								Member.payer_is_in_family = true;

							if (++FamilySize >= MAX_FAMILY_SIZE)
								break;	// Buffer capacity reached.
						}
						else
						{
							break;
						}
					}
				}

				CloseCursor (	MAIN_DB, READ_FamilyMembers_cur	);
				// Done with family-member list-building.

			}	// Member ID is non-zero.


			// LOGICAL data tests.

			// Member eligibility
			// DonR 10Oct2011: Tzahal members are not in Meuhedet!
			// DonR 24Dec2015: If this is a sale deletion, treat member as valid even if s/he has left
			// Maccabi - as long as the sale to be deleted took place within a configurable period
			// (based on sysparams/del_valid_months). Note that for these members, we see maccabi_code
			// set negative - so the test for negative/zero Member Rights has to be disabled for expired
			// members who are deleting recent drug sales.
			//
			// DonR 27Jun2016: Per Iris, simplified the criteria, particularly for deletions.
			//    (A) For deletions, if the member is currently eligible, there is no restriction on the date of the sale being deleted.
			//    (B) For deletions of non-eligible members (who died or otherwise left Maccabi), we allow the transaction only if
			//        the sale being deleted took place within a reasonably recent period, defined in sysparams.
			//    (C) For everything *other* than deletions, Member Rights (members/maccabi_code) must be > 0 and the Maccabi Until
			//        date must be at least today.
			//    (D) This change is based on the observation that we do *not* get a reliable Maccabi Until date for dead members -
			//        so we don't even want to look at this date for deletions. Of course, it *is* relevant for drug purchases,
			//        since only living, eligible members are supposed to be buying stuff.
			//
			// DonR 25Nov2021 User Story #206812: Get died-in-hospital indicator from the Ishpuz system.
			// DonR 30Nov2022 User Story #408077: Test for maccabi_code < 1, *not* < 0. Use new macro MEMBER_INELIGIBLE
			// as the test for eligibility to buy stuff; the macro is defined in MsgHndlr.h. Also, use a new macro
			// MEMBER_IN_MEUHEDET (defined in MsgHndlr.h) to decide if the person is a Meuhedet member.
			if (((v_ActionType			== SALE_DELETION)	&&										// This is a deletion request...
				 (Member.maccabi_code	<  1)				&&										// and the member is not eligible...
				 (v_DeletedPrDate		<  IncrementDate (SysDate, (0 - DeletionsValidDays))))	||	// and the sale is before the cutoff period.

				((v_ActionType			!= SALE_DELETION)	&& (MEMBER_INELIGIBLE))				||	// This is *not* a deletion request, and the member is not currently eligible.
//				 ((Member.died_in_hospital)))													||	// THIS CONDITION IS DISABLED.

				(MEMBER_IN_MEUHEDET))																// Member is in Meuhedet.
			{
				// DonR 30Jun2005: If this is a MaccabiCare sale to a non-Maccabi member
				// (T.Z. = 0), don't worry about eligibility.
				if (v_MemberIdentification != 0)
				{
					SetErrorVarArr (&v_ErrorCode, ERR_MEMBER_NOT_ELEGEBLE, 0, 0, NULL, &ErrOverflow);
					err = MAC_TRUE;
				}
			}
			else
			{
				// DonR 27Jun2016: Changed the criteria for this message to test for a non-eligible member
				// based on members/maccabi_code ("Member Rights") and *not* on the Maccabi Until date.
				// DonR 30Nov2022 User Story #408077: Test for maccabi_code < 1, *not* < 0.
				if ((v_ActionType == SALE_DELETION) && (Member.maccabi_code	< 1))
				{
					SetErrorVarArr (&v_ErrorCode, DELETION_ALLOWED_FOR_EX_MEMBER, 0, 0, NULL, &ErrOverflow);
				}
				// DonR 30Nov2021: It's not yet clear if "Member died in hospital" is going to be a transaction-level
				// error, or if it will apply only to expensive items.
				else
				{
					if ((v_ActionType != SALE_DELETION) && (Member.died_in_hospital))
					{
						if (SetErrorVarArr (&v_ErrorCode, MEMBER_DIED_IN_HOSPITAL, 0, 0, NULL, &ErrOverflow))
							err = MAC_TRUE;
					}
				}
			}


			// If card had a "real" date that was different from the card-issue
			// date in the database, set error.
			if ((v_IdentificationCode_s	!= 7						)	&&	// Don't check temp. members
				(v_MoveCard				>  0						)	&&	// 10Jan2005: 1 is a valid card date!
				(v_MoveCard				<  9999						)	&&	// Card was used. 07Mar2006: CR #32984: 9998 = Temp. Card - need to validate it!
				((v_MoveCard != 9997) || (Member.MemberTzahal == 0)	)	&&	// 10Oct2011: Special card for soldiers.
				(v_MoveCard				!= Member.card_date			)	&&	// Date on card doesn't match DB version.
				(Member.card_date		>  0						)	&&  // Yulia 20030213: DB date is "for real".
				(v_MemberIdentification	!= 59						)	&&	// Special case - exempt real members...
				(v_MemberIdentification	!= 83						))		// ...whose ID's have been used for testing.
			{
				// DonR 30Jul2013: Because a lot of new Maccabi Sheli cards were sent out by mail - and members'
				// data was updated with the new card dates before those cards had arrived - a new table,
				// membercard, has been added to list additional/alternative valid card dates for any given
				// member. Accordingly, check this table before sending a "card expired" error.
				ExecSQL (	MAIN_DB, READ_MemberCard,
							&Member.card_date,
							&v_MemberIdentification,	&v_IdentificationCode,
							&v_MoveCard,				END_OF_ARG_LIST				);

				// DonR/Marianna 05Jul2020 CR #32984: If the pharmacy sent 9998, that *should*
				// mean that the member used a valid temporary card. But since we're healthily
				// paranoid, we want to check that there really is a valid temporary card for
				// this member in our database. (Hint: The relevant table is currently empty.)
				if ((SQLCODE != 0) && (v_MoveCard == 9998))
				{
					ExecSQL	(	MAIN_DB, CheckIfValidTempmembExists,
								&RowsFound,
								&v_IdentificationCode,	&v_MemberIdentification,	&SysDate,
								END_OF_ARG_LIST													);

					// In this case, we want to treat RowsFound = 0 as a not-found "error".
					if ((SQLCODE == 0) && (RowsFound < 1))
						SQLCODE = 100;
				}

				if (SQLCODE != 0)
				{
					// DonR 05Apr2017 CR #11541: If the global check-card-date parameter (from sysparams)
					// is set FALSE, we still want to inform the pharmacy that the member's card has
					// expired - but we don't want to prevent the sale from going through. We thus use
					// the special "specify severity" version of the set-error routine, with the severity
					// conditional on the value of the check-card-date flag.
					// WORKINGPOINT: CHECK WITH IRIS WHETHER WE HAVE TO USE DIFFERENT CODES FOR DIFFERENT SEVERITIES!
					// DonR 17Sep207: Pharmacies don't deal gracefully with using different error severities for the
					// same error code - so use a different code for the warning version.
					SetErrorVarArr				(&v_ErrorCode, ((CheckCardDate) ? ERR_CARD_EXPIRED : WARN_CARD_EXPIRED), 0, 0, NULL, &ErrOverflow);
				}
			}			// Card had a "real" date that was different from the card-issue date in the database.


			// DonR 05Apr2017 CR #11541: If pharmacy used an expired temporary card, send
			// a "card expired" error (instead of a "member ID not found" error).
			// Note that the global CheckCardDate flag (from sysparams) does *not*
			// affect how we deal with temporary cards - it applies only to the date
			// on "real" Maccabi cards.
			else
			{
				if ((v_IdentificationCode_s == 7) && (ForceCardExpiredErr))
				{
					SetErrorVarArr (&v_ErrorCode, ERR_CARD_EXPIRED, 0, 0, &err, &ErrOverflow);
				}
			}	// CR #11541 end.

			// If Member belongs to Leumit, and either (A) pharmacy isn't allowed to sell
			// Maccabi prescriptions to Leumit members, or (B) the prescription isn't from
			// a Maccabi doctor, reject the sale. If the pharmacy is permitted but the
			// prescription source is wrong, give a different error.
			// DonR 11Aug2008: Added new Maccabi Nurse prescription source.
			// DonR 04Apr2016: Per Iris Shaya, added new prescription source for Maccabi Dieticians.
			if (v_insurance_status == 2)	// Leumit member.
			{
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					if ((!v_leumi_permission) || ((SPres[i].PrescSource != RECIP_SRC_MACABI_DOCTOR)		&&
												  (SPres[i].PrescSource != RECIP_SRC_MAC_DOC_BY_HAND)	&&
												  (SPres[i].PrescSource != RECIP_SRC_MAC_DIETICIAN)		&&
												  (SPres[i].PrescSource != RECIP_SRC_MACCABI_NURSE)))
					{
						SetErrorVarArr (&v_ErrorCode,
										(v_leumi_permission) ? ERR_PHARM_CANT_SALE_PRECR_SRC : ERR_LEUMI_NOT_VALID,
										0, 0, NULL, &ErrOverflow);
		
						err = MAC_TRUE;
						break;	// Once we've seen one problem, that's enough.
					}	// Either wrong pharmacy permission or wrong prescription source.
				}	// Loop through prescription request looking for Leumit problems.
			}	// Leumit member.


			// DonR 10Apr2013: It looks like all the pharmacies currently have the "card" parameter
			// set to zero - which means that this block of code doesn't do anything.
			// DonR 19Jul2021: It's still true that pharmacies using Transaction 6003 (i.e. everyone
			// except some non-hesder-Maccabi pharmacies) all have "card" set FALSE; but I still don't
			// like having a call to UPD_members_ClearAuthorizeAlways here, since I believe it's a
			// potential bug. Accordingly, I'm going to disable it - this will have no impact on
			// current operations, but may prevent the Authorize Always flag from being incorrectly
			// cleared at some point in the future.
			if ((v_pharm_card == 1) && (v_MemberIdentification != 0))	// only to pharmacy with flag ON
																		// DonR 30Jun2005: Doesn't apply
																		// to sales with T.Z. of zero.
			{
				if (v_IdentificationCode_s != 7) // 20010903 don't check tempmemb
				{
					if (Member.card_date > 0) // Member has a Card Date received from AS/400.
					{
						// If member didn't have card and isn't set to "authorize always", set error. 
						if (!MEMBER_USED_MAG_CARD)
						{
							if (!v_authorizealways)
							{
								SetErrorVarArr (&v_ErrorCode, ERR_PHARM_HAND_MADE, 0, 0, NULL, &ErrOverflow);
							}	// ID entered by hand and authorize-always was NOT set.
//
//							if (v_authorizealways)
//							{
//								// DonR 04Jun2015: If the Authorize Always flag was set because member requested it through
//								// the Maccabi website or our mobile app, we don't want to zero it out - these requests expire
//								// after a short time anyway. In fact, I'm not sure we should be zeroing-out AuthorizeAlways
//								// in any case!
//								if (Member.updated_by != 8888)
//								{
//									// DonR 24Mar2020: This operation requires an integer variable for "updated_by" -
//									// so I created OriginCodeInt. (Elsewhere, orgin_code needs to be a short, since it's
//									// a SMALLINT in the prescriptions table.)
//									ExecSQL (	MAIN_DB, UPD_members_ClearAuthorizeAlways,
//												&OriginCodeInt,			&v_MemberIdentification,
//												&v_IdentificationCode,	END_OF_ARG_LIST				);
//
//									SQLERR_error_test ();
//								}	// Updated_by <> 8888, meaning that we're *not* dealing with a temporary user request.
//							}	// ID entered by hand and authorize-always was set.
//							else
//							{
//								SetErrorVarArr (&v_ErrorCode, ERR_PHARM_HAND_MADE, 0, 0, NULL, &ErrOverflow);
//							}	// ID entered by hand and authorize-always was NOT set.
//
						}	// ID was entered by hand, not by passing magnetic card.
					}	// Member does have Maccabi card.
				}	// NOT a temporary member.
			}	// Pharmacy card flag == 1 (which is NEVER true in Trn. 6003 as of July 2021).


			// DonR 10Jul2012: Validate Doctor Location Codes against Prescription Sources.
			// Three circumstances can trigger an error:
			// (1) Prescription source does not require a Doctor Location Code, but one was supplied.
			// (2) Prescription source *does* require a Doctor Location Code, but one was *not* supplied.
			// (3) A Doctor Location Code (other than 999999) was supplied, but the location is invalid
			//     based on lookup in macabi_centers.
			// DonR 31Oct2012: Make this test conditional, so it executes only for drug sales. Deletions
			// do not have Doctor Location Codes, so the validation causes spurious rejections.
			if (v_ActionType == DRUG_SALE)	// DonR 31Oct2012.
			{
				ErrorCodeToAssign = 0;

				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					if (PrescrSource [SPres[i].PrescSource].PrSrcDocLocnRequired == 0)
					{
						if (SPres[i].DocFacility != 0)
							ErrorCodeToAssign = ERR_DOC_LOCATION_INVALID;
					}
					else
					{	// Prescription source *does* require a valid Doctor Location Code.
						SPres[i].DocFacility -= 990000;	// The initial "99" gets thrown away.

						if ((SPres[i].DocFacility < 1) || (SPres[i].DocFacility > 9999))
						{
							ErrorCodeToAssign = ERR_DOC_LOCATION_INVALID;
							SPres[i].DocFacility = 0;	// So we don't blow anything up sending bogus values to the DB or AS/400.
						}
						else
						{
							// Don't look up Code 9999.
							if (SPres[i].DocFacility < 9999)
							{
								v_DoctorLocationCode = SPres[i].DocFacility;	// Just to keep things simple for the SQL code.

								ExecSQL (	MAIN_DB, READ_MaccabiCenters_ValidateDocFacility,
											&RowsFound, &v_DoctorLocationCode, END_OF_ARG_LIST	);

								Conflict_Test (reStart);
						
								if (SQLERR_error_test ())
								{
									ErrorCodeToAssign = ERR_DATABASE_ERROR;
								}
								else
								{
									if (RowsFound < 1)
										ErrorCodeToAssign = ERR_DOC_LOCATION_INVALID;
								}	// Valid read, but nothing found.
							}	// Doctor Location Code needs to be looked up in macabi_centers.
						}	// Doctor Location Code is in correct range.
					}	// Prescription source *does* require a valid Doctor Location Code.

					if (ErrorCodeToAssign != 0)
						break;	// We've found a problem, so abort the testing loop.

				}	// Loop through drug lines to check Doctor Facility codes.
			
				// If we found something wrong with the Doctor Location Code, report it.
				if (ErrorCodeToAssign > 0)
				{
					if (SetErrorVarArr (&v_ErrorCode, ErrorCodeToAssign, 0, 0, NULL, &ErrOverflow))
					{
						err = MAC_TRUE;
//						break;
					}
				}
			}	// Current action is a drug sale - DonR 31Oct2012 end.


			// If a Client Location Code was sent (e.g. member lives in an old-age home),
			// validate against the macabi_centers table. This will also allow us to
			// sell drugs against a credit line without using the member's Maccabi Card,
			// if the location has a Credit Flag of 9.
			// DonR 10Apr2013: Just to explain - v_ClientLocationCode = 1 for normal purchases
			// made by members (at least those not living in old-age homes) at pharmacies.
			// DonR 24Dec2013: If this is a private-pharmacy sale and a Client Location Code
			// was sent, return an error just as if a non-valid code had been sent.
			// DonR 13Oct2015: Give location-not-found error only for drug sales - NOT for deletions!
			// DonR 26Jul2018: When SuperPharm sends transactions based on website orders, they will use
			// Client Location Code 2500 or 2600. We need to allow this exception to the general rule
			// that private pharmacies can send only Client Location Code 1.
			if (v_ClientLocationCode > 1)
			{
				if ((MACCABI_PHARMACY)				||
					((online_order_num) && ((v_ClientLocationCode == 2500) || (v_ClientLocationCode == 2600))))
				{
					ExecSQL (	MAIN_DB, READ_MaccabiCenters_PatientFacility,
								&v_MacCent_cred_flg,	&first_center_type,
								&v_ClientLocationCode,	END_OF_ARG_LIST			);

					Conflict_Test (reStart);
				}
				else FORCE_NOT_FOUND;

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					if (v_ActionType == DRUG_SALE)	// DonR 13Oct2015.
					{
						SetErrorVarArr (&v_ErrorCode, ERR_LOCATION_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
						err = MAC_TRUE;
//						break;
					}
					else
					{
						// DonR 13Oct2015: If this is something other than a drug sale, ignore location-not-found.
						v_MacCent_cred_flg = 0;
						strcpy (first_center_type, "02");	// Default = most common value.
						FirstCenterTypeNum = 2;				// Default = most common value.
					}
				}
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						break;
					}

					// DonR 04Jan2018 CR #13453: If this is an Al Tor order, check how many times this member
					// has ordered through Al Tor and failed to pick up his/her drugs.
					else	// Successful read of macabi_centers.
					{
						FirstCenterTypeNum = ((first_center_type [1] >= '0') && (first_center_type[1] <= '9')) ? (short)(first_center_type[1] - '0') : 0;

						if ((v_ActionType == DRUG_SALE) && (FirstCenterTypeNum == 1))
						{
							ErrorCodeToAssign = MemberFailedToPickUpDrugs (&Member);

							if (ErrorCodeToAssign > 0)
							{
								if (SetErrorVarArr (&v_ErrorCode, ErrorCodeToAssign, 0, 0, NULL, &ErrOverflow))
								{
									err = MAC_TRUE;
								}
							}	// MemberFailedToPickUpDrugs() detected enough no-shows to throw an error.
						}	// Current action is an Al Tor sale.
					}	// Successful read of macabi_centers.
				}	// Something other than not-found for macabi_centers lookup.
			}	// Client Location Code > 1.


			// DonR 18Jun2018 Remote Order (SuperPharm) enhancement.
			while (online_order_num)	// To avoid lots of messy if...then...else's.
			{
				// For the moment at least, simply ignore Online Order Number processing for transactions
				// other than drug sales.
				if (v_ActionType != DRUG_SALE)
					break;

				// Try to read the Online Order based on the number the pharmacy sent.
				ExecSQL (	MAIN_DB, READ_online_orders_TimestampsAndMember,
							&OO_member_id,			&OO_member_id_code,
							&OO_made_date,			&OO_made_time,
							&OO_start_work_date,	&OO_start_work_time,
							&online_order_num,		&Phrm_info.web_pharmacy_code,
							&Phrm_info.owner,		END_OF_ARG_LIST					);

				// If the row was not found, this transaction is (presumably) an attempt to add a new
				// online order. Accordingly, validate the request and INSERT to online_orders
				// if the pharmacy is authorized to send in remote orders.
				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					if (Phrm_info.order_originator == 0)
					{
						// If the pharmacy is not authorized to create new online orders, we will still record
						// the order number it sent; but we will *not* add the order to online_orders.
						// DonR 10Nov2020: If this is a MaccabiPharm online order, use a different error code
						// (Order Not Found). This is because Maccabi doesn't use a fictitious pharmacy to
						// create online orders - we add them directly to the database.
						SetErrorVarArr (&v_ErrorCode,
										(Phrm_info.web_pharmacy_code == 0) ? ONLINE_ORDER_NOT_FOUND : PHARM_NOT_ORDER_ORIGINATOR,
										0, 0, NULL, &ErrOverflow);
					}
					else
					{	// If we get here, the pharmacy *is* allowed to create new online orders.
						ExecSQL (	MAIN_DB, INS_online_orders,
									&online_order_num,		&v_MemberIdentification,	&v_IdentificationCode,
									&v_RecipeIdentifier,	&v_PharmNum,				&Phrm_info.owner,
									&SysDate,				&SysTime,					END_OF_ARG_LIST			);

						// DonR 08Sep2020: If the Online Order already exists, log it as such rather
						// than as a critical DB error. I've asked Iris about other options for
						// handling duplicate orders, including updating/replacing them, or possibly
						// reporting a separate error code to the requesting (web) pharmacy.
						if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_TRUE)
						{
							GerrLogMini (GerrId, "Online Order #%ld for Pharmacy %d Owner %d already exists.",
										 online_order_num,  v_PharmNum, Phrm_info.owner);

							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						}
						else
						{
							if (SQLERR_error_test ())
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						}
					}

					break;
				}	// Pharmacy sent Online Order Number that was not found in online_orders.

				// If the row was found, we need to validate that the order has not already been filled,
				// that it is for the current member, and that the requesting pharmacy is authorized to
				// fill online orders.
				if (SQLCODE == 0)
				{
					// If the pharmacy is not allowed to sell against online orders, or the order is for
					// a different member, or the order has expired, or the allowed time for working on
					// the order has passed, set appropriate error code(s).
					// These should all be severe errors that prevent the sale from being completed.
					if (Phrm_info.order_fulfiller == 0)
					{
						SetErrorVarArr (&v_ErrorCode, PHARM_NOT_ORDER_FULFILLER, 0, 0, NULL, &ErrOverflow);
					}

					if ((OO_member_id != v_MemberIdentification) || (OO_member_id_code != v_IdentificationCode))
					{
						SetErrorVarArr (&v_ErrorCode, ONLINE_ORDER_WRONG_MEMBER, 0, 0, NULL, &ErrOverflow);
					}

					// DonR 09Sep2020: Add validation for online-order processing: Location Code 2500/2600
					// is mandatory for fulfilling online orders. For now, I'm using the standard "bad
					// location code" error - we'll see if Iris wants a different one.
					// DonR 26Oct2020: Per Iris Shaya, the 2500/2600 test does *not* apply to Maccabi
					// pharmacies. We may want to add a different "mitkan chaver" test for Maccabi
					// pharmacies later.
					// DonR 10Nov2020: Changed the condition for this message from the usual test on
					// Permission Type to a test on Owner - since that's the column we're using as a basis
					// for the rest of the home-delivery logic. (Should probably add macros for this...)
					if ((v_ClientLocationCode != 2500) && (v_ClientLocationCode != 2600) && (Phrm_info.owner != 0))
					{
						SetErrorVarArr (&v_ErrorCode, ERR_LOCATION_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
					}

					OO_min_made_date = AddDays (SysDate, (0 - Phrm_info.max_order_sit_days));
					if (( OO_made_date <  OO_min_made_date)		||
						((OO_made_date == OO_min_made_date) && (OO_made_time < SysTime)))
					{
						SetErrorVarArr (&v_ErrorCode, ONLINE_ORDER_EXPIRED, 0, 0, NULL, &ErrOverflow);
					}

					// If this is the first transaction involved in fulfilling this online order, set
					// start_work_date/time to start the clock ticking. Otherwise, make sure that the
					// maximum allowed work interval has not been exceeded for this online order.
					if (OO_start_work_date < 1)
					{
						// Update online order with current system time. Note that we don't really have
						// to worry about error-handling here - if this UPDATE fails, it's no great tragedy.
						ExecSQL (	MAIN_DB, UPD_online_orders_StartWorkTimestamp,
									&SysDate,			&SysTime,
									&online_order_num,	&Phrm_info.web_pharmacy_code,
									&Phrm_info.owner,	END_OF_ARG_LIST					);
					}	// This is the first transaction involved in fulfilling this online order.

					else
					{
						AddHours (SysDate, SysTime, (0 - Phrm_info.max_order_work_hrs), &OO_min_work_date, &OO_min_work_time);
						if (( OO_start_work_date <  OO_min_work_date)		||
							((OO_start_work_date == OO_min_work_date) && (OO_start_work_time < OO_min_work_time)))
						{
							SetErrorVarArr (&v_ErrorCode, ONLINE_ORDER_EXCESS_WORKTIME, 0, 0, NULL, &ErrOverflow);
						}
					}	// This is *not* the first transaction dealing with fulfilling this online order.

					break;
				}	// Pharmacy sent Online Order Number that *was* found and needs to be validated.

				// If we get here, there was some kind of database error other than "not found". This is
				// considered a show-stopper!
				if (SQLERR_error_test ())
				{
					SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
					break;
				}

				// We should never get here, but let's avoid an endless loop just in case!
				break;
			}	// End of "while (online_order_num)" dummy loop.


//			if (err == MAC_TRUE)
//				break;

			// Test doctor IDs.
			// DonR 10Jul2005: Perform this lookup for *any* prescription where the doctor-id
			// type is not set to 1. Prescriptions from doctors who are not in the doctors
			// table should have the doctor's licence number (ID Type 1), *not* the doctor's
			// Teudat Zehut number. However, if this is a non-prescription sale and the
			// Doctor ID is zero, don't check.
			for (i = NumDoctors = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// DonR 11Dec2018 CR #15277: Validate Doctor ID info based on Prescription Source.
				if (((PrescrSource [SPres[i].PrescSource].id_type_accepted != DOC_LICENSE_IRRELEVANT	) && (SPres[i].DocID		<  1))	||
					((PrescrSource [SPres[i].PrescSource].id_type_accepted == DOC_TZ_ONLY				) && (SPres[i].DocIDType	== 1))	||
					((PrescrSource [SPres[i].PrescSource].id_type_accepted == DOC_LICENSE_ONLY			) && (SPres[i].DocIDType	== 0)))
				{
					// We don't want to bother reporting Doctor ID Type errors for sale deletions.
					if (v_ActionType == DRUG_SALE)
					{
						// This is a show-stopper - but at least for now, don't actually halt execution
						// of the rest of the transaction.
						SetErrorVarArr (&v_ErrorCode, ERR_DOCTOR_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);

					}	// Current transaction is a drug sale.
				}	// Some form of problem in the type of Doctor ID given by pharmacy.

				// DonR 11Dec2018 CR #15277: If Prescription Source == Maccabi Doctor, pharmacy *must*
				// send non-zero Doctor Prescription ID's.
				if (SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR)
				{
					for (Rx = 0; Rx < SPres[i].NumDocRxes; Rx++)
					{
						if (DocRx [Rx + SPres[i].FirstRx].PrID < 1)
						{
							if (SetErrorVarArr (&SPres[i].DrugAnswerCode, NON_ZERO_DOC_PRESC_ID_REQUIRED, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow))
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
								SPres[i].DFatalErr = MAC_TRUE;
							}

							break;	// No point in looking for more missing prescription ID's for the same drug line.
						}	// Found a missing Doctor Prescription ID.
					}	// Loop through prescriptions for the currrent drug line.
				}	// Prescription Source == Maccabi Doctor.


				// Skip past non-prescription sales with no Doctor ID.
				if (SPres[i].DocID == 0)
				{
					SPres[i].DocChkInteractions = 1;	// Interactions are checked *unless* a specific doctor has been flagged.
					continue;
				}

				// Check if this is a doctor we've already looked up.
				for (j = DoctorInList = 0; j < NumDoctors; j++)
				{
					if ((Doctors[j].DocIDType == SPres[i].DocIDType) && (Doctors[j].DocID == SPres[i].DocID))
					{
						DoctorInList = 1;
						SPres[i].DocChkInteractions = Doctors[j].check_interactions;	// Copy doctor interaction flag to SPres structure.
						break;
					}
				}	// Loop through doctors we've already looked up.

				// If this is a new doctor, perform the lookup and store the results.
				if (!DoctorInList)
				{
					// We don't want to look up the same doctor again, even if we failed to find him/her
					// the first time we tried.
					Doctors[NumDoctors].DocIDType			= SPres[i].DocIDType;
					Doctors[NumDoctors].DocID				= SPres[i].DocID;
					Doctors[NumDoctors].check_interactions	= 1;	// Interactions are checked *unless* a specific doctor has been flagged.

					if (SPres[i].DocIDType == 1)	// Doctor identified by license number.
					{
//						// DonR 10Jul2005: Maccabi Doctor prescriptions *must* have the doctor's
//						// Teudat Zehut number, *not* her license number.
//						// DonR 21May2017: Don't report doctor-ID errors for sale deletions.
//						if ((SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR) && (v_ActionType == DRUG_SALE))
//						{
//							SetErrorVarArr (&v_ErrorCode, ERR_DOCTOR_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
//						}
//
						// Look up (normally non-Maccabi) doctor by license number.
						// Note that we're not using the phone number, at least for now, but we might as
						// well look it up anyway.
						// DonR 05Sep2016: Changed SELECT DISTINCT to SELECT FIRST 1 to avoid a cardinality violation.
						ExecSQL (	MAIN_DB, READ_DoctorByLicenseNumber,
									&Doctors[NumDoctors].DoctorFirstName,	&Doctors[NumDoctors].DoctorFamilyName,
									&Doctors[NumDoctors].DoctorPhone,		&Doctors[NumDoctors].check_interactions,
									&SPres[i].DocID_FromLookup,
									&Doctors[NumDoctors].DocID,				END_OF_ARG_LIST								);

						// DonR 11Dec2018 CR #15277: Assuming we didn't find anything in doctor_percents *and* the
						// Prescription Source == Maccabi Doctor, try to find the correct Doctor TZ from the
						// Doctor Prescriptions table. Since this should happen only when a prescription was "missing"
						// from Transaction 6001, and Transaction 6003 normally follows a very short time after 6001,
						// it's not terribly likely that the SELECT below will really find anything.
						if ((SQLCODE != 0) && (SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR))
						{
							ExecSQL (	MAIN_DB, TR6003_READ_Get_doctor_id_from_doctor_presc,
										&SPres[i].DocID_FromLookup,
										&v_MemberIdentification,		&DocRx [SPres[i].FirstRx].PrID,
										&EarliestPrescrDate,			&LatestPrescrDate,
										&SPres[i].DrugCode,				&SPres[i].DrugCode,
										END_OF_ARG_LIST														);

							// If we actually managed to identify our doctor, read her details from the database.
							if (SQLCODE == 0)
							{
								// Look up (Maccabi) doctor by Teudat Zehut number.
								// Note that we're not using the phone number, at least for now, but we might as
								// well look it up anyway. Note also that since we're looking up the doctor based
								// on a doctor_id that we read from doctor_presc, we don't really expect this
								// lookup to fail - and we'll accept any failure to read the doctor's details
								// with Buddha-like equanimity.
								ExecSQL (	MAIN_DB, READ_doctors,
											&Doctors[NumDoctors].DoctorFirstName,	&Doctors[NumDoctors].DoctorFamilyName,
											&Doctors[NumDoctors].DoctorPhone,		&Doctors[NumDoctors].check_interactions,
											&SPres[i].DocID_FromLookup,				END_OF_ARG_LIST								);
							}	// We found the (apparent) doctor TZ from doctor_presc.
						}	// Pharmacy sent Doctor License Number for a Maccabi doctor that was not found in doctor_percents.

						// If we didn't get a "hit", blank out the doctor-name variables.
						// Note that (as in Trn. 2003 and 5003) no error is returned for doctor-not-found-by-license-number.
						if (SQLERR_code_cmp (SQLERR_ok) != MAC_TRUE)
						{
							strcpy (Doctors[NumDoctors].DoctorFamilyName,	"");
							strcpy (Doctors[NumDoctors].DoctorFirstName,	"");
							strcpy (Doctors[NumDoctors].DoctorPhone,		"");
							Doctors[NumDoctors].check_interactions = 1;	// Interactions are checked *unless* a specific doctor has been flagged.

							if ((SQLERR_code_cmp (SQLERR_not_found)			!= MAC_TRUE)	&&
								(SQLERR_code_cmp (SQLERR_access_conflict)	!= MAC_TRUE))
							{
								if (SQLERR_error_test ())
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}
							}	// Something other than not-found.
						}	// Something other than successful read.
					}	// Doc ID Type == 1: look up (non-Maccabi) doctor by license number.

					else
					{	// Maccabi doctor.

						// For now at least, we'll report "doctor ID = member ID" at the "header" level.
						if ((SPres[i].DocID		== v_MemberIdentification)	&&
							(v_ActionType		!= SALE_DELETION))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DOCTOR_EQ_MEMBER, 0, 0, NULL, &ErrOverflow);
//							err = MAC_TRUE;
						}

						// DonR 07Nov2024 User Story #357209: Check if this is an externally-supplied prescription
						// (i.e. from MaccabiDent, a hospital, or some other source; and, if so, use the relevant
						// values stored in doctor_presc instead of looking up the doctor in the doctors table.
						ExecSql (	MAIN_DB, TR6003_CheckForExternalRxSupplier,
									&ExternalRx_origin,						&Doctors[NumDoctors].DoctorFirstName,
									&Doctors[NumDoctors].DoctorFamilyName,	&Doctors[NumDoctors].DoctorPhone,
									&v_MemberIdentification,				&v_IdentificationCode,
									&Doctors[NumDoctors].DocID,				&DocRx [SPres[i].FirstRx].PrID,
									END_OF_ARG_LIST																	);

						// If we couldn't read the prescription (which shouldn't normally happen) or the
						// prescription is an ordinary Maccabi Doctor one, go ahead and read the doctor
						// fields from the doctors table. Note that if we *did* read an externally-supplied
						// prescription, we will leave Doctors[NumDoctors].check_interactions set to its
						// default of 1 (= TRUE).
						if ((SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE) || (ExternalRx_origin == 0))
						{
							// Look up (Maccabi) doctor by Teudat Zehut number.
							// Note that we're not using the phone number, at least for now, but we might as
							// well look it up anyway.
							ExecSQL (	MAIN_DB, READ_doctors,
										&Doctors[NumDoctors].DoctorFirstName,	&Doctors[NumDoctors].DoctorFamilyName,
										&Doctors[NumDoctors].DoctorPhone,		&Doctors[NumDoctors].check_interactions,
										&Doctors[NumDoctors].DocID,				END_OF_ARG_LIST								);
						}

						// If we didn't get a "hit", blank out the doctor-name variables.
						if (SQLERR_code_cmp (SQLERR_ok) != MAC_TRUE)
						{
							strcpy (Doctors[NumDoctors].DoctorFamilyName,	"");
							strcpy (Doctors[NumDoctors].DoctorFirstName,	"");
							strcpy (Doctors[NumDoctors].DoctorPhone,		"");
							Doctors[NumDoctors].check_interactions = 1;	// Interactions are checked *unless* a specific doctor has been flagged.

							if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
							{
								// For now at least, report doctor-not-found on the "header" level.
								// DonR 21May2017: Don't report doctor-ID errors for sale deletions.
								if (v_ActionType == DRUG_SALE)
									SetErrorVarArr (&v_ErrorCode, ERR_DOCTOR_ID_CODE_WRONG, 0, 0, NULL, &ErrOverflow);
//								err = MAC_TRUE;
							}
							else
							{
								if (SQLERR_error_test ())
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}
							}	// Something other than not-found.
						}	// Something other than successful read.
					}	// Doc ID Type != 1: look up (Maccabi) doctor by Teudat Zehut number.

					// Copy doctor's check-interaction flag to SPres structure.
					SPres[i].DocChkInteractions = Doctors[NumDoctors].check_interactions;

					// Even if we failed to find the doctor in our database, we still need to advance the doctor counter.
					NumDoctors++;
					
				}	// Doctor wasn't already in the list.
			}	// Loop through prescription lines to look up doctors.

		}
		while (0);
		// End of Big Dummy Loop #1.

		// DonR 27Apr2005: No need to restore "normal" database isolation here.


		// DUMMY LOOP #2 TO PREVENT goto.

		// DonR 21Apr2005: Avoid unnecessary lock errors by downgrading "isolation"
		// for this section. (Note that it should already be downgraded!)
		SET_ISOLATION_DIRTY;


		// DonR 19Feb2019: If the current requesting pharmacy isn't allowed to execute this transaction,
		// skip the loop below - we don't want to sent any error codes other than "this transaction is
		// illegal" in this case.
		if (PHARM_LEGAL_FOR_TRN)
		do	// Exiting from LOOP writes to database and sends reply.
		{
			// Drugs validation.
			// DonR 09Jun2010: Split the previous loop into two loops. The first one reads
			// all drugs from the drug_list table (using the new function read_drug)
			// and does some minimal processing of the data read; the second one deals with
			// Drug Purchase Limits, etc. This eliminates the ugly "read ahead" logic I added
			// on 06Jun2010, since now by the time we look at limits, all the drug_list data
			// for the current sale is already available.
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				v_DrugCode = SPres[i].DrugCode;

				// DonR 25Jul2013: If we found a vacation ishur in special_prescs, copy its ishur number into all drugs.
				if (Member.Has_PL_99997_Ishur)
					SPres[i].vacation_ishur_num = Member.PL_99997_IshurNum;


				// DonR 23Apr2025 User Story #390071: If this is a sale against one or more Maccabi
				// Doctor prescriptions, get the Rule Number (if any) specified by the doctor. This
				// gives us a "nohal" (presumably with Confirming Authority > 0) that we can use to
				// give the member better participation than the default. Note that since sPres is
				// initialized to all-zeroes, we shouldn't have to set SPres[i].DoctorRuleNumber for
				// non-Maccabi-Doctor sales.
				// DonR 13May2025 User Story #388766: Also get the sold status and the last-sold date,
				// so we know if this sale is a candidate for a special drug-shortage discount.
				if (SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR)
				{
					short	RxSoldStatus;
					int		RxLastSoldDate;

					ExecSQL	(	MAIN_DB, ReadPrescriptionDoctorRuleNumber,

								&SPres[i].DoctorRuleNumber,				&RxSoldStatus,
								&RxLastSoldDate,

								&Member.ID,								&DocRx [SPres[i].FirstRx].PrID,
								&DocRx [SPres[i].FirstRx].FromDate,		&DocRx [SPres[i].FirstRx].LargoPrescribed,
								&DocRx [SPres[i].FirstRx].DocID,		&Member.ID_code,
								END_OF_ARG_LIST																		);

					// No serious error-trapping here - but if we do see an error, log it.
					if (SQLCODE)
					{
						SPres[i].DoctorRuleNumber = 0;	// Should be redundant - but paranoia is a good thing.

						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							// DonR 04Jun2025: Looks like this diagnostic clutters up the log, and it's not really
							// essential - so I'll disable it for now, but leave it available for later if needed.
							if (0)
							{
								GerrLogMini (	GerrId,	"ReadPrescriptionDoctorRuleNumber couldn't find prescription %d "
														"for Member %d Doctor %d Largo %d.",
												DocRx [SPres[i].FirstRx].PrID,
												Member.ID,
												DocRx [SPres[i].FirstRx].DocID,
												DocRx [SPres[i].FirstRx].LargoPrescribed	);
							}
						}
						else
						{
							SQLERR_error_test ();
						}
					}

					// DonR 13May2025 User Story #388766: Add logic to check whether this drug may need to be
					// given a special discount because the prescription couldn't be completely filled in the
					// previous calendar month. Actually giving this discount also depends on the presence of
					// a "nohal" with confirm_authority equal to 17 (sysparams/DrugShortageRuleConfAuthority).
					// NOTE: We're assigning SPres[i].WasPossibleDrugShortage a "true" Boolean value - so it
					// should be tested as such, *not* looking for a value > 0, since "true" == -1!
					else
					{
						SPres[i].WasPossibleDrugShortage =
							(	(SPres[i].DL.rule_status						>  0)	&&	// There is at least something in drug_extension for this Largo Code.
								(SPres[i].NumDocRxes							== 1)	&&	// The sale is against exactly one doctor_presc row.
								(RxSoldStatus									== 1)	&&	// The prescription has been partially sold.
								(diff_calendar_months (RxLastSoldDate, SysDate)	== 1)		// The previous sale happened last month.
							);
					}	// We did succeed in reading the first prescription on the list for this drug line.
				}	// DonR 23Apr2025 User Story #390071 end.

			
				// DonR 11Jul2011: Per Iris Shaya, check for duplicate drugs in a sale request.
				for (j = 0; j < i; j++)
				{
					if (SPres[j].DrugCode == v_DrugCode)
					{
						if (SetErrorVarArr (&SPres[j].DrugAnswerCode, ERR_DUPLICATE_DRUG_IN_SALE, v_DrugCode, j + 1, NULL, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							SPres[i].DFatalErr = SPres[j].DFatalErr = MAC_TRUE;
							break;	// Out of the "for j..." loop - we still try to read the drug from drug_list.
						}
					}
				}
				// DonR 11Jul2011 end.

				// Marianna 17Mar2024 User Story #540234 - moved the call to read_drug() up to near the beginning of the transaction.


				// DonR 30Oct2025 User Story #429086: If the pharmacy is selling narcotics/opioids,
				// test the prescription's treatment length and validity-length and return errors
				// (to private pharmacies) or warnings (to MaccabiPharm) if the limits are exceeded.
				// Note that digital Maccabi Doctor prescriptions are exempt from this logic - but
				// other prescriptions do get this logic applied, even if they are digital.
				if (	(v_ActionType			== DRUG_SALE	)										&&
						(SPres[i].DL.drug_type	== 'N'			)										&&
						((!SPres[i].IsDigital) || (SPres[i].PrescSource != RECIP_SRC_MACABI_DOCTOR))		)
				{
					bool	DurationViolation		= false;
					bool	ValidityViolation		= false;
					bool	PreventSale				= false;
					bool	UsingExemptValues		= (Member.NarcoMaxDuration == exempt_narco_max_duration);
					int		PrescriptionTokefUsed;
					int		EffectiveDuration		= SPres[i].Duration;

					// In the case of non-continuous treatment (indicated by a non-zero value for
					// Course Length), the effective duration includes everything up to (and including)
					// the first day of the last course. So if there are 2 courses of 4 days each, the
					// effective duration will be 5 days even if SPres[i].Duration == 8. (Note that the
					// computation is meaningful only if the course length is > 1 and the overall
					// duration is at least 2 courses. Note also that (according to Iris) there is only
					// one drug in our system for which this calculation will be relevant!
					if ((SPres[i].course_len_days > 1) && (SPres[i].Duration >= (SPres[i].course_len_days * 2)))
					{
						// Strip off the last course, except for its first day, from the overall duration.
						EffectiveDuration = SPres[i].Duration + 1 - SPres[i].course_len_days;
					}

					// Treatment duration is reported only at the drug-line level - not for each prescription.
					// Note that digital opioid prescriptions have the same maximum duration as non-digial ones
					// for exempt members.
					if (	((SPres[i].Duration > exempt_narco_max_duration) && (SPres[i].IsDigital))	||
							 (SPres[i].Duration > Member.NarcoMaxDuration)									)
					{
						DurationViolation = true;
					}

					// For non-digital prescriptions, we normally expect only a single prescription per drug
					// line - but let's not count on that, especially for non-digital electronic prescriptions.
					for (Rx = 0; Rx < SPres[i].NumDocRxes; Rx++)
					{
						// Note that today counts as one day of "tokef" - so if the prescription's Valid
						// From Date was yesterday, that's *2* days of "tokef". So we add 1 to the output
						// of GetDaysDiff() before comparing the "tokef" length to the limit.
						PrescriptionTokefUsed = 1 + GetDaysDiff (SysDate, DocRx [Rx + SPres[i].FirstRx].FromDate);

						if (	((PrescriptionTokefUsed	> exempt_narco_max_validity) && (SPres[i].IsDigital))	||
								 (PrescriptionTokefUsed	> Member.NarcoMaxValidity)									)
						{
							ValidityViolation = true;
							break;	// No need to keep looping - not that it makes much difference here.
						}
					}

					if (DurationViolation)
					{
						// I could have done this using nested ternary operators, but I decided
						// to have mercy on the next person who has to read the code.
						// Note that we're setting PreventSale using OR-equals - so once we set
						// it TRUE, it will stay TRUE.
						if (UsingExemptValues)
						{
							PreventSale |= SetErrorVarArr (	&SPres[i].DrugAnswerCode,
															(MACCABI_PHARMACY ?	WARN_NARC_HAND_RX_DURATION_EXEMPT	: ERR_NARC_HAND_RX_DURATION_EXEMPT),
															v_DrugCode, i + 1, NULL, &ErrOverflow	);
						}
						else
						{
							PreventSale |= SetErrorVarArr (	&SPres[i].DrugAnswerCode,
															(MACCABI_PHARMACY ?	WARN_NARC_HAND_RX_DURATION_DEFAULT	: ERR_NARC_HAND_RX_DURATION_DEFAULT),
															v_DrugCode, i + 1, NULL, &ErrOverflow	);
						}
					}	// There is a duration violation.

					if (ValidityViolation)
					{
						// I could have done this using nested ternary operators, but I decided
						// to have mercy on the next person who has to read the code.
						// Note that we're setting PreventSale using OR-equals - so once we set
						// it TRUE, it will stay TRUE.
						if (UsingExemptValues)
						{
							PreventSale |= SetErrorVarArr (	&SPres[i].DrugAnswerCode,
															(MACCABI_PHARMACY ?	WARN_NARC_HAND_RX_VALIDITY_EXEMPT	: ERR_NARC_HAND_RX_VALIDITY_EXEMPT),
															v_DrugCode, i + 1, NULL, &ErrOverflow	);
						}
						else
						{
							PreventSale |= SetErrorVarArr (	&SPres[i].DrugAnswerCode,
															(MACCABI_PHARMACY ?	WARN_NARC_HAND_RX_VALIDITY_DEFAULT	: ERR_NARC_HAND_RX_VALIDITY_DEFAULT),
															v_DrugCode, i + 1, NULL, &ErrOverflow	);
						}
					}	// There is a validity ("tokef") violation.

					if (PreventSale)
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						SPres[i].DFatalErr = MAC_TRUE;
					}
				}	// DonR 30Oct2025 User Story #429086 end.


				// DonR 09Oct2016: If this is an "emergency supply" sale, hypnotics and narcotics are not allowed.
				// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
				if ((SPres[i].PrescSource	== RECIP_SRC_EMERGENCY_NO_RX)	&&
					(v_ActionType			== DRUG_SALE)					&&
//					((SPres[i].DL.drug_type == 'H') || (SPres[i].DL.drug_type == 'N')))
					((SPres[i].DL.drug_type == 'H') || (SPres[i].DL.is_narcotic)))
				{
					if (SetErrorVarArr (&SPres[i].DrugAnswerCode, NARCOTICS_HYPNOTICS_RX_ONLY_ERR, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						continue;
					}
				}


				// DonR 28Nov2021 User Story #205423: Check for maximum daily OTC purhases of a
				// particular drug from a particular pharmacy.
				// DonR 25Jan2024 User Story #545773: Split into two parameters, MacPharmMaxOTC_OP_PerDay
				// for Drug Type 'O' and the new MacPharmMaxGSL_OP_PerDay for Drug Type 'Q'.
				// DonR 29Jan2024 User Story #205423/#545773: While the daily limit is expressed in OP,
				// we need to compute previous and current purchases using units as well as OP.
				if ((MACCABI_PHARMACY)															&&	// Maccabi only, at least for now.
					(SPres[i].PrescSource		== RECIP_SRC_NO_PRESC)							&&	// We're interested only in OTC purchases.
					(((MacPharmMaxOTC_OP_PerDay	>  0) && (SPres[i].DL.drug_type == 'O'))	||		// Relevant forms of OTC drug/supplement: O = OTC, Q = GSL.
					 ((MacPharmMaxGSL_OP_PerDay	>  0) && (SPres[i].DL.drug_type == 'Q'))))			// If the limit is < 1, the feature is disabled.
				{
					int	OTC_prev_tot_op			= 0;
					int	OTC_prev_tot_units		= 0;
					int	OTC_current_tot_units	= 0;
					int	OTC_permitted_tot_units	= 0;

					// DonR 29Jan2024 User Story #205423/#545773: Compute current purchase and permitted
					// quantity using units as well as OP.
					OTC_permitted_tot_units =		((SPres[i].DL.drug_type == 'O') ? 
														MacPharmMaxOTC_OP_PerDay : MacPharmMaxGSL_OP_PerDay)
												*	SPres[i].DL.effective_package_size;

					OTC_current_tot_units	 =		SPres[i].Units + (SPres[i].Op * SPres[i].DL.effective_package_size);



					// Don't bother looking up earlier sales if the current sale is enough to put us over the limit on its own.
					if (OTC_current_tot_units <= OTC_permitted_tot_units)
					{
						ExecSQL (	MAIN_DB, READ_count_one_day_OTC_purchases,
									&OTC_prev_tot_op,	&OTC_prev_tot_units,

									&Member.ID,			&SPres[i].DL.largo_code,
									&SysDate,			&v_PharmNum,
									&Member.ID_code,	END_OF_ARG_LIST				);

						// If the DB query failed for any reason, just assume that we found
						// no previous purchases - don't worry about "real" error trapping.
						if (SQLCODE)
						{
							OTC_prev_tot_op = OTC_prev_tot_units = 0;
							SQLERR_error_test ();
						}

						// Add previously-bought OP x package size to previously-bought units.
						OTC_prev_tot_units += (OTC_prev_tot_op * SPres[i].DL.effective_package_size);
					}

					if ((OTC_prev_tot_units + OTC_current_tot_units) > OTC_permitted_tot_units)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode,
											(SPres[i].DL.drug_type == 'O') ?	OVER_DAILY_OTC_OP_PER_PHARM_LIMIT :
																				OVER_DAILY_GSL_OP_PER_PHARM_LIMIT,
											v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							continue;
						}
					}
				}	// Need to check for maximum daily OTC purhases of a particular drug from a particular pharmacy.


				// DonR 17Oct2021 User Story #196891: Check whether this drug is blocked for this member.
				// Note that unlike Transaction 6001, in Transaction 6003 we do *not* need to check
				// member_blocked_drugs for a generic substitute - here, the pharmacy has already indicated
				// what medication they intend to sell, so we check blocked status only for that drug.
				// DonR 13Mar2025 User Story #384811: To support more detailed drug-blocking based on
				// different categories of Darkonaim (Maccabi, Harel Tourists, Harel Foreign Workers),
				// add Darkonai Type (3 times) to the READ_CheckDrugBlockedForMember parameter list.
				if ((Member.has_blocked_drugs) || (SPres[i].DL.has_member_type_exclusion))	// Don't waste a DB lookup if we know we won't get results.
				{
					ExecSQL (	MAIN_DB, READ_CheckDrugBlockedForMember,
								&RowsFound,
								&Member.ID,
								&Member.darkonai_type,		&Member.darkonai_type,	&Member.darkonai_type,
								&SPres[i].DL.largo_code,	&Member.ID_code,		END_OF_ARG_LIST			);

					if ((SQLCODE == 0) && (RowsFound > 0))
					{
						// Mark this drug as blocked - so for private pharmacies, we'll know we have to
						// force participation to 100%, and we'll pass an indicator to the Nihul Tikrot
						// application so it knows to leave this item out of its calculations.
						// NOTE: SPres is already initialized to all-zeroes, so we don't need a separate
						// initialization for SPres[i].LargoBlockedForMember.
						SPres[i].LargoBlockedForMember = 1;


						// Private pharmacies get a warning message since they can still sell drugs at 100%
						// participation, while the Maccabi version will be a full transaction-blocker.
						// DonR 26Jul2023 User Story #196891/448931: Use separate message code(s) for Darkonaim;
						// for now, this applies only to the MaccabiPharm "chasima" version.
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode,

											(Member.ID_code == 9)
												?	(MACCABI_PHARMACY ? LARGO_BLOCKED_FOR_DARKONAI_MAC		: LARGO_CODE_BLOCKED_FOR_MEMBER_PVT)
												:	(MACCABI_PHARMACY ? LARGO_CODE_BLOCKED_FOR_MEMBER_MAC	: LARGO_CODE_BLOCKED_FOR_MEMBER_PVT)	,

											v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							continue;
						}
					}
					else
					{
						if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
						{
							SQLERR_error_test ();
						}
					}
				}


				// DonR 15Sep2020 CR #30106: If this is a drug that requires a prior purchase before
				// allowing future sales (i.e. for 3 months at a time), check whether such a qualifying
				// sale has in fact been made. If not, change the drug's in-memory future-sale flag to
				// FUTURE_SALE_NOT_YET_QUALIFIED; this will disable 3-month sales and provide a special
				// error message to the pharmacy.
				if (((SPres[i].DL.allow_future_sales	== FUTURE_SALE_MAC_ONLY) || (SPres[i].DL.allow_future_sales == FUTURE_SALE_ALL_PHARM))		&&
					(SPres[i].DL.qualify_future_sales	>  0))
				{
					EarliestPurchaseDate	= AddDays (SysDate, (0 - FutureSalesMaxHist));
					LatestPurchaseDate		= AddDays (SysDate, (0 - FutureSalesMinHist));
					FirstPurchaseOfDrug		= 0;	// Paranoid re-initialization.

					ExecSQL (	MAIN_DB, READ_CheckForPreviousPurchaseOfDrug,
								&RowsFound,
								&Member.ID,				&SPres[i].DL.largo_code,	&EarliestPurchaseDate,
								&LatestPurchaseDate,	&Member.ID_code,			END_OF_ARG_LIST			);

					// No very fancy error-handling here.
					if (SQLCODE)
						SQLERR_error_test ();	// Just to catch bugs or unexpected DB problems.
GerrLogMini (GerrId, "Qualify future sales: Member %d, Largo %d, from %d to %d, SQLCODE = %d, RowsFound = %d.",
	Member.ID, SPres[i].DL.largo_code, EarliestPurchaseDate, LatestPurchaseDate, SQLCODE, RowsFound);
					if ((SQLCODE == 0) && (RowsFound < 1))
					{
						// No qualifying prior purchase was found - so change the drug's in-memory
						// future-sale flag accordingly.
						SPres[i].DL.allow_future_sales = FUTURE_SALE_NOT_YET_QUALIFIED;

						// DonR 01Oct2020: If we didn't find a qualifying past sale, check again to see
						// if this is the first sale for this drug. If it is and the member is buying
						// only what s/he is allowed, we want to send a new warning message to pharmacy.
						ExecSQL (	MAIN_DB, READ_CheckForPreviousPurchaseOfDrug,
									&RowsFound,
									&Member.ID,				&SPres[i].DL.largo_code,	&LatestPurchaseDate,
									&SysDate,				&Member.ID_code,			END_OF_ARG_LIST			);

						FirstPurchaseOfDrug = (SQLCODE == 0) && (RowsFound < 1);

					}
				}	// DonR 15Sep2020 CR #30106: need to check for prior purchase to qualify 3-month sales.


				// Set errors for cannabis sales:
				// a. if prescription Source <> 1
				// b. if it has at least one cannabis item and at least one non-cannabis item
				// c. if pharmacy is not authorized for cannabis
				// d. if future dated beyond CannabisSaleEarlyDays days from today
				if (v_ActionType == DRUG_SALE && SPres[i].DL.drug_type == 'K')
				{

					//a. Block sale if Prescription Source != Maccabi Doctor
					if (SPres[i].PrescSource != RECIP_SRC_MACABI_DOCTOR)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, CANNABIS_NEEDS_DIGITAL_RX, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							SPres[i].DFatalErr = MAC_TRUE;
						}
					}	// Prescription Source != Maccabi Doctor.

					//b. Block sale if it has at least one cannabis item and at least one non-cannabis item.
					if (!IsCannabisSale)
					{
						if (SetErrorVarArr (&v_ErrorCode, CANNABIS_NEEDS_SEPARATE_SALE_REQ, 0, 0, NULL, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							SPres[i].DFatalErr = MAC_TRUE;
						}
					}

					//c. Block sale if pharmacy is not authorized
					if (!Phrm_info.can_sell_cannabis)
					{
						SetErrorVarArr (&v_ErrorCode,
							(CannabisPermitPerPharmacy ? THIS_PHARMACY_CANNOT_SELL_CANNABIS : MACCABIPHARM_CANNOT_SELL_CANNABIS), 0, 0, NULL, &ErrOverflow);
					}

					//d. Block sale of a cannabis item if it is future dated beyond CannabisSaleEarlyDays days from today
					if (SPres[i].MaxPrDate > MaxCannabisDate)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, CANNABIS_FORBIDDEN_FOR_FUTURE_RX, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							SPres[i].DFatalErr = MAC_TRUE;
						}
					}

				}
				else
				{
					// Block sale of a not cannabis item and this *is* a cannabis sale
					if (SPres[i].DL.drug_type != 'K' && IsCannabisSale)
					{
						if (SetErrorVarArr (&v_ErrorCode, CANNABIS_NEEDS_SEPARATE_SALE_REQ, 0, 0, NULL, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							SPres[i].DFatalErr = MAC_TRUE;
						}
					}
				}	// END of block sale with a cannabis item: User Story #540234 
					


				// DonR 22Jun2020 CR #32984 Part 1: If member is buying narcotics and didn't use his/her
				// magnetic card, send a warning/error to pharmacy. Note that for now, I'm using
				// the macro MEMBER_USED_CURRENT_MAG_CARD; but if it's decided that an expired
				// card is acceptable for this purpose, MEMBER_USED_MAG_CARD could be used instead.
				// In addition, check for "split sales" of narcotic prescriptions between pharmacies.
				// Marianna 22Feb2024 User Story #540234 Cannabis item
				// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
				if ((SPres[i].PrescSource	== RECIP_SRC_MACABI_DOCTOR)		&&
					(v_ActionType			== DRUG_SALE)					&&
//					((SPres[i].DL.drug_type	== 'N')						||
					((SPres[i].DL.is_narcotic)							||
					 (SPres[i].DL.drug_type	== 'K')))		
				{
					// If the member didn't use a current magnetic card, check whether there's a current
					// service-without-card request; if not, give the warning/error.
					if ((!MEMBER_USED_CURRENT_MAG_CARD) && (!CheckForServiceWithoutCard (&Member, Phrm_info)))
					{
						// DonR 01Jul2020: One more requirement - we don't want to stop the sale
						// if all the prescriptions have their Digital Prescription Flag set
						// FALSE - since in that case, the member has to come to the pharmacy
						// with a printout of the prescription, which adds a level of security.
						// We want to stop the sale only if there is at least one digital prescription
						// involved, since that means that there's no magnetic card AND no printout.
						// QUESTION: Can we just use SPres[i].IsDigital instead of looking up each
						// prescription? We get values of 2 and 3 from pharmacies, as well as the
						// usual 0 and 1.
						RowsFound = 0;	// Default is that there are no digital prescriptions involved.

						if (SPres[i].NumDocRxes > 0)
						{

							for (j = SPres[i].FirstRx; j < (SPres[i].FirstRx + SPres[i].NumDocRxes); j++)
							{
								ExecSQL	(	MAIN_DB, CheckPrescriptionDigitalStatus,
											&digital_presc_flag,
											&Member.ID,					&DocRx [j].PrID,	&DocRx [j].FromDate,
											&DocRx [j].LargoPrescribed,	&DocRx [j].DocID,	&Member.ID_code,
											END_OF_ARG_LIST															);

								// The only values for digital_presc_flag should be 0 and 1. At least
								// for now, accept any value > 0 as TRUE.
								if ((SQLCODE == 0) && (digital_presc_flag > 0))
								{
									RowsFound = 1;
									break;	// We don't need to look for more than one digital prescription.
								}
							}	// Loop through prescriptions for this drug line.
						}	// There is at least one doctor prescription for this drug line.

						if (RowsFound > 0)
						{
							if (SetErrorVarArr (&SPres[i].DrugAnswerCode, SELLING_NARCOTIC_WITHOUT_MAG_CARD, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
//								continue;	FOR NOW AT LEAST, CONTINUE LOOKING FOR OTHER PROBLEMS.
							}
						}	// We found at least one digital prescription for this drug line.
					}	// Member didn't use a current magnetic card OR create a valid service-without-card request.


					// Now look for previous partial sales at other pharmacies of any of the prescriptions
					// for this narcotic drug.
					if (SPres[i].NumDocRxes > 0)
					{
						for (j = SPres[i].FirstRx; j < (SPres[i].FirstRx + SPres[i].NumDocRxes); j++)
						{
							// Don't check unless this is a Maccabi doctor prescription with a non-zero prescription ID.
							if ((DocRx [j].DocID == 0) || (DocRx [j].PrID == 0))
								continue;

							ExecSQL	(	MAIN_DB, CheckForPartlySoldNarcoticsPrescription,
										&RowsFound,
										&Member.ID,					&DocRx [j].PrID,	&DocRx [j].FromDate,
										&DocRx [j].LargoPrescribed,	&DocRx [j].DocID,	&Member.ID_code,
										&v_PharmNum,				END_OF_ARG_LIST								);

							if ((SQLCODE == 0) && (RowsFound > 0))
							{
								if (SetErrorVarArr (&SPres[i].DrugAnswerCode, NARCOTIC_SPLIT_SALE_AT_OTHER_PHARM, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
//									continue;	FOR NOW AT LEAST, CONTINUE LOOKING FOR OTHER PROBLEMS.
								}

								break;	// No point in continuing the inner loop once we've found a
										// partially-sold prescription sold at a different pharmacy.
							}
						}	// Loop through prescriptions for this narcotic drug-line.
					}	// There is at least one doctor prescription for this narcotic drug-line.
				}	// Selling narcotics with a Maccabi Doctor prescription - CR #32984 Part 1 end.


				// DonR 23Jun2020 CR #32984 Part 2: If *any* included Maccabi doctor prescription
				// has already been fully sold, generate an error. (Note that this will *not*
				// entirely prevent abuse - it will still be possible to execute Trn. 6003 on two
				// separate pharmacy computers for the same prescription, then execute Trn. 6005
				// to complete both sales. The current change prevents abuse when Trn. 6001 is
				// executed on two computers, then one of them completes the sale *before* the
				// second computer runs Trn. 6003. The more complete fix will require database
				// changes, since prescriptions will have to be marked in some way *before* Trn.
				// 6005 is run.)
				if ((SPres[i].PrescSource	== RECIP_SRC_MACABI_DOCTOR)		&&
					(v_ActionType			== DRUG_SALE)					&&
					(SPres[i].NumDocRxes	>  0))
				{
					for (j = SPres[i].FirstRx; j < (SPres[i].FirstRx + SPres[i].NumDocRxes); j++)
					{
						// Don't check unless this is a Maccabi doctor prescription with a non-zero prescription ID.
						if ((DocRx [j].DocID == 0) || (DocRx [j].PrID == 0))
							continue;

						ExecSQL	(	MAIN_DB, CheckForFullySoldDocRx,
									&RowsFound,
									&Member.ID,					&DocRx [j].PrID,	&DocRx [j].FromDate,
									&DocRx [j].LargoPrescribed,	&DocRx [j].DocID,	&Member.ID_code,
									END_OF_ARG_LIST															);

						if ((SQLCODE == 0) && (RowsFound > 0))
						{
							if (SetErrorVarArr (&SPres[i].DrugAnswerCode, PRESCRIPTION_ALREADY_FULLY_SOLD, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
//								continue;	FOR NOW AT LEAST, CONTINUE LOOKING FOR OTHER PROBLEMS.
							}

							break;	// No point in continuing the inner loop once we've found a
									// partially-sold prescription sold at a different pharmacy.
						}
					}	// Loop through prescriptions for this drug-line.
				}	// Selling a Maccabi Doctor drug line with at least one prescription - CR #32984 Part 2 end.


				// DonR 29Jun2020 CR #29682: If the item begin sold is in one of the "special" substitution
				// groups with Group Code between 50001 and 55000 (should these be configurable?), check
				// whether the last time the member bought something from the same group was for a different
				// Largo Code *and* a different Shape Code. If so, give a warning message. (Note that we
				// compare both the last Largo Code *and* the last Shape Code - which is really redundant,
				// since comparing just the Shape Code would really be enough. I'll leave the code like
				// this, just in case someone changes their mind and wants to give the warning even if the
				// shape code *didn't* change.
				if ((MACCABI_PHARMACY)										&&
					(SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)	&&
					(SPres[i].DL.economypri_group	>= 50001)				&&
					(SPres[i].DL.economypri_group	<= 55000))
				{
					OneYearAgo = IncrementDate (SysDate, -365);

					ExecSQL	(	MAIN_DB, READ_test_for_special_substitution,
								&LastSubLargo,		&LastSubShapeCode,
								&Member.ID,			&OneYearAgo,
								&Member.ID_code,	&SPres[i].DL.economypri_group,
								END_OF_ARG_LIST										);

					if ((SQLCODE			== 0)								&&
						(LastSubLargo		!= SPres[i].DrugCode)				&&	// As noted above, this line is really redundant.
						(LastSubShapeCode	!= SPres[i].DL.shape_code_new))
					{
						// I'm assuming that this warning will never be made into a fatal error;
						// if it is, add "kiss of death" logic here.
						SetErrorVarArr (&SPres[i].DrugAnswerCode, SPECIAL_SUBSTITUTION_WARNING, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
					}
				}
				// CR #29682 end.


				// DonR 27Jan2016: Set a new flag if at least one drug in this sale request is a "treatment" type.
				// Note that we make this check before performing generic-drug substitution; it shouldn't make
				// any difference, since substitute drugs should always have the same Largo Type as their equivalents.
				if ((SPres[i].DL.largo_type	== 'B')		||
					(SPres[i].DL.largo_type	== 'M')		||
					(SPres[i].DL.largo_type	== 'T'))
				{
					ReqIncludesTreatment = 1;
				}


				// DonR 20Aug2018 CR #15804: At Maccabi pharmacies, if the Barcode Scanned status is 2
				// (item is a "treatment" and barcode was *not* scanned), send the pharmacy a message
				// that requires two pharmacist cards to be swiped. (Note that I coded this so that we're
				// ready if someone decides that this should be a critical error.)
				// DonR 17Oct2018: Oops! This test should happen only for drug sales, *not* deletions!
				// DonR 11Oct2020: Per "Feature" 96317 (by Iris Shaya), we want to send BARCODE_NOT_SCANNED_PASS_2_CARDS
				// for both BarcodeScanned == 2 *and* BarcodeScanned == 4. The other conditions are unchanged.
				if ((v_ActionType == DRUG_SALE)						&&
					(MACCABI_PHARMACY)								&&
					((SPres[i].BarcodeScanned == 2) || (SPres[i].BarcodeScanned == 4)))
				{
					if (SetErrorVarArr (&SPres[i].DrugAnswerCode, BARCODE_NOT_SCANNED_PASS_2_CARDS, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
					{
						// This will happen only if the severity of BARCODE_NOT_SCANNED_PASS_2_CARDS is increased
						// to be a "show-stopper".
						SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						continue;
					}
				}


				// DonR 11Jul2010: Calling routine is now responsible for copying health-basket parameter
				// from the DL structure to the sPres structure. This should NOT be done for deletions,
				// since in that case we've already read the computed health-basket parameter from the
				// original sale.
				// Marianna 25Feb2024 User Story #540234: NO LONG_DURATION_WARNING for cannabis sales.
				if ((v_ActionType != SALE_DELETION)	&&	(!IsCannabisSale))
				{
					SPres[i].in_health_pack		= SPres[i].DL.health_basket_new;

					// DonR 11Sep2012: Send pharmacy a warning message if the drug being sold is non-chronic
					// and the prescription date is too far in the future (based on the sale_ok_early_days
					// parameter in sysparams) OR the Duration parameter is greater than 45 days.
					// Note that the logic below allows for the possibility that this warning can later be
					// "upgraded" into a fatal error.
					// DonR 16Sep2012: Don't look at Chronic Flag; Chronic Months must be >= 3 for a
					// drug to be considered chronic.
					// DonR 07Jul2013: New "Bakara Kamutit" logic includes new controls on future sales.
					// Duration is no longer relevant.
					if ((v_ActionType == DRUG_SALE) && (SPres[i].MaxPrDate > MaxFutureDate))
					{
						// Future sale can be permitted in several different ways; proceed from the most general
						// to the most specific. (Note that SPres[i].why_future_sale_ok has an initial value of zero.)
						// For now at least, future sales are permitted only at Maccabi pharmacies except in the case
						// of a vacation ishur - but this may change in the future for members who live overseas.
						// DonR 09Oct2018 CR #26700: Pharmacies are now authorized to sell future-dated prescriptions
						// based on a new flag, can_sell_future_rx, in the Pharmacy table.
						if (CAN_SELL_FUTURE_RX)
						{
							if ((SPres[i].DL.allow_future_sales == FUTURE_SALE_MAC_ONLY)	||
								(SPres[i].DL.allow_future_sales == FUTURE_SALE_ALL_PHARM))
							{
								SPres[i].why_future_sale_ok = (SPres[i].DL.allow_future_sales == FUTURE_SALE_ALL_PHARM) ?
																FUT_PERMITTED_ALL_PHARM : FUT_PERMITTED_MACCABI;
							}	// Future sale permitted by drug_list allow_future_sales flag.
							else
							{
								// Members who live overseas can fill future-dated prescriptions at Maccabi pharmacies.
								if (OVERSEAS_MEMBER)
									SPres[i].why_future_sale_ok = FUT_PERMITTED_OVRSEAS;
							}	// Future-dated sales of this drug are not normally permitted.
						}	// Sale at Maccabi pharmacy (or other pharmacy with can_sell_future_rx set non-zero).

						// Vacation ishurim allow future sales at all pharmacies.
						if ((SPres[i].why_future_sale_ok == 0) && (Member.Has_PL_99997_Ishur))
							SPres[i].why_future_sale_ok = FUT_PERMITTED_ISHUR;

						if (SPres[i].why_future_sale_ok == 0)
						{
							// DonR 15Sep2020 CR #30106: If the drug being sold is one that allows future sales only
							// after an initial purchase - and an initial purchase was not found - we want to return
							// a different error code than the usual one: ERR_FUTURE_SALE_NOT_YET_QUALIFIED. Note that
							// while this error may not be "fatal", an attempt to sell more than one month's worth in
							// this case will also (presumably) trigger a "bakara kamutit" error.
							if (SetErrorVarArr (	&SPres[i].DrugAnswerCode,
													(SPres[i].DL.allow_future_sales == FUTURE_SALE_NOT_YET_QUALIFIED) ? ERR_FUTURE_SALE_NOT_YET_QUALIFIED : ERR_PR_DATE_IN_FUTURE,
													v_DrugCode,
													i + 1,
													&SPres[i].DFatalErr,
													&ErrOverflow))
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							}	// Error is fatal.
						}	// Future sale is NOT approved!
					}	// Future drug sale.

					// DonR 01Oct2020 CR #30106: If this is the first sale of a drug that requires previous sales to
					// enable future sales, and the member is buying only what s/he is allowed to buy, send a warning
					// message to pharmacy.
					// DonR 11Oct2020: Do not send this message if the member lives overseas or has a vacation ishur.
					// Don't send if for non-prescription sales either - nobody mentioned that, but it seems sensible.
					else	// NOT a future drug sale.
					{
						if ((v_ActionType == DRUG_SALE)											&&
							(SPres[i].DL.allow_future_sales == FUTURE_SALE_NOT_YET_QUALIFIED)	&&
							(SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)				&&	// DonR 11Oct2020.
							(!Member.Has_PL_99997_Ishur)										&&	// DonR 11Oct2020.
							(!(OVERSEAS_MEMBER))												&&	// DonR 11Oct2020.
							FirstPurchaseOfDrug														)
						{
							SetErrorVarArr (&SPres[i].DrugAnswerCode, WARN_FUTURE_SALE_NOT_YET_QUALIFIED, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
						}
					}


					// DonR 21May2014: Add new warning message for Duration > 45 days.
					// DonR 16Jun2014: This warning doesn't apply if member has a vacation ishur.
					// DonR 09Oct2018 CR #26700: Pharmacies are now authorized to sell future-dated prescriptions
					// based on a new flag, can_sell_future_rx, in the Pharmacy table. Accordingly, it seems
					// sensible to send these pharmacies the same long-duration warning that Maccabi pharmacies get.
					if ((v_ActionType					== DRUG_SALE)						&&
						(SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)				&&
						(SPres[i].Duration				>  45)								&&
						(SPres[i].DL.allow_future_sales	== FUTURE_SALE_FORBIDDEN)			&&
						(CAN_SELL_FUTURE_RX)												&&
						(!Member.Has_PL_99997_Ishur)										&&
						(!(OVERSEAS_MEMBER))												&&
						(!(SetErrorVarExists (ERR_PR_DATE_IN_FUTURE, SPres[i].DrugCode))))
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, LONG_DURATION_WARNING, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						}
					}	// Applicable long-duration drug sale.

				}	// Current operation is not a deletion OR a cannabis sale.


				// Compute ingredient usage for Ishur Limit checking - and possibly, eventually,
				// for ingredient-based Overdose/Interaction checking.
				for (ingred = 0; ingred < 3; ingred++)
				{
					if ((SPres[i].DL.Ingredient[ingred].code		<  1)	||
						(SPres[i].DL.Ingredient[ingred].quantity	<= 0.0)	||
						(SPres[i].DL.Ingredient[ingred].per_quant	<= 0.0)	||
						(SPres[i].DL.package_size					<  1))
					{
						// Invalid values - set this slot to zero.
						SPres[i].DL.Ingredient	[ingred].code		= 0;
						SPres[i].DL.Ingredient	[ingred].quantity	= 0.0;
						SPres[i].TotIngrQuantity[ingred]			= 0.0;
						SPres[i].IngrQuantityStd[ingred]			= 0.0;
					}

					else
					{
						if (SPres[i].DL.package_size == 1)
						{
							// Syrups and similar drugs.
							SPres[i].TotIngrQuantity[ingred] =	  (double)SPres[i].Op
																* SPres[i].DL.package_volume
																* SPres[i].DL.Ingredient[ingred].quantity
																/ SPres[i].DL.Ingredient[ingred].per_quant;
							SPres[i].IngrQuantityStd[ingred] =	  (double)SPres[i].Op
																* SPres[i].DL.package_volume
																* SPres[i].DL.Ingredient[ingred].quantity_std
																/ SPres[i].DL.Ingredient[ingred].per_quant;
						}

						else	// Package size > 1.
						{
							// Tablets, ampules, and similar drugs.
							// For these medications, ingredient is always given per unit.
							UnitsSold	=	  (SPres[i].Op		* SPres[i].DL.package_size)
											+  SPres[i].Units;

							SPres[i].TotIngrQuantity[ingred] =   SPres[i].DL.Ingredient[ingred].quantity
															   * (double)UnitsSold;
							SPres[i].IngrQuantityStd[ingred] =   SPres[i].DL.Ingredient[ingred].quantity_std
															   * (double)UnitsSold;
						}
					}	// Valid quantity values available.
				}	// Loop through ingredients for this drug.

				// Set flag for member if at least one item to be bought is "Mazon im Tikra".
				// DonR 11Feb2025 User Story #376480: Only a value of 1 for tikrat_mazon_flag indicates member
				// is buying a relevant food/supplement. Now a value of 2 indicates that the drug is a fertility
				// treatment (LH/FSH) that may be eligible for a new category of monthly tikra discount.
				if (SPres[i].DL.tikrat_mazon_flag == 1)
					MemberBuyingTikMazon = true;

				// DonR 12Feb2025 User Story #376480: All drugs involved in the new monthly LH/FSH tikra
				// feature *should* have the same value for tikrat_piryon_pharm_type - but it's best to
				// be a little paranoid and allow for the possibility that there may in future be some
				// drugs that get this tikra at different categories of pharmacy. So we need to use two
				// different boolean variables: CheckThisDrugPiryonTikra tells us whether the current
				// drug line qualifies for this tikra, while CheckMonthlyPiryonTikra tells us whether any
				// drug in the current sale request qualifies.
				if (SPres[i].DL.tikrat_mazon_flag == 2)
				{
					MemberBuyingLH_FSH			=	true;
					CheckThisDrugPiryonTikra	=	(	((SPres[i].DL.tikrat_piryon_pharm_type == 0) && PRIVATE_PHARMACY	) ||
														((SPres[i].DL.tikrat_piryon_pharm_type == 1) && MACCABI_PHARMACY	) ||
														( SPres[i].DL.tikrat_piryon_pharm_type == 2							) ||
														((SPres[i].DL.tikrat_piryon_pharm_type == 6) && MACCABI_PHARMACY	) ||
														((SPres[i].DL.tikrat_piryon_pharm_type == 6) && PRATI_PLUS_PHARMACY	)	);
				}
				else
				{
					CheckThisDrugPiryonTikra	=	false;
				}

				// DonR 11Feb2025 User Story #376480: Instead of sending Nihul Tikrot the value in
				// drug_list/tikrat_mazon_flag, we need to send zero (actually sent as a space) when
				// tikrat_mazon_flag == 2 but the requesting pharmacy does not qualify for tikrot on
				// LH/FSH fertility drugs. We support this by creating a new structure element,
				// SPres[i].TikratMazonFlagSend. Note that we need to use DL.tikrat_mazon_flag in this
				// condition, since we need to qualify each drug line based on its own criteria!
				SPres[i].TikratMazonFlagSend =
					((SPres[i].DL.tikrat_mazon_flag == 1) || CheckThisDrugPiryonTikra) ? SPres[i].DL.tikrat_mazon_flag : 0;

				// If *any* drug qualifies for the monthly LH/FSH tikra, set the need-to-check flag TRUE.
				CheckMonthlyPiryonTikra = (CheckMonthlyPiryonTikra || CheckThisDrugPiryonTikra);

		    }	// Drug reading/preliminary processing loop.


		    if ((reStart == MAC_TRUE) || (v_ErrorCode == ERR_DATABASE_ERROR))
		    {
				break;
			}


			// DonR 09Jun2010: Second drug loop, to handle Drug Purchase Limits and other processing.
			// This loop (along with the next ones, dealing with supplements and participation) is
			// relevant only for drug sales! For deletions, we skip approximately 1,900 lines of code
			// here!
			if (v_ActionType != SALE_DELETION)
			{
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					v_DrugCode = SPres[i].DrugCode;

					// DonR 25Apr2023 User Story #432608: Check for appropriate use of the "Consignment Sale" flag.
					ErrorCodeToAssign = 0;

					if (CONSIGNMENT_PHARMACY)
					{
						// If this is a consignment item at a consignment pharmacy, the pharmacy *must* sell it that way.
						if (SPres[i].DL.ConsignmentItem == CONSIGNMENT_ITEM)
						{
							if (SPres[i].IsConsignment)
							{
								// DonR 30Jul2023 User Story #468171: Make a "note" that this is a valid consignment
								// sale, so we'll remember to send pharmacy zero for Supplier Drug Price.
								SPres[i].ValidConsignmentSale = 1;
							}
							else
							{
								ErrorCodeToAssign = THIS_IS_A_CONSIGNMENT_ITEM;
							}
						}	// The item being sold is flagged as available for consignment sales.
						else
						{
							// If this is not a consignment item, the pharmacy *can't* sell it on consignment.
							if (SPres[i].IsConsignment)
							{
								ErrorCodeToAssign = THIS_IS_NOT_A_CONSIGNMENT_ITEM;
							}
						}	// The item being sold is NOT flagged as available for consignment sales.
					}
					else	// Not a consignment pharmacy.
					{
						if (SPres[i].IsConsignment)
						{
							ErrorCodeToAssign = NOT_A_CONSIGNMENT_PHARMACY;
						}
					}

					if (ErrorCodeToAssign)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ErrorCodeToAssign, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						}

						ErrorCodeToAssign = 0;	// Probably not necessary, but cleanliness is next to godliness. Or at least it's next to OCD...
					}
					// DonR 25Apr2023 User Story #432608: End of check for appropriate use of the "Consignment Sale" flag.


					// DonR 29Jun2006: If this drug has a Drug Purchase Limit, attempt to read
					// the relevant fields from the drug_purchase_lim table and store them.
					if (SPres[i].DL.purchase_limit_flg > 0)
					{
						// DonR 26May2010 "Stickim": read previously-purchased drugs now, so we'll
						// be able to categorize member for new drug-purchase-limit logic based on
						// his/her previous drug purchases.
						if (get_drugs_in_blood (&Member,
												&v_DrugsBuf,
												GET_ALL_DRUGS_BOUGHT,
												&v_ErrorCode,
												&reStart)				== 1)
						{
							break;
						}	// high severity error OR deadlock occurred


						// DonR 01Dec2016: New function ReadDrugPurchaseLimitData() replaces separate code in Transactions
						// 2003, 5003, and 6003, and adds new functionality to support ingredient-based purchase limits.
						FunctionError = ReadDrugPurchaseLimitData (&Member, SPres, i, v_NumOfDrugLinesRecs, &v_DrugsBuf, NULL, &v_ErrorCode, &reStart);
					}	// Drug has a Drug Purchase Limit.


					// Logical tests on drug.
					// 1. Prescription drug sold w/o prescription.
					if ((SPres[i].PrescSource			== RECIP_SRC_NO_PRESC) &&
						(SPres[i].DL.no_presc_sale_flag	== MAC_FALS))
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DRUG_REQUIRE_PRESCRIPTION, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
//							continue;
						}
					}	// Drug Test 1 - presc. drug sold w/o prescription.

					// 2. DonR 09Jun2005: If this is a non-prescription purchase from a private pharmacy,
					// either the drug must have its MaccabiCare flag set true (meaning it's a
					// Maccabi-branded OTC drug) OR the pharmacy must have sent a Maccabi Sale Number
					// (which is sent and stored in the Doctor Prescription ID field). If neither of
					// these conditions is met, the pharmacy should never have sent us this drug-line.
					// DonR 25May2015: I believe that the business of sending a Maccabi Sale Number in
					// place of the Doctor Prescription ID is no longer applicable; certainly it isn't
					// mentioned in the "Mersham Digitali" specification. Thus I'm deleting that bit
					// of logic.
					if ((SPres[i].PrescSource			== RECIP_SRC_NO_PRESC)	&&
						(PRIVATE_PHARMACY)										&&
						(SPres[i].DL.maccabicare_flag	== 0))
//						(DocRx [SPres[i].FirstRx].PrID	== 0))
//						(PR_DoctorPrID[i]				== 0))
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_NOT_MACCABICARE_DRUG, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
//							continue;
						}
					}

					
					// DonR 21Nov2017 CR #13341: If the item being sold is not in the same generic-substitution group
					// as the drug prescribed by the doctor, the sale is forbidden - except in specific circumstances:
					//
					// 1) The pharmacy is a Maccabi pharmacy.
					// 2) Both items are "treatment" drugs (Type M or T).
					// 3) The pharmacy has specified that the substitute drug is being sold because other options are out of stock.
					// 4) Both drugs have the same principal (first) active ingredient (and that ingredient's code is non-zero).
					//
					// (Note that if the pharmacy didn't supply a valid prescribed drug, we don't check further!)
					// DonR 08Apr2018: Added new parameter to read_drug() to enable reading logically-deleted drugs
					// when we're performing a sale deletion. In this case, we're selling drugs - so we don't want to
					// "see" deleted drugs, and the parameter is set FALSE.
					// DonR 01Nov2020: This is the only call to read_drug() I see that doesn't have any error logging.
					// We're probably OK, since if there's any problem with the SQL code or the database, we'll catch
					// errors elsewhere - but if we see any problems come up here, we'll have to switch things around
					// so we can catch and log errors for this call as well.
					if ((PR_Original_Largo_Code[i]	!= SPres[i].DrugCode)					&&
						(PR_Original_Largo_Code[i]	>  0)									&&
						(read_drug (PR_Original_Largo_Code[i], 9999999, NULL, false, &DL_prescribed, NULL)))
					{
						// If the two drugs are in the same (non-zero) generic substitution group, there's no problem.
						// Only if they're *not* in the same group do we need to look further.
						// DonR 15Aug2018: If both the sold item and the prescribed item have Preferred Flag = 8 (which means
						// that they are not "treatment" drugs), we want to allow substitution without any restrictions.
						if (((SPres[i].DL.economypri_group != DL_prescribed.economypri_group)	||	(SPres[i].DL.economypri_group <  1))	&&
							((SPres[i].DL.preferred_flg != 8) || (DL_prescribed.preferred_flg != 8)))
						{
							// If we get here, the pharmacy is indeed selling something different from the prescribed drug,
							// and it's *not* a normally-valid generic substitute. Check further to see whether this is a
							// critical problem (which will block the sale), or a permitted substitution that will generate
							// a "pharmacist must pass card" warning message.
							// Note that for now, the Reason Code OUT_OF_STOCK_SUPPLIER (= 7) is not in use; if it is decided
							// to enable this one as well, it will have to be added to the "if" below.
							// Note also that pharmacies *are* allowed to substitute a Type 'M' drug for a type 'T' drug
							// or vice versa, as long as all the other conditions (including having the same main ingredient)
							// are met.
							if ((PRIVATE_PHARMACY)																											||
								(PR_WhyNonPreferredSold[i]					!= OUT_OF_STOCK_SUB_OTHER			)											||
								((SPres[i].DL.largo_type					!= 'M'								) && (SPres[i].DL.largo_type	!= 'T'))	||
								((DL_prescribed.largo_type					!= 'M'								) && (DL_prescribed.largo_type	!= 'T'))	||	// NOTE: DISABLE THIS...
//								( SPres[i].DL.largo_type					!= DL_prescribed.largo_type			)											||	// ... OR THIS.
								( SPres[i].DL.Ingredient[0].code			<  1								)	/* Must be a real ingredient!	*/		||
								( SPres[i].DL.Ingredient[0].quantity_std	<= 0.0								)	/* With a real amount...		*/		||
								( DL_prescribed.Ingredient[0].quantity_std	<= 0.0								)	/* ...for both drugs			*/		||
								( SPres[i].DL.Ingredient[0].code			!= DL_prescribed.Ingredient[0].code	))
							{
								// This is *not* a valid substitution! Send pharmacy a critical error and block the sale.
								if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DISALLOWED_SUBSTITUTION, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
								}
							}
							else
							{
								// If pharmacy is making a "special" substitution, we need to compare the amount of the main active ingredient being sold
								// to the amount prescribed and unsold. This means we need to read the original doctor prescription.
								PW_DoctorPrID		= DocRx [SPres[i].FirstRx].PrID;
								DocID				= DocRx [SPres[i].FirstRx].DocID;
								PW_Doc_Largo_Code	= PR_Original_Largo_Code[i];

								ExecSQL (	MAIN_DB, TR6003_READ_ValidateSpecialDrugSubstitution,
											&DRX_QtyMethod,				&DRX_Rx_OP,			&DRX_Rx_TotUnits,
											&DRX_SoldOP,				&DRX_SoldUnits,
											&v_MemberIdentification,	&PW_DoctorPrID,
											&EarliestPrescrDate,		&LatestPrescrDate,
											&PW_Doc_Largo_Code,			&DocID,
											&v_IdentificationCode,		END_OF_ARG_LIST							);

								// For the moment, no special handling for row-not-found errors. It's possible that
								// we'll need to add it in future.
								if (SQLCODE != 0)
								{
									if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
									{
										GerrLogMini (GerrId, "TR6003_READ_ValidateSpecialDrugSubstitution couldn't find Member %d Doctor %d Rx %d Largo %d min from-date %d.",
													 v_MemberIdentification, DocID, PW_DoctorPrID, PW_Doc_Largo_Code, EarliestPrescrDate);
									}
									else
									{
										SQLERR_error_test ();
									}

									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								}	// TR6003_READ_ValidateSpecialDrugSubstitution did not succeed.

								// If we were able to read the doctor prescription, calculate ingredient stuff and see if
								// the substitution is allowed.
								else
								{
									// Calculate ingredient quantity for the original presription.
									// Depending on how the drug was prescribed, we want to use either the original
									// OP value or the original total-units value - but not both!
									if ((DRX_QtyMethod == 1) || (DL_prescribed.calc_op_by_volume > 0))
										DRX_Rx_TotUnits	= 0;	// Doctor specified OP - so ignore units.
									else
										DRX_Rx_OP		= 0;	// Doctor did not specify OP - so use units and ignore OP.

									UnitsPrescribed		= (DRX_Rx_OP	* DL_prescribed.effective_package_size) + DRX_Rx_TotUnits;
									UnitsAlreadySold	= (DRX_SoldOP	* DL_prescribed.effective_package_size) + DRX_SoldUnits;

									// Units Sellable *should* always be greater than zero, since otherwise pharmacy would
									// not be trying to sell against the prescription.
									UnitsSellable		= (UnitsAlreadySold > UnitsPrescribed) ? 0 : UnitsPrescribed - UnitsAlreadySold;
									// GerrLogMini (GerrId, "UnitsPrescribed = %d, UnitsAlreadySold = %d, UnitsSellable = %d.", UnitsPrescribed, UnitsAlreadySold, UnitsSellable);

									if (DL_prescribed.effective_package_size == 1)
									{
										// This should never happen, but just in case - avoid division by zero.
										if (DL_prescribed.Ingredient[0].per_quant == 0)
											DL_prescribed.Ingredient[0].per_quant = 1;

										IngredSellable =	  (double)UnitsSellable
															* DL_prescribed.package_volume
															* DL_prescribed.Ingredient[0].quantity_std
															/ DL_prescribed.Ingredient[0].per_quant;
									}
									else
									{
										IngredSellable = (double)UnitsSellable * DL_prescribed.Ingredient[0].quantity_std;
									}

									// Now calculate the ingredient usage for the current purchase.
									UnitsSoldNow	= (SPres[i].Op * SPres[i].DL.effective_package_size) + SPres[i].Units;

									if (SPres[i].DL.effective_package_size == 1)
									{
										// This should never happen, but just in case - avoid division by zero.
										if (SPres[i].DL.Ingredient[0].per_quant == 0)
											SPres[i].DL.Ingredient[0].per_quant = 1;

										IngredSoldNow =		(double)UnitsSoldNow
															* SPres[i].DL.package_volume
															* SPres[i].DL.Ingredient[0].quantity_std
															/ SPres[i].DL.Ingredient[0].per_quant;
									}
									else
									{
										IngredSoldNow =		(double)UnitsSoldNow * SPres[i].DL.Ingredient[0].quantity_std;
									}

									// Finally, compare the sellable amount of the active ingredient according to the
									// prescription to the amount of the ingredient being sold now. The maximum ratio
									// is stored in IngrSubstMaxRatio, which is loaded from the SysParams table.
									// DonR 23Aug2018: Per Iris Shaya and Raya Karol, we don't want to generate an
									// "excessive substitution" error if the drug being sold comes in un-openable
									// packages and only one package is being sold.
									if ((IngredSoldNow > (IngredSellable * IngrSubstMaxRatio))		&&
										((SPres[i].DL.openable_pkg) || ((SPres[i].Op + SPres[i].Units) > 1)))
									{
										if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_EXCESSIVE_INGR_SUBSTITUTION, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
										{
											SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
										}
									}
									else
									{
										// This is a valid substitution - but the pharmacy still needs to see a message and
										// specifically authorize the sale.
										SetErrorVarArr (&SPres[i].DrugAnswerCode, WARN_INGR_BASED_SUBSTITUTION, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
										SPres[i].WhyNonPreferredSold = INGR_BASED_SUBSTITUTION;
									}

								}	// Successful read of doctor prescription.

							}	// The "special" substitution wasn't rejected out-of-hand, so we needed to check against the original prescription.

						}	// The drug being sold is not in the same (non-zero) generic-substitution group as the drug prescribed,
							// and one or both drugs have a Preferred Status other than 8.

					}	// Treatment drug sold is different from (non-zero, valid) drug prescribed.


					// DonR 03Feb2004: Use separate function to find preferred (generic) drug.
					// DonR 14APR2003: Per Iris Shaya - if a non-preferred drug is being sold for
					// a reason (e.g. "dispense as written" or pharmacy is out of preferred drug),
					// member participates as if s/he were being given the preferred drug.
					// DonR 13Jan2005: Moved this block of code down to after drug_list is
					// read, so that we know beforehand whether the drug is in economypri.
					// Also, note that find_preferred_drug now looks up the Member Price Code
					// of the preferred drug, if any.
					find_preferred_drug (SPres[i].DrugCode,
										 SPres[i].DL.economypri_group,
										 SPres[i].DL.preferred_flg,
										 SPres[i].DL.preferred_largo,
										 0, // No need to check purchase history for alternate preferred drugs.
										 0,	// Allow drugs with Preferred Status = 3 to be sold without requiring an explanation from pharmacy.
										 SPres[i].DocID,
										 v_MemberIdentification,
										 v_IdentificationCode,
										 &EP_LargoCode,
										 &PR_AsIf_Preferred_SpDrug	[i],
										 &PR_AsIf_ParentGroupCode	[i],
										 &preferred_mbr_prc_code	[i],
										 &DispenseAsWritten,
										 &PR_AsIf_Preferred_Basket	[i],
										 &PR_AsIf_RuleStatus		[i],
										 NULL,	// DL structure pointer
										 &FunctionError);

					SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);

					// Check if the drug to be sold is the one Maccabi wants to sell. If not, send
					// a warning message to the pharmacy.
					if (EP_LargoCode != SPres[i].DrugCode)
					{
						// If the pharmacist has a reason for selling a drug other
						// than the "preferred" one, store the preferred drug's Largo Code
						// for later use in checking member's participation level. Otherwise,
						// return a "Not Preferred Drug" warning code.
						//
						// DonR 28Mar2010: Changed handling of reason sent by pharmacy; instead of
						// excluding NO_REASON_GIVEN and DISPENSED_KACHA (= 0 and 99), now we
						// *include* only OUT_OF_STOCK_SUB_EQUIV and EXCESS_STOCK (= 2 and 3).
						// DOCTOR_NIXED_SUBSTITUTION (= 1) and any other strange value will *not*
						// allow sale of non-preferred drugs at preferred prices.
						if ((PR_WhyNonPreferredSold[i] == OUT_OF_STOCK_SUB_EQUIV	)	||
							(PR_WhyNonPreferredSold[i] == EXCESS_STOCK				)	||
							(DispenseAsWritten))
						{
							// Non-substitution is legitimate.
							PR_AsIf_Preferred_Largo[i] = EP_LargoCode;

							// DonR 14Jan2009: Give the AS/400 a record of why we gave "as-if-preferred"
							// participation.
							// DonR 28Mar2010: Give a separate reason-code if participation was granted
							// based on a "tofes" that expired within the last 91 days.
							// DonR 20Dec2011: If a private pharmacy is selling a non-generic medicine because
							// the generic version is out of stock, send a warning message. Note that if the
							// doctor has nixed substitution anyway, there's no need to send this message - so
							// we execute this logic only for DispenseAsWritten == 0.
							switch (DispenseAsWritten)
							{
								case 0:		SPres[i].WhyNonPreferredSold = PHARM_AUTH_NON_GENERIC;

											if ((PRIVATE_PHARMACY)											&&
												(SPres[i].PrescSource		!= RECIP_SRC_NO_PRESC		)	&&
												(PR_WhyNonPreferredSold[i]	== OUT_OF_STOCK_SUB_EQUIV	))
											{
												SetErrorVarArr (&SPres[i].DrugAnswerCode,
																ERR_OUT_OF_STOCK_WARN,
																SPres[i].DrugCode, i + 1, 
																NULL,
																&ErrOverflow);
											}
											break;

								case 1:		SPres[i].WhyNonPreferredSold = DOC_AUTH_NON_GENERIC;
											break;

								case 2:		SPres[i].WhyNonPreferredSold = DOC_AUTH_EXPIRED_TOFES;
											break;

								// Default condition should never really happen - but just in case...!
								default:	SPres[i].WhyNonPreferredSold = PHARM_AUTH_NON_GENERIC;	break;
							}
						}
						else
						{
							PR_AsIf_Preferred_Largo [i] = 0;	// Disable preferred-drug swapping - redundant, but paranoia is good!

							// If we're not going to use an "as-if-preferred" drug, zero
							// out the "as-if-preferred in-health-basket" parameter.
							PR_AsIf_Preferred_Basket[i] = 0;

							// DonR 14Jan2009: Give the AS/400 a record of the fact that a non-preferred
							// drug was sold without using "as-if-preferred" conditions.
							SPres[i].WhyNonPreferredSold = NON_GENERIC_SOLD_AS_IS;

							// 22Dec2003: Per Iris Shaya, non-preferred drug warning is given only if the
							// non-preferred drug is being dispensed without any indication that the
							// pharmacist is aware of the problem. If the pharmacist gives the Reason Code
							// 99 ("kacha"), no "acceptable" reason for the substitution is being offered,
							// but the pharmacist is already aware of the situation and doesn't need a message.
							// DonR 08Mar2006: Per Iris Shaya, if the drug's preferred_flg is 2, don't give
							// a warning.
							// DonR 28Mar2010: If pharmacy sent reason 1 (DOCTOR_NIXED_SUBSTITUTION) but
							// there is no valid doctor's ishur for dispensing the prescription as written,
							// give pharmacy a new, severe error message telling them so.
							// DonR 23Mar2015: Don't give an error if the drug being sold is, in fact, preferred.
							// This can happen when member bought Preferred Drug X last time but (for whatever
							// reason) is buying Preferred Drug Y this time.
							if (((PR_WhyNonPreferredSold[i]	== NO_REASON_GIVEN)				||
								 (PR_WhyNonPreferredSold[i]	== DOCTOR_NIXED_SUBSTITUTION))		&&
								(SPres[i].DL.preferred_flg	!= 1)								&&	// DonR 23Mar2015.
								(SPres[i].DL.preferred_flg	!= 2)								&&
								(SPres[i].PrescSource		!= RECIP_SRC_NO_PRESC))
							{
								// DonR 09May2010 HOT FIX: Use new non-critical error code so that we
								// don't give up on this drug yet; it's possible member has an AS/400
								// ishur for the non-generic drug, in which case we'll use that and
								// suppress the non-critical error. If there isn't an AS/400 ishur
								// applicable, we'll replace the non-critical error with the "real"
								// critical error later on.
								SetErrorVarArr (&SPres[i].DrugAnswerCode,
												(PR_WhyNonPreferredSold[i] == DOCTOR_NIXED_SUBSTITUTION) ?
														ERR_NO_DOCTORS_ISHUR_WARN :
														ERR_NOT_PREFERRED_DRUG_WARNING,
												SPres[i].DrugCode, i + 1, 
												NULL,
												&ErrOverflow);
							}

						}	// No reason given for dispensing non-preferred drug.
					}	// Drug being sold isn't the preferred one.

					else
					// No preferred drug found - zero appropriate variables.
					{
						preferred_mbr_prc_code  [i]		= 0;
						PR_AsIf_Preferred_SpDrug[i]		= 0;
						PR_AsIf_Preferred_Basket[i]		= 0;
						PR_AsIf_ParentGroupCode	[i]		= 0;
						PR_AsIf_RuleStatus		[i]		= 0;
						PR_AsIf_Preferred_Largo [i]		= 0;	// Disable preferred-drug swapping.
						SPres[i].WhyNonPreferredSold	= 0;	// DonR 14Jan2009: shouldn't really be necessary.
					}
					// DonR 13Jan2005 end.


					// Set up pricing defaults.
					SPres[i].ret_part_source.table			= FROM_DRUG_LIST_TBL;
					SPres[i].ret_part_source.insurance_used	= BASIC_INS_USED;

					// Previous Member Price Code is not used for Electronic Prescriptions!
					// DonR 16May2006: Kishon Divers (who are supposed to get their medications
					// direct from the government) pay 100% unconditionally.
					// DonR 09Aug2021 User Story #163882: Treat darkonaim-plus people who always
					// pay 100% (minus shovarim they get from their insurance company) the same
					// as Kishon divers.
					// Marianna 22Feb2024 User Story #540234 Cannabis Sale - 100% hishtatfut 
					if ((v_IdentificationCode == 3)			||	// Kishon divers.
						(Member.force_100_percent_ptn)		||	// Darkonaim-plus not getting any discounts.
						(IsCannabisSale)					||	// Marianna 22Feb2024 User Story #540234
						(SPres[i].LargoBlockedForMember))		// DonR 17Oct2021 User Story #196891 - add per-Largo purchase blocks.
					{
						SPres[i].BasePartCode				= PARTI_CODE_ONE;
						SPres[i].RetPartCode				= PARTI_CODE_ONE;
						SPres[i].part_for_discount			= PARTI_CODE_ONE;

						// DonR 09Sep2021 "Darkonaim-Plus": If this member is paying 100% for everything, force
						// "in health basket" FALSE. I'm applying this for Kishon divers as well as Darkonaim -
						// it makes sense, and in any case we don't appear to have any of them any more.
						SPres[i].in_health_pack				= 0;
					}
					else	// Normal members.
					{
						SPres[i].BasePartCode				= SPres[i].DL.member_price_code;
						SPres[i].RetPartCode				= SPres[i].DL.member_price_code;
						SPres[i].part_for_discount			= SPres[i].DL.member_price_code;
					}

					SPres[i].BasePartCodeFrom			= CURR_CODE;
					SPres[i].ret_part_source.state		= CURR_CODE;

				}	// Loop through drugs.


				if ((reStart == MAC_TRUE) || (v_ErrorCode == ERR_DATABASE_ERROR))
				{
					break;
				}


				// DonR 06Dec2010: Adding new "preparation" consistency test. Preparations should be handled
				// by a single Transaction 6003, and every item in the sale must be part of the preparation.
				// Keep track of the LinkDrugToAddition parameter for the first drug; everything else in
				// the list should agree with it. If the first drug is part of a preparation, everything
				// else should be as well; and if not, nothing else should be. If the Link field is being
				// used for a Gadget Code, treat it as zero for this purpose.
				PreparationLinkLargo = (SPres[0].DL.in_gadget_table > 0) ? 0 : SPres[0].LinkDrugToAddition;

				// DonR 24Dec2013: Additional "preparation" consistency checks. If this sale is a preparation,
				// there *must* be a non-zero Chemical Price; and if there is a non-zero Chemical Price the
				// sale *must* be a "preparation". Note (A) that negative Chemical Price is allowed, and
				// (B) we already check consistency of other items in the same sale. Also, if this is a
				// "preparation" sale, there *must* be more than one item in the sale. (Otherwise there isn't
				// anything to "prepare", after all...
				if (((PreparationLinkLargo != 0) && (ChemicalPrice == 0))			||
					((PreparationLinkLargo == 0) && (ChemicalPrice != 0))			||
					((PreparationLinkLargo != 0) && (v_NumOfDrugLinesRecs < 2)))
				{
					SetErrorVarArr (&v_ErrorCode, ERR_PREPARATION_INCONSISTENT, 0, 0, NULL, &ErrOverflow);
				}

				// Drugs SUPPLEMENTs test.
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// DonR 06Dec2010: New "preparation" consistency test. Compare the link for each drug
					// against the link for the first drug; any inconsistency means the whole transaction
					// is invalid.
					TestLinkLargo = (SPres[i].DL.in_gadget_table > 0) ? 0 : SPres[i].LinkDrugToAddition;
					if (TestLinkLargo != PreparationLinkLargo)
					{
						SetErrorVarArr (&v_ErrorCode, ERR_PREPARATION_INCONSISTENT, 0, 0, NULL, &ErrOverflow);
					}

					// Skip this drug if one of the following is true:
					// 1. There's no supplement link - meaning that drug[i] isn't a supplement.
					// 2. It's a Package or Preparation type drug.
					// 3. We've already hit a severe error for this drug.

					// DonR 22Dec2003: Per Iris Shaya, bottles (Largo Type 'A') should be treated like other
					// parts of the preparation - that is, they get the same Participation Code as the
					// Preparation (Largo Type 'X', the 'major drug') itself.
					// DonR 23Aug2005: For "gadgets", LinkDrugToAddition is used optionally to indicate
					// the "gadget code" - e.g. in order to differentiate between knee braces sold for
					// use on the right knee as opposed to identical braces sold for the left knee.
					// Thus, if the "drug" is a gadget, skip the drug-supplement stuff.
					if ((SPres[i].LinkDrugToAddition	== 0)			||
						(SPres[i].DL.in_gadget_table	>  0)			||
						(SPres[i].DL.largo_type			== 'X')			||
						(SPres[i].DFatalErr				== MAC_TRUE))
					{
						continue;
					}

					flg = MAC_FALS;		// Major drug found flag.

					// Loop through the other drugs in the prescription, searching for the major
					// drug to which drug[i] is linked.
					for (is = 0; is < v_NumOfDrugLinesRecs; is++)
					{
						// Skip past drug[i] - we don't want to compare it to itself!
						if (is == i)
							continue;

						// If this drug isn't the one that drug[i] links to, skip it.
						if (SPres[is].DrugCode != SPres[i].LinkDrugToAddition)
							continue;

						flg = MAC_TRUE;	// Major drug found for supplemental drug[i].
						MajorDrugIndex[i] = is;

						// If the major drug is a Preparation (type 'X'), skip
						// the linkage and quantity tests.
						if (SPres[is].DL.largo_type != 'X')
						{
							// If drug[i] isn't recognized as a supplement to drug[is], set error.
							// DonR 10Jun2014: Per Iris Shaya, give an error only if the major drug's
							// type is neither X nor C; also, change the error given from 6013 to 6057.
							if ((SPres[i].DrugCode != SPres[is].DL.supplemental_1) &&
								(SPres[i].DrugCode != SPres[is].DL.supplemental_2) &&
								(SPres[i].DrugCode != SPres[is].DL.supplemental_3) &&
								(SPres[is].DL.largo_type != 'C'))
							{
								if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_PREPARATION_INCONSISTENT,
													SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
								}
							}	// Drug[i] isn't valid supplement to drug[is].

							else
							{
								// The supplement is the right stuff. Now match quantity
								// of supplement to that of the major drug.
								if (SPres[i].Op > (((SPres[is].Units > 0) ? 1 : 0 ) + SPres[is].Op))
								{
									// More packages of supplement than of major drug.
									if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_SUPPL_OP_NOT_MATCH_DRUG_OP,
														SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
									{
										SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
									}
								}	// Too much of drug[i] to supplement quantity of drug[is].
							}	// Drug[i] is a valid supplement to drug[is].
						}	// The major drug[is] is not a Preparation (type 'X').


						// We've found the major drug and performed our tests - so we can quit
						// the inner loop.
						break;
					}	// Loop on [is] to find Major drug for supplemental drug[i].


					// If no major drug was found for supplemental drug[i], set error.
					// DonR 24Dec2013: If the reason that the major drug wasn't found was that there is only
					// one drug in the sale, we're now returning error 6057 (Preparation Inconsistent) - so
					// we don't have to return additional errors.
					// DonR 09Jun2014: Per Iris Shaya, changed the error code for this test from 6013 to 6057.
					if ((flg == MAC_FALS) && (v_NumOfDrugLinesRecs > 1))
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_PREPARATION_INCONSISTENT,
											SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							break;
						}
					}
				}	// Loop through drugs to perform supplement-drug tests.


				// Get Drug prices and check for Special Prescriptions in the DB.
				// DonR 06Nov2011: By default, trigger that enables the "Member in hospital"
				// warning message for pharmacies is set FALSE.
				DrugPriceMemHospTrigger	= 0;
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// Skip drugs for which we've already discovered a major error.
					if (SPres[i].DFatalErr == MAC_TRUE)
						continue;

					v_DrugCode = SPres[i].DrugCode;
					
					// Marianna 25Feb2024 User Story #540234 
					// If its cannabis sale, set Yarpa Price what pharmacy sent
					if (IsCannabisSale)
					{
						Yarpa_Price		= SPres[i].ph_OTC_unit_price;
						Macabi_Price	= 0;
						Supplier_Price	= 0;

						FORCE_SQL_OK;
					}
					else // Check price in table
					{
						// DonR 30Jun2020: Made this a "normal" operation (i.e. without a
						// custom WHERE clause) and made it sticky, since this executes
						// for every drug bought.
						ExecSQL (	MAIN_DB, READ_PriceList_simple,
									&Yarpa_Price,	&Macabi_Price,		&Supplier_Price,
									&v_DrugCode,	&v_PriceListCode,	END_OF_ARG_LIST		);

						Conflict_Test (reStart);

					}

					if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DRUG_PRICE_NOT_FOUND, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
							continue;
						}
					}
					else
					{
						if (SQLERR_error_test ())
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
							break;
						}
						else
						{	// Successful read of price-list row.

							// DonR 06Nov2011: If at least one drug has a non-discounted per-OP price of
							// more than NIS 500.00, set trigger that enables the "Member in hospital" warning
							// message for pharmacies. Note that this check must be made *before* taking VAT
							// off the price for Eilat pharmacies!
							// DonR 23Aug2022: The threshold price should be coming from a table, *not*
							// hard-coded!
							if (Yarpa_Price > 50000)
								DrugPriceMemHospTrigger	= 1;

							// DonR 06Aug2020 CR #33003: If this is an expensive drug (by default, NIS 3,000
							// or more per package) and the person buying it is a Maccabi member, generate
							// an error code to trigger the AS/400 to send the member a "is this OK?" SMS.
							// DonR 09Sep2020: We want to generate warning SMSs only for prescription
							// purchases - NOT for OTC stuff.
							// DonR 25Nov2020 Feature 110506: Do not send members SMSs when they're getting
							// drugs from one of the special Maccabi pharmacies that supply drugs to hospitals.
							// DonR 14Mar2021 Feature 145196: Send SMS only for normal in-person drugstore sales
							// (Client Location Code == 1).
							if ((Yarpa_Price			>= pkg_price_for_sms)	&&
								(Member.MemberMaccabi)							&&
								(v_MemberIdentification	>  0)					&&
								(v_PharmNum				!= 995482)				&&	// DonR 25Nov2020 Feature 110506.
								(v_PharmNum				!= 997582)				&&	// DonR 25Nov2020 Feature 110506.
								(v_ClientLocationCode	== 1)					&&	// DonR 14Mar2021 Feature 145196.
								(SPres[i].PrescSource	!= RECIP_SRC_NO_PRESC))
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, EXPENSIVE_DRUG_SEND_MEMBER_SMS, v_DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
							}
						}
					}


					// Store drug price in SPres array.
					// NOTE: The following call to GET_PARTICIPATING_PERCENT is ONLY to ensure that
					// the Participation Type is one we know something about. The retrieved
					// participation percentage is not used!
					state = GET_PARTICIPATING_PERCENT (SPres[i].BasePartCode,	&percents);
					if (state != NO_ERROR)
					{
						if (SetErrorVarArr (&v_ErrorCode, state, 0, 0, NULL, &ErrOverflow))
						{
							break;
						}
					}

					
					// 25Mar2003: Per Iris, the logic for use of Maccabi Price is changing.
					// For normal participation calculation, we will always use the Yarpa
					// (i.e. regular) price; at the end, we'll use the Maccabi Price as
					// a fixed participation price if:
					//     A) A Maccabi Price exists;
					//     B) Participation is 100%; and
					//     C) No fixed participation has been set from other sources, such as
					//        Drug-Extension.
					SPres[i].RetOpDrugPrice		= Yarpa_Price;
					SPres[i].YarpaDrugPrice	    = Yarpa_Price;
					SPres[i].MacabiDrugPrice    = Macabi_Price;
					SPres[i].SupplierDrugPrice  = Supplier_Price;

					// DonR 23Aug2011: For VAT-exempt pharmacies (e.g. in Eilat), deduct VAT from prices.
					// For now, adjust only the Yarpa price; but in future we may need to do the same
					// for the Maccabi (discounted) price.
					// DonR 19Feb2012: Added a separate price variable for calculating member participation, since Eilat
					// pharmacies are still supposed to see the VAT-inclusive price as the per-OP price.
					// DonR 25Jun2024 User Story #327482: Eilat pharmacies already send cannabis prices with VAT
					// deducted, and we don't want to deduct it again - so add NOT IsCannabisSale to the condition.
					if ((vat_exempt != 0) && (!IsCannabisSale))
					{
						SPres[i].PriceForPtnCalc = (int)(((double)Yarpa_Price * no_vat_multiplier) + .5001);
					}
					else
					{
						SPres[i].PriceForPtnCalc = Yarpa_Price;
					}


					// Test Special Prescription.
					// 20020122: If a member has a special prescription, it is
					// written in the members table (column spec_prescs). For such
					// members, we must check for a constant amount to pay.
					// DonR 21Jul2008: Per Iris Shaya, we should check Special Prescriptions only if drugs are
					// being sold based on some form of prescription. Non-prescription sales are not covered
					// by Special Prescriptions.
					// Marianna 22Feb2024 User Story #540234: Don't check ishurim for cannabis sales.
					if ((v_MemberSpecPresc /* from members table */)			&&
						(SPres[i].PrescSource != RECIP_SRC_NO_PRESC)			&&
						(SPres[i].PrescSource != RECIP_SRC_EMERGENCY_NO_RX)		&&
						(!CannabisForce100Percent))
					{
						TypeCheckSpecPr = 1;
					}

					// All the stuff about special special-prescription numbers
					// shouldn't apply to Electronic Prescriptions.
					if (TypeCheckSpecPr > 0)
					{
						// DonR 04Sep2003: If there was a Pharmacy Ishur to use an expired AS400
						// Special Prescription (and such a Special Prescription was found), the
						// number of days to extend it (currently always 31) will be stored in
						// PR_ExtendAS400IshurDays[]. Otherwise the array will have a zero, and
						// things will work as normal.
						flg = test_special_prescription (NULL,//&v_DummySpecialConfirmationNum,
														 NULL,//&v_DummySpecialConfirmationNumSource,
														 &Member,
														 OVERSEAS_MEMBER,
														 SPres[i].DocIDType,
														 SPres[i].DocID,
														 &SPres[i],
														 &SPres[0],
														 v_NumOfDrugLinesRecs,
														 PR_AsIf_Preferred_Largo[i],		// DonR 23Feb2004
														 &FunctionError,
														 TypeCheckSpecPr,
														 v_PharmNum,
														 Phrm_info.pharmacy_permission,		// DonR 14Aug2003
														 SPres[i].BasePartCode,
														 PR_ExtendAS400IshurDays[i],
														 &ThisIshurHasTikra);

						SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);

						// DonR 28Mar2007: If function returned OK, check whether
						// an ishur was found that had its "Tikra" flag set. If
						// so, remember that at least one such ishur was found
						// for the sale, so we can advise the member to pay by
						// Credit Line.
						// DonR 04Jan2012: Moved this stuff up above the "break" statements,
						// to make sure that it's executed unconditionally.
						if (ThisIshurHasTikra)
						{
							AnIshurHasTikra = SPres[i].IshurWithTikra = 1;
						}

						// DonR 09May2010 HOT FIX: If there is an AS/400 ishur for this member/drug,
						// suppress errors involving sale of non-generic medication without a valid
						// reason. The AS/400 ishur is a valid reason!
						// DonR 11Jul2011: Changed method of deleting error code, in order to work
						// with the "new" error-array system.
						if (SPres[i].ret_part_source.table == FROM_SPEC_PRESCS_TBL)
						{
							SetErrorVarDelete (ERR_NO_DOCTORS_ISHUR_WARN,		SPres[i].DrugCode);
							SetErrorVarDelete (ERR_NOT_PREFERRED_DRUG_WARNING,	SPres[i].DrugCode);
						}
						// DonR 04Jan2012 end.

						if (flg == 1)		/* high severity error occurred	*/
						{
							break;
						}
						else
						{
							if (flg == 2)	/* deadlock; access conflict	*/
							{
								reStart = MAC_TRUE;
								break;
							}
						}	// Something other than 1 (severe error) from test_special_prescription().
					}	// Need to test Special Prescription.
				}	// Get Drug Prices / Check Special Prescriptions loop.

				// DonR 04Jan2012: Add a separate "mini" loop to swap the real no-doctor's-ishur
				// error for the temporary version - since there is the possibility that the previous
				// loop will be exited prematurely, leaving the temporary version in place.
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// DonR 09May2010 HOT FIX: Replace fictitious warning message with the real, critical-error
					// version.
					// DonR 11Jul2011: Since we're using the "new" error-array system, use a special swapping
					// function instead of just changing DrugAnswerCode.
					SetErrorVarSwap (&SPres[i].DrugAnswerCode,
									 ERR_NO_DOCTORS_ISHUR_WARN,
									 ERR_NO_DOCTORS_ISHUR,
									 SPres[i].DrugCode,
									 NULL);
				}	// "Mini-loop" for error-code substitution.

				// If we've hit a major problem, break out of big DUMMY loop.
				if ((reStart == MAC_TRUE) || (v_ErrorCode == ERR_DATABASE_ERROR))
				{
					break;
				}


				// DonR 02Aug2011: If member is currently a hospital inpatient and is trying to buy
				// prescription medications, provide a warning message to pharmacy.
				// DonR 06Nov2011: This message is now contingent on their being at least one expensive
				// (price/OP >= NIS 500.00) item being bought; purchase at Maccabi pharmacy; and member
				// either currently in hospital OR absent without official discharge ("on vacation").
				if (((v_in_hospital				== IN_HOSPITAL) || (v_in_hospital == ABSENT_NOT_DISCHARGED))	&&
					(DrugPriceMemHospTrigger	!= 0)															&&
					(RX_SOURCE_OTHER_THAN (RECIP_SRC_NO_PRESC))													&&
					(MACCABI_PHARMACY))
				{
					SetErrorVarArr (&v_ErrorCode, WARN_MEMBER_IN_HOSPITAL, 0, 0, NULL, &ErrOverflow);
				}


				// Check for interactions and overdoses.
				// DonR 27Jul2003: Made these tests a separate function, since the same 1000+ lines of code
				// are present in at least three transactions.
				// DonR 24Jan2018: Moved member validation inside test_interaction_and_overdose(), so we can
				// now execute it unconditionally.
				test_interaction_and_overdose (	&Member,				max_drug_date,				v_PharmNum,
												&Phrm_info,				v_InstituteCode,			v_TerminalNum,
												v_RecipeIdentifier,		SPres,						v_NumOfDrugLinesRecs,
												v_SpecialConfNum,		v_SpecialConfSource,
												1,	// DonR 23Mar2004 - Error Mode = "new style"
												1,	// DonR 31Aug2005: Electronic Prescription Flag.
												&DocRx[0],				&v_MsgExistsFlg,			&v_MsgIsUrgentFlg,
												&FunctionError,			&reStart);

				SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);


				// Member participating percent calculation.
				// Set Participation Code according to Prescription Source.
				// DonR 03Aug2003: Moved this section up, because we need to know the calculated
				// participation type *before* calculating Member Discount.
				flg = 0;

				// DonR 16May2006: Kishon Divers (who are supposed to get their medications
				// direct from the government) pay 100% unconditionally. This is implemented
				// (sneakily) by disabling the for-loop: Kishon divers have Identification Code
				// of 3, which makes the test condition FALSE for all values of i.
				// DonR 09Aug2021 User Story #163882: Add darkonai-plus people who don't get
				// any discounts (other than shovarim from their insurance company) to the
				// criteria for disabling this loop.
				// Marianna 22Feb2024 User Story #540234 - no discounts for Cannabis Sales.
				for (i = 0;
					((i < v_NumOfDrugLinesRecs) && (v_IdentificationCode != 3) && (!Member.force_100_percent_ptn) && (!CannabisForce100Percent));
					i++)
				{
					// DonR 18Nov2021 User Story #196891: Add support for per-Largo blocking.
					if (SPres[i].LargoBlockedForMember)
						continue;

					// DonR 19May2016 HOT FIX: If we're getting *any* kind of participation from an AS/400 ishur,
					// don't do any further participation checking.
					if (SPres[i].ret_part_source.table == FROM_SPEC_PRESCS_TBL)
						continue;


					// DonR 14Apr2003: If we are treating a non-preferred drug as if it
					// were the preferred drug (for purposes of determining member participation),
					// swap in the preferred drug for checking participation levels.
					// DonR 04Dec2003: Use the preferred largo only if the participation for the
					// dispensed largo would be 100% with no fixed price.
					// DonR 09Jan2012: Replaced standard full-price conditions with macro FULL_PRICE_SALE.
					// DonR 17May2016: Per CR #4720, we now want to compute participation using the
					// generic "as if" drug first, and only if nothing better than 100% is found
					// will we fall back to the non-generic medication being sold.
					// This change is irrelevant except in situations where an "as if" drug exists - 
					// that is, a non-generic medication is being sold either because of a pharmacy
					// stock issue or because the doctor requested "dispense as written". Only
					// then will PR_AsIf_Preferred_Largo[i] have a non-zero value.
					if (PR_AsIf_Preferred_Largo[i] > 0)
					{
						// Switch pricing variables to preferred drug.
						SPres[i].BasePartCode				= preferred_mbr_prc_code[i];
						SPres[i].RetPartCode				= preferred_mbr_prc_code[i];
						SPres[i].part_for_discount			= preferred_mbr_prc_code[i];
						SPres[i].BasePartCodeFrom			= CURR_CODE;
						SPres[i].ret_part_source.state		= CURR_CODE;

						// Redo the participation-determination stuff with the preferred Largo Code.
						HoldLargo			= SPres[i].DrugCode;
						HoldSpecialistDrug	= SPres[i].DL.specialist_drug;
						HoldParentGroupCode	= SPres[i].DL.parent_group_code;
						HoldRuleStatus		= SPres[i].DL.rule_status;
						SPres[i].DrugCode				= PR_AsIf_Preferred_Largo	[i];
						SPres[i].DL.specialist_drug		= PR_AsIf_Preferred_SpDrug	[i];
						SPres[i].DL.parent_group_code	= PR_AsIf_ParentGroupCode	[i];
						SPres[i].DL.rule_status			= PR_AsIf_RuleStatus		[i];
						SPres[i].in_health_pack			= PR_AsIf_Preferred_Basket	[i];

						switch (SPres[i].PrescSource)
						{
							case RECIP_SRC_DENTIST:

									flg = test_dentist_drugs_electronic (&SPres[i],
																		 &FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;


							// DonR 23Feb2008: Added new Prescription Source 11, for
							// "Home Visit" prescriptions.
							case RECIP_SRC_HOME_VISIT:

									flg = test_home_visit_drugs_electronic (&SPres[i],
																			&FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;

//							case RECIP_SRC_MACABI_DOCTOR:
//							case RECIP_SRC_PRIVATE:
//							case RECIP_SRC_HOSPITAL:
//							case RECIP_SRC_OLD_PEOPLE_HOUSE:
//							case RECIP_SRC_MACABI_STAMP:
//							case RECIP_SRC_MAC_DOC_BY_HAND:
//							case RECIP_SRC_MACCABI_NURSE:		// DonR 11Aug2008
//							case RECIP_SRC_AFFILIATED_CLINIC:	// DonR 24Sep2009
//							case RECIP_SRC_NO_PRESC:
//							case RECIP_SRC_MOKED_MACCABI:		// DonR 06Jul2005
//							case RECIP_SRC_MEUCHEDET:			// DonR 06Jul2005
//							case RECIP_SRC_LEUMIT:				// DonR 06Jul2005
//							case RECIP_SRC_CONTINUED_PRESC:		// DonR 06Jul2005
//							case RECIP_SRC_PHARMACIST_EQUIP:	// DonR 24Aug2014
//							case RECIP_SRC_MAC_DIETICIAN:		// DonR 04Apr2016
							default:							// DonR 29Aug2016 CR #8956.

									flg = test_mac_doctor_drugs_electronic (SPres[i].DocIDType,
																			SPres[i].DocID,
																			&SPres[i],
																			i + 1,
																			Member.age_months,
																			v_MemberGender,
																			Phrm_info.pharmacy_permission,
																			SPres[i].PrescSource,
																			v_MemberIdentification,
																			v_IdentificationCode,
																			(v_ClientLocationCode > 1),
																			&PharmIshurProfession[i],
																			&FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;

						}	// End of switch on prescription source.


						// Swap back the drug code actually being sold.
						// DonR 15Jan2013 WORKINGPOINT: Should we also swap in the original Health Basket status
						// if participation is still 100%?
						SPres[i].DrugCode				= HoldLargo;
						SPres[i].DL.specialist_drug		= HoldSpecialistDrug;
						SPres[i].DL.parent_group_code	= HoldParentGroupCode;
						SPres[i].DL.rule_status			= HoldRuleStatus;
					}	// Need to compute participation with "as if" preferred Largo Code.

					
					// DonR 17May2016: Per CR #4720, the logic for the drug being sold now comes *after* the
					// logic for the "as if" generic drug. This change is irrelevant except in situations where
					// an "as if" drug exists - that is, a non-generic medication is being sold either because
					// of a pharmacy stock issue or because the doctor requested "dispense as written". Only
					// then will PR_AsIf_Preferred_Largo[i] have a non-zero value.
					if ((PR_AsIf_Preferred_Largo[i]	== 0) || (FULL_PRICE_SALE(i)))
					{
						// DonR 22Mar2015: If we *didn't* get participation for the preferred generic
						// drug, zero out the "tens" digit of the why-non-preferred-drug-was-sold flag.
						SPres[i].WhyNonPreferredSold	= 0;

						switch (SPres[i].PrescSource)
						{
							case RECIP_SRC_DENTIST:

									flg = test_dentist_drugs_electronic (&SPres[i],
																		 &FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;


							// DonR 23Feb2008: Added new Prescription Source 11, for
							// "Home Visit" prescriptions.
							case RECIP_SRC_HOME_VISIT:

									flg = test_home_visit_drugs_electronic (&SPres[i],
																			&FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;

//							case RECIP_SRC_MACABI_DOCTOR:
//							case RECIP_SRC_PRIVATE:				// Yulia 20021022
//							case RECIP_SRC_HOSPITAL:			// Yulia 20021022
//							case RECIP_SRC_OLD_PEOPLE_HOUSE:	// Yulia 20021022
//							case RECIP_SRC_MACABI_STAMP:		// DonR 22Jul2003
//							case RECIP_SRC_MAC_DOC_BY_HAND:		// DonR 03Aug2003
//							case RECIP_SRC_MACCABI_NURSE:		// DonR 11Aug2008
//							case RECIP_SRC_AFFILIATED_CLINIC:	// DonR 24Sep2009
//							case RECIP_SRC_NO_PRESC:			// DonR 21Aug2003
//							case RECIP_SRC_MOKED_MACCABI:		// DonR 06Jul2005
//							case RECIP_SRC_MEUCHEDET:			// DonR 06Jul2005
//							case RECIP_SRC_LEUMIT:				// DonR 06Jul2005
//							case RECIP_SRC_CONTINUED_PRESC:		// DonR 06Jul2005
//							case RECIP_SRC_PHARMACIST_EQUIP:	// DonR 24Aug2014
//							case RECIP_SRC_MAC_DIETICIAN:		// DonR 04Apr2016
							default:							// DonR 29Aug2016 CR #8956.

									// DonR 05Aug2003: test_mac_doctor_drugs_electronic () now handles
									// retrieval of the name of non-Maccabi doctors (DocID = license number
									// rather than Teudat Zehut number) with entries in doctor_percents
									// and doctors tables.
									flg = test_mac_doctor_drugs_electronic (SPres[i].DocIDType,
																			SPres[i].DocID,
																			&SPres[i],
																			i + 1,
																			Member.age_months,
																			v_MemberGender,
																			Phrm_info.pharmacy_permission,
																			SPres[i].PrescSource,
																			v_MemberIdentification,
																			v_IdentificationCode,
																			(v_ClientLocationCode > 1),
																			&PharmIshurProfession[i],
																			&FunctionError);

									SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);
									break;

						}	// End of switch on prescription source.
					}	// Either there is no "as if" generic drug, or there was no price reduction
						// for the "as if" drug.

				}	// Loop through drugs - yet again!



				// Test for deadlock or severe error.
				if (flg == 2) // deadlock or access conflict
				{
					reStart = MAC_TRUE;
				}

				// If we've hit a serious database error, break out of outer loop and restart.
				if ((reStart == MAC_TRUE) || (v_ErrorCode == ERR_DATABASE_ERROR) || (flg == 1))
					break;



				// Member participating percent validation.
				//
				// Compare Prescription participation with Drug participation.
				flg = 0;

				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					if (SPres[i].DFatalErr == MAC_TRUE )
						continue;

					// DonR 07Aug2003: The supplement gets its participation (i.e. RetPartCode)
					// from the "major" drug.
					// DonR 23Aug2005: This is not true for "gadgets" - which sometimes use
					// the Link to Addition parameter for a different purpose.
					if ((SPres[i].LinkDrugToAddition	>  0	)	&&
						(SPres[i].DL.largo_type			!= 'X'	)	&&
						(SPres[i].DL.in_gadget_table	== 0	)	&&
						(MajorDrugIndex[i]				>= 0	))
					{
						SPres[i].RetPartCode = SPres[MajorDrugIndex[i]].RetPartCode;
						continue;
					}

					// Percent2 is the "default" participation for this drug.
					state =	GET_PARTICIPATING_PERCENT (SPres[i].BasePartCode, &percent2);
					if (state != NO_ERROR)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, state, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							flg = 1;
						}
						continue;
					}

					// Percent1 is the calculated participation, based on drug_extension,
					// doctor specialty, etc.
					state = GET_PARTICIPATING_PERCENT (SPres[i].RetPartCode, &percent1);
					if (state != NO_ERROR)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, state, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow))
						{
							flg = 1;
						}
						continue;
					}


					// Process Pharmacy Ishur, if any, for this drug line.
					LineNum = i + 1;

					// DonR 30Mar2006: Don't bother checking Pharmacy Ishur for Member ID zero! OR
					// Marianna 22Feb2024 User Story #540234: for Cannabis Sale not need to check Pharmacy Ishur
					if ((v_MemberIdentification > 0) || (!CannabisForce100Percent))
					{
						flg = test_pharmacy_ishur (v_PharmNum,
												   SPres[i].PrescSource,
												   v_MemberIdentification,
												   v_IdentificationCode,
												   Member.maccabi_code,
												   v_MemberDiscPercent,
												   Member.illness_bitmap,
												   SPres[i].DocIDType,
												   SPres[i].DocID,
												   &SPres[i],
												   PR_AsIf_Preferred_Largo[i],
												   v_SpecialConfNum,
												   v_SpecialConfSource,
												   v_RecipeIdentifier,
												   LineNum,
												   (short)6003,
												   PharmIshurProfession[i],
												   &FunctionError);

						SetErrorVarArr (&v_ErrorCode, FunctionError, 0, 0, NULL, &ErrOverflow);


						// Test for deadlock or severe error.
						if (flg == 2) // deadlock or access conflict
						{
							reStart = MAC_TRUE;
							break;
						}
						else
						{
							if (flg == 1)	// Other severe error.
							{
								break;
							}

							// If we get here, the Pharmacy Ishur routine was happy.
						}
					}	// Member ID is non-zero.


					// DonR 14Jun2004: If "drug" being purchased is a device in the "gadgets"
					// table, retrieve the appropriate information and query the AS400 for
					// participation information.
					// DonR 08Oct2018 CR #15092: Meishar is now enabled for non-prescription items, contingent
					// on the enabled_without_rx added to the Gadgets table.
					// DonR 05Nov2018: Added new logical variable prescription_sale; we now read gadget rows
					// only if prescription_sale is > 0 OR the "gadget" is set up for sale without prescription.
					// This eliminates excessive "duplicate gadget" errors; but OTOH it creates "not found"
					// errors for non-prescription sales, so we need to suppress these errors below.
					// DonR 01Jul2012: New macro conditionally enables Prati Plus pharmacies.
					// Marianna 22Feb2024 User Story #540234 - cannabis sale
					// DonR 19Aug2025 User Story #442308: If Nihul Tikrot calls are disabled, disable Meishar calls as well.
					if ((SPres[i].DL.in_gadget_table)		&&
						(TikrotRPC_Enabled)					&&	// If Nihul Tikrot calls are disabled, disable Meishar calls too.
						(MEISHAR_PHARMACY)					&&
						(!Member.force_100_percent_ptn)		&&	// DonR 29Aug2021: Added new condition to exclude Darkonaim-Plus.
						(!CannabisForce100Percent)					&&  // Marianna 22Feb2024 User Story #540234: Added new condition to exclude cannabis sale
						(!SPres[i].LargoBlockedForMember))		// DonR 18Nov2021 User Story #196891: Add per-Largo blocking.
					{
						GoToMeishar			= true;	// Start with the assumption that we are going to call Meishar.
						v_gadget_code		= SPres[i].LinkDrugToAddition;
						v_DrugCode			= SPres[i].DrugCode;
						prescription_sale	= ((SPres[i].PrescSource != RECIP_SRC_NO_PRESC) && (SPres[i].PrescSource != RECIP_SRC_EMERGENCY_NO_RX)) ? 1 : 0;

						// DonR 18Sep2011: Add get_ptn_from_as400 flag to gadgets table; if it's equal to zero,
						// pharmacy has chosen a "placeholder" service that is not actually supposed to get
						// its participation from AS/400.
						// DonR 27Nov2011: Switch from get_ptn_from_as400 to new separate enabled-status flags
						// for Maccabi member and IDF soldiers.
						// DonR 25Jul2016: Fixed WHERE clause (which had stuff grouped together wrong); also
						// suppress the "duplicate gadget" message to log, since it's not an indication of any
						// actual program or database problem.
						// DonR 28Feb2024 User Story #551403: Read three new columns from the gadgets table to
						// support conditional calls to Meishar based on purchase history.
						ExecSQL (	MAIN_DB, TR6003_READ_gadgets,
									&GadgetCodeFound,				&v_service_code,			&v_service_number,
									&v_service_type,				&v_enabled_mac,				&v_enabled_hova,
									&v_enabled_keva,				&enabled_pvt_pharm,			&enabled_without_rx,
									&GadgetPrevPurchaseClassCode,	&GadgetMinPrevPurchases,	&GadgetMaxPrevPurchases,

									&v_DrugCode,					&v_gadget_code,				&v_gadget_code,
									&prescription_sale,				&Member.MemberMaccabi,		&Member.MemberHova,
									&Member.MemberKeva,				END_OF_ARG_LIST									);

						Conflict_Test (reStart);

						if (SQLERR_code_cmp (SQLERR_too_many_result_rows) == MAC_TRUE)
						{
							SetErrorVarArr (&SPres[i].DrugAnswerCode,	ERR_DUPLICATE_GADGET_ROW,	v_DrugCode,	i + 1,	NULL, &ErrOverflow);
							SetErrorVarArr (&v_ErrorCode,				ERR_DRUG_S_WRONG_IN_PRESC,	0,			0,		NULL, &ErrOverflow);
//							GerrLogMini (GerrId, "Duplicate gadget! Largo %d, Gadget Code %d, err %d.",
//										 v_DrugCode, v_gadget_code, SQLCODE);
							break;
						}
						else
						{
							// WORKINGPOINT: NEED TO GIVE PHARMACY SOMETHING MORE INFORMATIVE THAN "DATABASE ERROR" IN THIS CASE!
							// (DonR 12OCT2008)
							// DonR 21Jul2011: Just to de-clutter the log, provide a shorter message for
							// row-not-found.
							// DonR 05Nov2018: Suppress this error if the current sale is without a prescription;
							// in thise case not-found "errors" are perfectly normal, although of course we don't
							// want to call Meishar if we didn't find an applicable "gadget" row.
							if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
							{
								if (prescription_sale)
								{
									GerrLogReturn (GerrId, "Get gadget: No data for Largo %d, Gadget Code %d.",
												   v_DrugCode, v_gadget_code);
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}
								else
								{
									// If this isn't a prescription sale, don't report an error - but don't call Meishar either!
									GoToMeishar = false;
								}
							}
							else
							{
								if (SQLERR_error_test ())
								{
									GerrLogReturn (GerrId, "Get gadget: Largo %d, Gadget Code %d, err %d.",
												   v_DrugCode, v_gadget_code, SQLCODE);
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}

								// If we get here, we read the row successfully.

							}	// Something other than row-not-found.
						}	// Not a duplicate gadget-row.


						// DonR 28Feb2024 User Story #551403: If the "gadgets" row specified a Previous
						// Purchase Class Code, check purchase history to see if we actually want to
						// contact Meishar. If we do, *and* if Meishar authorizes the sale, we will set
						// values to indicate that further Purchase Limit checking doesn't need to be
						// performed on this item.
						if ((GoToMeishar) && (GadgetPrevPurchaseClassCode > 0))
						{
							int		QualifyingPurchaseDate [GadgetMaxPrevPurchases];	// OK in C, but maybe not in C++. I can live with that...
							int		NumQualifyingPurchasesFound			= 0;
							int		UniqueDate;
							int		class_history_days;
							int		CurrSaleSubscript;
							int		MinimumPurchDate;
							bool	QualifyingPurchaseAlreadyMadeToday	= false;


							// Note that we contact the Meishar application even if we already got participation
							// from an AS/400 ishur. At least for now, we will continue working like this even in
							// the case of people with ishurim for Libre sensors - if Meishar wants to give its
							// own participation value, it can do so, and it will override whatever is in the ishur.
							// (Presumably Meishar is smart enough to give its own discount only once per member.)
							// If it turns out that the Meishar team wants us *not* to contact Meishar for people
							// who have ishurim for Libre sensors, we can force GoToMeishar FALSE when
							// SPres[i].HasIshurWithLimit is TRUE, and skip the rest of the logic in this section.

							// We almost certainly already loaded past purchases - but just in case, call
							// get_drugs_in_blood() again. (It's smart enough to return without checking
							// the database if it's already been called for this transaction.) Since we're
							// not really expecting get_drugs_in_blood() to have to do anything this time,
							// we won't bother checking error codes.
							get_drugs_in_blood (&Member, &v_DrugsBuf, GET_ALL_DRUGS_BOUGHT, &v_ErrorCode, &reStart);

							// Get the history length to check from purchase_lim_class.
							ExecSQL (	MAIN_DB, GetPurchaseLimitClassHistoryLength,
										&class_history_days,
										&GadgetPrevPurchaseClassCode,
										END_OF_ARG_LIST									);

							// If we didn't find a value for the Purchase Limit Class (which should really
							// never happen unless someone entered an invalid Class Code), default to six
							// months and write a message to log.
							if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
							{
								GerrLogMini (	GerrId,
												"Couldn't find Purchase Limit Class %d; defaulting to 183 days of history.",
												GadgetPrevPurchaseClassCode);

								class_history_days = 183;
							}
							else
							{
								// Log any database error other than row-now-found.
								if (SQLCODE != 0)
									SQLERR_error_test ();
							}

							MinimumPurchDate = IncrementDate (SysDate, (0 - class_history_days));

							for (j = 0; j < v_DrugsBuf.max; j++)
							{
								if ((v_DrugsBuf.Durgs[j].ClassCode	== GadgetPrevPurchaseClassCode)	&&
									(v_DrugsBuf.Durgs[j].StartDate	>= MinimumPurchDate))
								{
									// Count the number of unique purchase *dates* rather than just *purchases*.
									// First, loop through the Unique Purchase Date array to see if we already
									// found something for that date.
									for (UniqueDate = 0; UniqueDate < NumQualifyingPurchasesFound; UniqueDate++)
									{
										if (QualifyingPurchaseDate [UniqueDate] == v_DrugsBuf.Durgs[j].StartDate)
											break;
									}

									// If we got to the end of the previous loop with no matches, store this date
									// and increment our dates-found counter.
									if (UniqueDate == NumQualifyingPurchasesFound)
									{
										QualifyingPurchaseDate [NumQualifyingPurchasesFound++] = v_DrugsBuf.Durgs[j].StartDate;

										// If we see a qualifying past purchase that took place today, we don't
										// need to bother checking the current sale request, since we're counting
										// unique purchase dates rather than just counting drug sale transactions.
										if (v_DrugsBuf.Durgs[j].StartDate == SysDate)
											QualifyingPurchaseAlreadyMadeToday = true;
									}

									// Keep looping until the end, unless we've already seen enough unique
									// purchase dates to disqualify the member for this Meishar request.
									if (NumQualifyingPurchasesFound > GadgetMaxPrevPurchases)
										break;
								}	// Found a qualifying past sale.
							}	// Loop through array of past purchases.

							// We need to check current sale for qualifying purchase, not just past sales.
							// There's no point in checking the current purchase unless (A) we haven't
							// already found a qualifying purchase made today, and (B) exactly one more
							// purchase date will put us over the limit. 
							if ((NumQualifyingPurchasesFound		== GadgetMaxPrevPurchases)	&&
								(QualifyingPurchaseAlreadyMadeToday	== false))
							{
								for (CurrSaleSubscript = 0; CurrSaleSubscript < v_NumOfDrugLinesRecs; CurrSaleSubscript++)
								{
									if (SPres[CurrSaleSubscript].DL.class_code == GadgetPrevPurchaseClassCode)
									{
										NumQualifyingPurchasesFound++;
										break;
									}
								}
							}	// We need to check the current sale to see if it puts us over the limit.

							// At this point, we know how many times (counting each purchase date as one "time")
							// the member has bought something with the specified Class Code - or at least we know
							// if the number of purchases is or is not within the limits that were set in the
							// gadgets table. If the result is either too low or too high, disable the Meishar call.
							// Note that we are *not* saving the number of purchases we found, since (A) the scan
							// through history is all done in memory and thus takes very little time, and (B) at
							// this point we don't know how many previous purchases (if any) the Drug Purchase Limits
							// logic is going to be interested in. So if Meishar doesn't authorize this sale, the
							// Purchase Limits code may have to do this scan over again.
							if ((NumQualifyingPurchasesFound < GadgetMinPrevPurchases)	||
								(NumQualifyingPurchasesFound > GadgetMaxPrevPurchases))
							{
								GoToMeishar = false;
							}
						}	// DonR 28Feb2024 User Story #551403: Check for previous purchases to qualify
							// call to Meishar.


						// DonR 18Sep2011: If get_ptn_from_as400 flag from gadgets table is equal to zero,
						// pharmacy has chosen a "placeholder" service that is not actually supposed to get
						// its participation from AS/400. Make the rest of the "gadgets" code conditional
						// on this flag.
						// DonR 27Nov2011: Switch from get_ptn_from_as400 to new separate enabled-status flags
						// for Maccabi member and IDF soldiers. A "placeholder" service will have zeroes for
						// all three member types.
						// DonR 20Jan2014: Add a condition for pharmacy type. Maccabi pharmacies can sell all
						// "meishar" items; private pharmacies can sell (or at least can get participation
						// from the "meishar" application) only those items with their "private pharmacy
						// enabled" flag set > 0.
						// DonR 08Oct2018 CR #15092: Meishar is now enabled for non-prescription items, contingent
						// on the enabled_without_rx added to the Gadgets table.
						// DonR 05Nov2018: Added GoToMeishar to the "if" below - so if we're selling a gadget without
						// a prescription, and no applicable gadgets row was found, we'll quietly skip this whole
						// block of code.
						if (((MACCABI_PHARMACY)		|| (enabled_pvt_pharm > 0))		&&
							(GoToMeishar)											&&
							(((v_enabled_mac	> 0) && (Member.MemberMaccabi	> 0))	||
							 ((v_enabled_hova	> 0) && (Member.MemberHova		> 0))	||
							 ((v_enabled_keva	> 0) && (Member.MemberKeva		> 0))))
						{
							// If this is a non-prescription sale, we want to go to Meishar only if the member's magnetic card
							// was passed OR this is something that was ordered online for pickup or delivery - otherwise give
							// an error message to the pharmacy. (DonR added Type 3 = pickup 01Jun2021.)
							if (!prescription_sale)
							{
								if (MEMBER_USED_CURRENT_MAG_CARD	||
									(MACCABI_PHARMACY && ((FirstCenterTypeNum == 1) || (FirstCenterTypeNum == 2) || (FirstCenterTypeNum == 3))))
								{
									// A valid card was passed, or isn't required.
									GoToMeishar = true;	// Should be redundant.
								}
								else
								{
									// A valid card was *not* passed, and is required - send an error.
									// Note that according to Ronen Har'el, we want to give the Meishar discount anyway -
									// but require a pharmacist to authorize the sale (thus, the error severity will be 2).
									// If they want to sell the item without a Meishar discount, they will have to re-do
									// the transaction *without* entering a Member TZ Number. I'm still keeping the variable
									// GoToMeishar "alive" even though it never gets a value other than "true" - this will
									// simplify things if someone later on decides to change the functionality here.

									GoToMeishar = true;	// Should be redundant.

									if (SetErrorVarArr (&SPres[i].DrugAnswerCode, MEISHAR_DISCOUNT_REQUIRES_CARD,	v_DrugCode,	i + 1,	NULL, &ErrOverflow))
									{
										SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
									}
								}
							}	// This is a non-prescription sale.
							else
							{
								// This is an ordinary prescription sale - proceed as normal, without worrying about the card.
								GoToMeishar = true;
							}

							if (GoToMeishar)	// Should be true in all cases *except* OTC sale where no OTC gadgets row exists.
							{
								// DonR 08Oct2018 CR #15092: If we're doing a Meishar call for something purchased without a
								// prescription, AND pharmacy has supplied the price at which they plan to sell the item (in
								// other words, Transaction Version is 2 or above), use the pharmacy-supplied price as the default
								// to send to Meishar instead of the Yarpa price. (Note that pharmacies in Eilat will send
								// this "hishtatfut" *without* VAT, so we don't have to worry about taking VAT off.)
								if ((!prescription_sale) && (VersionNumber > 1))
								{
									UnitPrice = SPres[i].ph_OTC_unit_price;
								}
								else
								{
									// DonR 14Nov2012: We no longer want to send the reduced "Maccabi" price to Meishar;
									// instead, we just send the ordinary unit price, with VAT deducted for Eilat pharmacies.
									// DonR 20Jan2014: For private pharmacies, send the price from Price List 2 (normally used
									// for Maccabi pharmacies) to Meishar as the default unit price.
									if (PRIVATE_PHARMACY)
									{
										ExecSQL (	MAIN_DB, READ_GetStandardMaccabiPharmPriceForMeishar,
													&Yarpa_Price,	&v_DrugCode,	END_OF_ARG_LIST			);

										// No error trapping - just disable the price substitution.
										if (SQLCODE != 0)
											Yarpa_Price = 0;
									}
									else
									{
										// For Maccabi pharmacies, we never want (or need) to do this substitution.
										Yarpa_Price = 0;
									}

									// DonR 20Jan2014: Use Yarpa Price if we're at a private pharmacy and we read it
									// successfully from Price List 2; otherwise use RetOpDrugPrice, which is the
									// normal Yarpa Price.
									UnitPrice = (Yarpa_Price > 0) ? Yarpa_Price : SPres[i].RetOpDrugPrice;	// DonR 14Nov2012.

									// DonR 25Mar2012: For members buying stuff at VAT-exempt pharmacies (i.e. in Eilat),
									// take VAT off the unit price sent to AS/400. The AS/400 "meishar" application is
									// supposed to send a response that will reflect this reduction, and so we won't
									// have to deduct VAT later on.
									// DonR 25Jun2024 User Story #327482: Eilat pharmacies already send cannabis prices with
									// VAT deducted, and we don't want to deduct it again - so add NOT IsCannabisSale to the
									// condition. This should be irrelevant for Meishar, but I'm going to make the fix here
									// as well, just in case someone sets up a Meishar discount for bongs or something. <g>
									if ((vat_exempt != 0) && (!IsCannabisSale))
									{
										UnitPrice = (int)(((double)UnitPrice * no_vat_multiplier) + .5001);
									}
								}

								// Store this gadget's information in array. If another gadget in the
								// same transaction has the same Service Code, Service Number, and
								// Service Type, abort and return a transaction-level error to
								// the pharmacy.
								gadget_svc_code		[i]		= v_service_code;
								gadget_svc_number	[i]		= v_service_number;
								gadget_svc_type		[i]		= v_service_type;

								for (j = 0; j < i; j++)
								{
									if ((gadget_svc_code	[j] == gadget_svc_code	[i]) &&
										(gadget_svc_number	[j] == gadget_svc_number[i]) &&
										(gadget_svc_type	[j] == gadget_svc_type	[i]))
									{
										SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
										SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DUPLICATE_GADGET_REQ,
														v_DrugCode, i + 1, NULL, &ErrOverflow);
										SPres[i].DFatalErr = MAC_TRUE;
										break;	// This is a severe error!
									}
								}


								// One more test before talking to the AS400: Did the pharmacy send
								// a non-zero value for Units? If so, return a severe error at the
								// treatment level, as quantity for Gadgets should be in OP only.
								if (SPres[i].Units > 0)
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
									SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_GADGET_REQ_WITH_UNITS,
													v_DrugCode, i + 1, NULL, &ErrOverflow);
									SPres[i].DFatalErr = MAC_TRUE;
									break;	// This is a severe error!
								}


								// If we get here, the gadget entry really does exist, and there are no
								// major problems with the gadget sale request.
								gettimeofday (&EventTime[EVENT_GADGET_START], 0);

								err = as400EligibilityTest (v_PharmNum,
															v_RecipeIdentifier,
															v_MemberIdentification,
															v_IdentificationCode,
															(int)v_service_code,
															(int)v_service_number,
															(int)v_service_type,
															v_DrugCode,
															(int)SPres[i].Op,
															(int)UnitPrice,
															(int)2,				// Retries
															&MeisharInfoCode,	// DonR 23Dec2014. For now, should be either 0 or 88.
															&l_dummy,			// plIdNumber
															&i_dummy,			// pnIdCode
															&QuantityPermitted,
															&RequestNum,
															&PtnPrice,
															&Insurance);

								gettimeofday (&EventTime[EVENT_GADGET_END], 0);

								GerrLogFnameMini ("gadgets_log",
												   GerrId,
												   "6003: AS400 err = %d.",
												   (int)err);

								// DonR 11Oct2018: Reworked the switch statement to use ErrorCodeToAssign and thus make the code
								// a lot more compact. Also added new return codes required by the Meishar-without-prescription
								// enhancement (CR #15092).
								ErrorCodeToAssign = flg = 0;	// Set to 1 in switch below if we've hit a fatal error.

								switch (err)
								{
									case enCommFailed:				ErrorCodeToAssign = ERR_GADGET_COMM_PROBLEM;		break;	// Communications error.

									case enAlreadyPurchased:		ErrorCodeToAssign = ERR_GADGET_ALREADY_BOUGHT;		break;	// Member has already bought one of these gadgets.

									case enNoAppropriateInsurance:	ErrorCodeToAssign = ERR_GADGET_NO_INSURANCE;		break;	// Member is ineligible.

									case enPharmacyNotExist:
									case enUnknownPharmacy:
									case enCalculationError:
									case IdNumberNotFound:			ErrorCodeToAssign = ERR_GADGET_ERROR;				break;	// Various "bad data" errors.

									case enPay2MonthLate:
									case IdNumberIndebted:			ErrorCodeToAssign = ERR_GADGET_DEADBEAT_MEMBER;		break;	// Member owes money.

									case enNoAccordance:			flg = 1;	// Sets severe error stuff after the switch.
																	ErrorCodeToAssign = ERR_GADGET_REQ_DISCREPANCY;		break;	// This is a severe error!

									case enNotEligible:				ErrorCodeToAssign = ERR_GADGET_NOT_ELIGIBLE;		break;

									case Rejected_TrafficAccident:	ErrorCodeToAssign = ERR_GADGET_TRAFFIC_ACCIDENT;	break;


									// DonR 11Oct2018 CR #15092: New Meishar error codes dealing with pregnancies (for the
									// Meishar-without-prescription enhancement).
									case PregQtyNotYetUtilized:		ErrorCodeToAssign = GADGET_PREG_QTY_NOT_USED;		break;
									case PregNoOpenPregCheck:		ErrorCodeToAssign = GADGET_PREG_NO_BASKET_OPENED;	break;
									case PregWaitPeriodNotPassed:	ErrorCodeToAssign = GADGET_PREG_STILL_WAIT_PERIOD;	break;
									case PregBadMeisharInputData:	ErrorCodeToAssign = GADGET_PREG_BAD_INPUT_DATA;		break;
									case PregZeroBalance:			ErrorCodeToAssign = GADGET_PREG_ZERO_IN_BASKET;		break;
									case PregQuantityProblem:		ErrorCodeToAssign = GADGET_PREG_BASKET_QTY_PROBLEM;	break;
									case PregRejectedOtherReason:	ErrorCodeToAssign = GADGET_PREG_REJECTED_OTHER;		break;
									case PregPeriodQuantityAllUsed:	ErrorCodeToAssign = GADGET_PREG_PERIOD_QTY_USED;	break;


									case enHasEligibility:		// Member is eligible.

										// DonR 22Jan2019: If pharmacy didn't supply the Gadget Code, fill it in from what we
										// read in the Gadgets table.
										if (SPres[i].LinkDrugToAddition < 1)
											SPres[i].LinkDrugToAddition = GadgetCodeFound;

										if (QuantityPermitted < SPres[i].Op)
										{
											// DonR 13Dec2010: Reduce OP only if the Quantity Permitted by AS/400
											// was *less* than the quantity requested.
											SPres[i].Op = QuantityPermitted;

											switch (Insurance)
											{
												case 1:		ErrorCodeToAssign = ERR_GADGET_OP_REDUCED_BASIC;	break;
												case 2:		ErrorCodeToAssign = ERR_GADGET_OP_REDUCED_MAGEN;	break;
												case 3:		ErrorCodeToAssign = ERR_GADGET_OP_REDUCED_KEREN;	break;
												case 7:		ErrorCodeToAssign = ERR_GADGET_OP_REDUCED_YAHALOM;	break;
												default:	ErrorCodeToAssign = ERR_GADGET_OP_REDUCED_UNKNOWN;	break;
											}	// Switch on insurance type returned by Meishar.
										}	// Meishar authorized a lower quantity than requested.
										else
										{
											switch (Insurance)
											{
												case 1:		ErrorCodeToAssign = ERR_GADGET_APPROVED_BASIC;		break;
												case 2:		ErrorCodeToAssign = ERR_GADGET_APPROVED_MAGEN;		break;
												case 3:		ErrorCodeToAssign = ERR_GADGET_APPROVED_KEREN;		break;
												case 7:		ErrorCodeToAssign = ERR_GADGET_APPROVED_YAHALOM;	break;
												default:	ErrorCodeToAssign = ERR_GADGET_APPROVED_UNKNOWN;	break;
											}	// Switch on insurance type returned by Meishar.
										}	// Meishar authorized at least as many units as requested.

	//									// DonR 20Jul2010: Meishar sends per-unit participation, NOT total participation.
	//
										// DonR 15Dec2015: It's possible that "Meishar" is overriding participation granted according
										// to as AS/400 ishur. If this is the case, clear out any ishur-about-to-expire warnings,
										// since they are not relevant.
										// It's possible that other ishur-related warnings or errors should also be suppressed.
										// DonR 17Jul2016: The Meishar ("gadget") application can override participation
										// from AS/400 ishurim. In this case, we need to zero out the ishur number, so
										// that we don't confuse other parts of the system.
										if (SPres[i].ret_part_source.table == FROM_SPEC_PRESCS_TBL)
										{
											SetErrorVarDelete (ERR_ISHUR_EXPIRY_15_WARNING,		SPres[i].DrugCode);
											SetErrorVarDelete (ERR_ISHUR_EXPIRY_30_WARNING,		SPres[i].DrugCode);
											SetErrorVarDelete (ERR_ISHUR_EXPIRY_45_WARNING,		SPres[i].DrugCode);

											SPres[i].SpecPrescNum		= 0;
											SPres[i].SpecPrescNumSource	= 0;
											SPres[i].IshurTikraType		= 0;
										}

										// DonR 02Sep2004: If more than one unit is being sold and authorized,
										// Meishar sends us the total participation, not the per-unit participation.
										// We have to change the participation to a per-unit basis, since this
										// is what the pharmacy expects.
										if (QuantityPermitted > 1)
											PtnPrice /= QuantityPermitted;

										SPres[i].RetPartCode					= 1;
										SPres[i].PriceSwap						= PtnPrice;
										SPres[i].ret_part_source.table			= FROM_GADGET_APP;


										// DonR 25Dec2007: Per Iris Shaya, if we're getting participation
										// from the AS400 "Shaban" application, turn member discounts off.
										SPres[i].in_health_pack					= 0;

										// DonR 09Jan2012: On the other hand (see above), if "Meishar" has authorized
										// participation of zero, we want to force in a 100% discount to clarify matters
										// for pharmacy systems and the AS/400.
										if (PtnPrice == 0)
											SPres[i].AdditionToPrice = 10000;


										switch (Insurance)
										{
											case 1:
											case 2:
											case 3:
											case 7:		SPres[i].ret_part_source.insurance_used	= Insurance;		break;

											default:	SPres[i].ret_part_source.insurance_used	= BASIC_INS_USED;	break;
										}

										// DonR 23Dec2014: "Meishar" can now send an "error code" that is not really an error. 
										// In this case, the code will be sent by the "listener" program in the field that was
										// originally used to send back the Prescription ID (which we weren't paying any
										// attention to anyway). We will now use this code to supply extra messages to the
										// pharmacy.
										// NOTE THAT SINCE THIS IS AN "EXTRA" MESSAGE CODE, WE CAN'T USE ErrorCodeToAssign LOGIC
										// FOR THIS ONE - WE DON'T WANT TO OVERWRITE OTHER MEISHAR MESSAGE CODES!
										switch (MeisharInfoCode)
										{
											case Approved_WorkAccident:	SetErrorVarArr (&SPres[i].DrugAnswerCode,
																						GADGET_APPROVED_WORK_ACCIDENT,
																						v_DrugCode, i + 1,
																						NULL, &ErrOverflow);
																		break;

											default:					break;
										}

										// DonR 28Feb2024 User Story #551403: If this Meishar call was qualified
										// by a particular number of previous drug purchases *and* Meishar actually
										// authorized the sale, we want to disable "normal" Drug Purchase Limit
										// checking and make a "note" that Meishar did our "limit checking" for us.
										if (GadgetPrevPurchaseClassCode > 0)
										{
											SPres[i].HasIshurWithLimit	= true;
											SPres[i].qty_limit_chk_type	= MEISHAR_PURCHASE_LIMIT;
										}

										break;	// case enHasEligibility - Member is eligible.



									default:						ErrorCodeToAssign = ERR_GADGET_ERROR;				break;	// Strange error.
								}	// End of Meishar return-code switch.


								if (ErrorCodeToAssign > 0)	// Note that this should always be true, since all CASE's assign a code.
								{
									// DonR 05Mar2024 User Story #551403: If the member is getting "hishtatfut" from an
									// AS/400 ishur (and not from Meishar) suppress Meishar-related error messages.
									if (SPres[i].ret_part_source.table != FROM_SPEC_PRESCS_TBL)
									{
										SetErrorVarArr (&SPres[i].DrugAnswerCode, ErrorCodeToAssign, v_DrugCode, i + 1, NULL, &ErrOverflow);
									}
								}

								// If we got an AS400 return code indicating a fatal problem, break out
								// of dummy loop.
								if (flg != 0)
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
									SPres[i].DFatalErr = MAC_TRUE;
									break;
								}

							}	// This is a prescription sale, OR member used a current magnetic card.

						}	// DonR 18Sep2011: Need to query AS400 for "gadget" eligibility.

					}	// Item in gadgets table being bought with prescription at Maccabi (or eligible private) pharmacy.


					// Member discount percent calculation.
					//
					// Member discounts apply if:
					//
					// A) The drugs are being bought with a prescription.
					//
					// B) The member is entitled to a discount: Either by having Member Rights 7 or 17
					//    (entitled to a 100% discount) or with an explicit discount level set by
					//    Member Discount Percent.
					//    DonR 04Dec2014: Member can also get an automatic 100% discount if s/he has
					//    a match between his/her serious-illness bitmap and the drug's illness bitmap.
					//    This is implemented with the new macro GETS_100PCT_DISCOUNT.
					//
					// C) Drug is in Health Pack (i.e. "The Basket") - this can be set from drug_list,
					//    drug_extension, spclty_largo_prcnt, or an AS400 ishur.
					//    WORKINGPOINT: Should we be getting in_health_pack from the preferred drug
					//    when "participation swapping" is going on?
					//    DonR 03Jan2008: Yes, we should!
					//
					// D) The drug's Largo Type is equal to 'T' or 'M'.
					//
					// DonR 29Dec2014: In order to provide a message to pharmacies when a member with a
					// serious illness has to pay for prescribed drugs that are not relevant to that illness,
					// change the order of the logic a bit. The new macro MEMBER_GETS_DISCOUNTS tells us
					// that the member is entitled to discounts at least some of the time, but may not get
					// a discount on any particular medication.
					// DonR 11Feb2015: If we are actually selling a non-preferred drug under "preferred" conditions, the
					// preferred drug's in-health-basket flag will already have been copied to the regular in_health_pack
					// variable; and if we're *not* using the preferred drug's conditions (e.g. if we found a rule
					// of some sort that gives less than 100% participation for the non-preferred drug), we don't want
					// to use the preferred drug's in-health-basket flag. Accordingly, we want to test only the "regular"
					// health-basket flag for Condition C!
					// DonR 24Mar2015: For the moment, we're backing out the change from 11Feb2015.
					// DonR 30Jun2015: Restoring the change from 11Feb2015.
					// DonR 28Mar2016: Add capability for bypassing the health-basket requirement for particular illnesses.
					// DonR 13May2020 CR #31591: Use Largo Type lists from Sysparams to qualify discounts instead of
					// hard-coded values. For flexibility, use separate lists for illness-based and non-illness-based discounts,
					// as well as the new category of "ventilator" discounts. The comparision between a drug's Largo Type and these
					// lists is performed in read_drug() and stored in DL.IllnessDiscounts/VentilatorDiscounts/NonIllnessDiscounts.
					// E) Marianna 22Feb2024 User Story #540234 -  Disable member discounts for Cannabis Sale
					if ( (SPres[i].PrescSource != RECIP_SRC_NO_PRESC)										&&	// Condition (A).
						 (SPres[i].PrescSource != RECIP_SRC_EMERGENCY_NO_RX)								&&	// Condition (A).
						 (MEMBER_GETS_DISCOUNTS)															&&	// Condition (B).
						 ((SPres[i].in_health_pack != 0)	|| (IGNORE_HEALTH_BASKET (SPres[i].DL)))		&&	// Condition (C).
						 ((SPres[i].DL.IllnessDiscounts)	|| (SPres[i].DL.VentilatorDiscounts) || (SPres[i].DL.NonIllnessDiscounts)) &&	// Condition (D) - revised by CR #31591.
						 (!CannabisForce100Percent)	)																	// Condition (E): not cannabis sale
					{
						// DonR 07Aug2003: Per Iris Shaya, deleted the condition that would skip the
						// discount for a drug with DFatalErr set TRUE. This was done because we want
						// to see discounts even if there's been an overdose/interaction detected.
						//
						// DonR 03Feb2004: If there is a Special Prescription, the drug's in_health_pack flag
						// has already been set based on the value in the special_prescs table. If the Special
						// Prescription specifies that the drug is not in the health basket, no discount
						// should be given.
						//
						// DonR 25Dec2007: Per Iris Shaya, member discounts are no longer conditioned
						// on any particular participation code.
						//
						// DonR 11Feb2003: In all cases other than MemberRights = 7 or 17 or a bitmap match
						// (i.e. 100% discount), the level of discount will be stored in
						// Member Discount Percent.
						// DonR 02Oct2018 CR #13262: In some cases (cancer, at least) we need to qualify
						// member/drug combination based on matching Diagnosis Codes in order to grant
						// a 100% discount.
						//
						// DonR 13May2020 CR #31591: Add a new category of "ventilator" discounts. These are
						// given for members with their VentilatorDiscount flag set non-zero (currently comes
						// from members/asaf_code, which should be renamed when we migrate to MS-SQL), for
						// all items with Largo Type matching a list - currently "B", "Y", or "D".
						if (((Member.VentilatorDiscount) && (SPres[i].DL.VentilatorDiscounts))	||
							(GETS_100PCT_DISCOUNT_WITHOUT_DIAGNOSIS (SPres[i].DL)))
						{
							SPres[i].AdditionToPrice	= 10000;
							SPres[i].member_diagnosis	= 0;	// Redundant re-initialization - pure paranoia.
						}
						else
						{
							if (GETS_100PCT_DISCOUNT_WITH_DIAGNOSIS (SPres[i].DL))
							{
								// If we get here, we need to see if one or more of the member's diagnoses
								// corresponds with a listed diagnosis for the drug being sold.
								MatchingDiagnosis = 0;

								ExecSQL (	MAIN_DB,
											READ_Find_member_diagnosis,
											Find_diagnosis_from_member_diagnoses,
											&MatchingDiagnosis,
											&SPres[i].DrugCode,		&v_MemberIdentification,
											&v_IdentificationCode,	END_OF_ARG_LIST				);

								// If we didn't get a positive count(*) and a valid SQL result code, check against
								// additional member diagnoses in the special_prescs table.
								if ((SQLCODE != 0) || (MatchingDiagnosis < 1))
								{
									ExecSQL (	MAIN_DB,
												READ_Find_member_diagnosis,
												Find_diagnosis_from_special_prescs,
												&MatchingDiagnosis,
												&SPres[i].DrugCode,		&v_MemberIdentification,
												&SysDate,				&SysDate,
												&v_IdentificationCode,	END_OF_ARG_LIST				);
								}


								if ((SQLCODE == 0) && (MatchingDiagnosis > 0))
								{
									SPres[i].AdditionToPrice	= 10000;
									SPres[i].member_diagnosis	= MatchingDiagnosis;
								}
							}	// 100% discount conditional on diagnosis-code match.
						}	// Did *not* grant a 100% discount based on non-diagnosis match. 

						if (SPres[i].AdditionToPrice != 10000)	// No 100% discount - does member have a discount percentage set?
						{
							// Marianna 29Mar2022 Epic 232192:
							// DonR 17Nov2022 User Story 297991: The original specification for Epic 232192 was not
							// written properly in ADO, so a couple of conditions were left out. The conditional
							// 100% discount should exist *only* for "treatment" drugs and "medical foods" (Largo
							// Type == 'T' or 'M'), and it should apply only when "in Health Basket" is TRUE.
							if ((Member.mem_id_extension	== 9)										&&
								(Member.darkonai_type		== 2)										&&	// Harel Foreign Workers.
								((SPres[i].DL.largo_type	== 'T') || (SPres[i].DL.largo_type == 'M'))	&&	// DonR 17Nov2022 User Story 297991.
								(SPres[i].in_health_pack	!= 0))											// DonR 17Nov2022 User Story 297991.
							{
								GET_MEMBER_PRICE_ROW (SPres[i].RetPartCode, &PriceRow);
								
								// Marianna 24Mar2022 Epic 232192: Type 2 Darkonaim get a 100% discount if the participation
								// percentage is less or equal to a configurable value - currently 15%.
								if ((PriceRow.member_price_prcnt <= DarkonaiMaxHishtatfutPct))
								{
									SPres[i].AdditionToPrice = 10000; // 100% discount
								} // Get 100% discount darkonai 
							}
							
							// DonR 12Jan2004: Make sure we don't overwrite a big discount with a little one.
							// DonR 13May2020 CR #31591: For flexibility, make this discount conditional on
							// the drug's NonIllnessDiscounts flag, which is set by read_drug() based on whether
							// the drug's Largo Type matches the list set in sysparams/memb_disc_4_types.
							if ((SPres[i].DL.NonIllnessDiscounts) && (Member.discount_percent > SPres[i].AdditionToPrice))
								SPres[i].AdditionToPrice = Member.discount_percent;
						}	// else - member has a discount percentage set.

						// If member isn't getting a 100% discount (s/he may have a lower percentage, or zero)
						// AND there is participation for this drug, AND the sale is at a Maccabi pharmacy,
						// AND the member has a serious-illness code that would give 100% discount for some drugs,
						// send a message to indicate that member has to pay some "hishtatfut". This should
						// happen only when a member is seriously ill but buys a drug that is not relevant
						// to that illness. Since we don't want to send this message more than once per sale,
						// it's sent at the "header" level, with Largo Code = 0. (Note: only Maccabi pharmacies
						// get this message for now - this may change in future.)
						if ((Member.illness_bitmap)										&&	// Member has a serious illness
							(SPres[i].AdditionToPrice < 10000)							&&	// Not giving 100% discount
							(SPres[i].RetPartCode != 4)									&&	// Not giving 0% from Member Price Code
							(MACCABI_PHARMACY))
						{
							SetErrorVarArr (&v_ErrorCode, DRUG_DISEASE_MISMATCH_NO_DISCOUNT, 0, 0, NULL, &ErrOverflow);
						}
					}	// Member may be entitled to a discount.


					// If participation is 100% (without Fixed Price) after all our machinations, AND
					// better specialist participation is allowed for this drug and member's insurance
					// type, send a warning message to pharmacy.
					// DonR 16May2006: Kishon Divers (who are supposed to get their medications
					// direct from the government) pay 100% unconditionally. This means that
					// they will get participation code 1 (= 100%) even for drugs that everyone
					// else pays 15% for. We don't want to send warning messages in this case!
					//
					// DonR 01Apr2008: Per Iris Shaya, do not send this error code for purchases
					// of dentist- or home-visit-prescribed drugs.
					// DonR 10Jul2011: Since we now can report multiple errors for each drug, suppress
					// this test only if a fatal error has already occurred.
					// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
					// DonR 12Jun2012: New macro FULL_PRICE_NO_ISHUR_ETC with some additional conditions.
					if ((FULL_PRICE_NO_ISHUR_ETC(i))												&&	// DonR 09Jan2012
						((SPres[i].DL.specialist_drug	>  0) || (PR_AsIf_Preferred_SpDrug[i] > 0))	&&
						(SPres[i].PrescSource			!= RECIP_SRC_DENTIST)						&&
						(SPres[i].PrescSource			!= RECIP_SRC_HOME_VISIT))
					{
						ExecSQL (	MAIN_DB, READ_test_for_ERR_SPCLTY_LRG_WRN,
									&RowsFound,

									&SPres[i].DrugCode,				&PR_AsIf_Preferred_Largo[i],
									&Member.MemberMaccabi,			&Member.MemberHova,
									&Member.MemberKeva,				&ROW_NOT_DELETED,
									&Member.insurance_type,			&Member.current_vetek,
									&Member.prev_insurance_type,	&Member.prev_vetek,
									END_OF_ARG_LIST												);

						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
							break;
						}
						else
						{
							if (RowsFound > 0)
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_SPCLTY_LRG_WRN,
												SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}
						}
					}


					// DonR 28Mar2004: Per Iris Shaya, if member could get a discount by going to a Maccabi
					// pharmacy, send a warning message.
					// DonR 15Feb2011: Tuned WHERE clause for better performance.
					// DonR 23Mar2011: Use the drug_list rule_status flag so we don't do a table lookup for
					// drugs that aren't in drug_extension.
					// DonR 10Jul2011: Since we now can report multiple errors for each drug, suppress
					// this test only if a fatal error has already occurred.
					// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
					// DonR 12Jun2012: New macro FULL_PRICE_NO_ISHUR_ETC incorporating more "standard" conditions.
					if ((FULL_PRICE_NO_ISHUR_ETC(i))									&&	// DonR 12Jun2012
						((SPres[i].DL.rule_status > 0) || (PR_AsIf_RuleStatus[i] > 0)))		// DonR 23Mar2011
					{
						// DonR 22Mar2011: In order to avoid checking the drug_extension table three times
						// when there are no rules applicable to this member, perform an extra lookup just
						// to see if there is something there. In theory at least, this should reduce the
						// average number of lookups.
						ExecSQL (	MAIN_DB, READ_test_for_SomeRuleApplies,
									&RowsFound,
									&SPres[i].DrugCode,		&PR_AsIf_Preferred_Largo[i],
									&Member.age_months,		&Member.age_months,
									&v_MemberGender,		&SysDate,
									&Member.MemberMaccabi,	&Member.MemberHova,
									&Member.MemberKeva,		END_OF_ARG_LIST					);

						// Don't bother with error-checking here; just say that if we got a valid response
						// from SQL *and* no rows were found, we set the flag FALSE, otherwise we continue
						// with the "real" table lookups, which do have error-checking.
						// DonR 04Jun2020: If SQLCODE is 100 (= not found), that's the equivalent of
						// SQLCODE == 0 && RowsFound == 0.
						// DonR 22Jun2020: The ODBC interface routine now has logic that automatically
						// converts SQLCODE = 100 to COUNT = 0 under appropriate conditions - so the logic
						// that sets SomeRuleApplies could be simplified.
						SomeRuleApplies = (	((SQLCODE == 0) && (RowsFound == 0))		||
											(SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)) ? 0 : 1;
if ((SQLCODE != 0) && (SQLERR_code_cmp (SQLERR_not_found) == MAC_FALSE)) GerrLogMini (GerrId, "SomeRuleApplies test: SQLCODE = %d, RowsFound = %d, SomeRuleApplies = %d.", SQLCODE, RowsFound, SomeRuleApplies);				

						if (SomeRuleApplies)
						{
							// Check for discount available at Maccabi pharmacy.
							ExecSQL (	MAIN_DB, READ_test_for_ERR_DISCOUNT_AT_MAC_PH_WARN,
										&RowsFound,

										&SPres[i].DrugCode,				&PR_AsIf_Preferred_Largo[i],
										&Member.age_months,				&Member.age_months,
										&v_MemberGender,				&Phrm_info.pharmacy_permission,
										&Phrm_info.pharmacy_permission,	&ROW_NOT_DELETED,
										&Member.MemberMaccabi,			&Member.MemberHova,
										&Member.MemberKeva,				&SysDate,
										&Member.insurance_type,			&Member.current_vetek,
										&Member.prev_insurance_type,	&Member.prev_vetek,
										END_OF_ARG_LIST														);

							Conflict_Test (reStart);

							if (SQLERR_error_test ())
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								break;
							}
							else
							{
								if (RowsFound > 0)
									SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DISCOUNT_AT_MAC_PH_WARN,
													SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}
						}	// At least one drug_extension rule is applicable to this member.
					}	// Full-price sale, no fatal errors, etc., and there is a "nohal" for this drug.

					// DonR 12Jun2012: If this sale is discounted, an AS/400 ishur is being used, the
					// member is a Kishon diver, a fatal error has occurred for this drug, or the drug
					// doesn't have any nohalim, set the flag SomeRuleApplies to zero so that we don't
					// have to make the same tests again.
					// DonR 09Aug2021 User Story #163882: Another condition that applies is where the
					// purchaser is a darkonai-plus who doesn't receive any discounts other than "shovarim".
					else
					{
						SomeRuleApplies = 0;	// We know no rules apply even without reading drug_extension.
					}


					// DonR 11May2004: Per Iris Shaya, if member could get a discount according to some
					// rule with Authorizing Authority between 1 and 49, send a warning message.
					// DonR 11Aug2005: Per Iris Shaya, change the confirm_authority select
					// to examine only rules for low-level authority (less than 25).
					// DonR 14May2007: If member has an Ishur with "tikra", we don't need to
					// give this message.
					//
					// DonR 01Apr2008: Per Iris Shaya, do not give this warning message
					// for purchases of dentist- or home-visit-prescribed drugs.
					// DonR 15Feb2011: Tuned WHERE clause for better performance.
					// DonR 23Mar2011: Use the drug_list rule_status flag so we don't do a table lookup for
					// drugs that aren't in drug_extension.
					// DonR 10Jul2011: Since we now can report multiple errors for each drug, suppress
					// this test only if a fatal error has already occurred.
					// DonR 27Dec2011: This message applies to all ishur possibilities - so widen the
					// confirm_authority check to include everything greater than zero.
					// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
					// DonR 12Jun2012: SomeRuleApplies now implies that a whole bunch of conditions have been
					// met: the sale is not discounted or subject to an AS/400 ishur, the member isn't a Kishon
					// diver, the drug has a "nohal", and so on; so there's no point in testing the same
					// variables again!
					// DonR 13Jun2012: Give different messages for different forms of available ishur.
					if ((SomeRuleApplies)											&&
						(SPres[i].PrescSource			!= RECIP_SRC_DENTIST)		&&
						(SPres[i].PrescSource			!= RECIP_SRC_HOME_VISIT))
					{
						ErrorCodeToAssign = 0;	// Default: no ishur discount possible.

						// First, see if there is a pharmacy-ishur-level rule available to the selling pharmacy,
						// based on its permission type.
						// DonR 25Apr2023 User Story #432608: Give the "pharmacy ishur possible" warnings *only* to
						// pharmacies that are authorized to create "nohal-based" pharmacy ishurim. The easiest way
						// to do this is simply not to look for nohalim if the pharmacy isn't authorized to use them.
						// DonR 04Jul2023 User Story #432608 BUG FIX: If PHARM_NOHAL_ENABLED is FALSE, just set
						// RowsFound to zero rather than simulate a not-found error - which was being treated as an
						// actual database error.
						// DonR 20Feb2024 User Story #540566: These "pharmacy ishur possible" messages are *not*
						// dependent on the pharmacy actually being enabled to issue pharmacy ishurim - although
						// which message to send *does* depend on whether the pharmacy can issue the ishur.
						ExecSQL (	MAIN_DB, READ_test_for_discount_with_pharmacy_ishur,
									&RowsFound,

									&SPres[i].DrugCode,					&PR_AsIf_Preferred_Largo[i],
									&Member.age_months,					&Member.age_months,
									&v_MemberGender,					&SysDate,
									&ROW_NOT_DELETED,					&Member.MemberMaccabi,
									&Member.MemberHova,					&Member.MemberKeva,
									&Phrm_info.pharmacy_permission,		&Phrm_info.pharmacy_permission,
									&Phrm_info.pharmacy_permission,		&Member.insurance_type,
									&Member.current_vetek,				&Member.prev_insurance_type,
									&Member.prev_vetek,					END_OF_ARG_LIST						);

						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
							break;
						}
						else
						{
							if (RowsFound > 0)	// Found a pharmacy-ishur rule for this pharmacy's permission type.
							{
								// DonR 21Feb2024: If the pharmacy is able to issue the pharmacy ishur, send the
								// "ishur is possible" message regardless of the pharmacy's "harsha'ot"; and if
								// the pharmacy is not authorized (but another pharmacy of same type might be),
								// send ERR_ISHUR_DISCNT_PRATI_PLUS (which could go to a non-Prati-Plus pharmacy
								// now). If no pharmacy nohal was found that will work for this pharmacy type, we
								// check below for a nohal that might work at a different pharmacy type or might
								// permit an AS/400 ishur to be created; if we find something, we'll send
								// ERR_UNSPEC_ISHUR_DISCNT_AVAIL.
								ErrorCodeToAssign = (PHARM_NOHAL_ENABLED)	? ERR_DISCOUNT_WITH_PH_ISHUR_WRN
																			: ERR_ISHUR_DISCNT_PRATI_PLUS;

							}	// Found at least one applicable pharmacy "nohal".

							else
							// If no pharmacy-ishur rule was found for the selling pharmacy's permission type,
							// perform a more general check that includes all pharmacy types and all confirmation-
							// authority levels (including "nohalim" for AS/400 ishurim).
							{
								ExecSQL (	MAIN_DB, READ_test_for_ERR_UNSPEC_ISHUR_DISCNT_AVAIL,
											&RowsFound,

											&SPres[i].DrugCode,				&PR_AsIf_Preferred_Largo[i],
											&Member.age_months,				&Member.age_months,
											&v_MemberGender,				&SysDate,
											&ROW_NOT_DELETED,				&Member.MemberMaccabi,
											&Member.MemberHova,				&Member.MemberKeva,
											&Member.insurance_type,			&Member.current_vetek,
											&Member.prev_insurance_type,	&Member.prev_vetek,
											END_OF_ARG_LIST													);

								Conflict_Test (reStart);

								if (SQLERR_error_test ())
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}
								else
								{
									if (RowsFound > 0)	// Found a rule.
									{
										ErrorCodeToAssign = ERR_UNSPEC_ISHUR_DISCNT_AVAIL;
									}
								}	// No database error looking for general non-automatic rules.
							}	// No pharmacy-ishur rule was found.

							// Finally, if we found something in either query, report the result to pharmacy.
							if (ErrorCodeToAssign > 0)
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, ErrorCodeToAssign,
												SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}

						}	// No database error checking drug_extension table for pharmacy-ishur rules.
					}	// Some rule applies for the member/drug and prescription source is not dentist/home visit.



					// DonR 28Mar2004: Per Iris Shaya, if member could have gotten a discount by
					// signing up for Magen Kesef or Magen Zahav, send a warning message to that effect.
					// DonR 11Aug2005: Per Iris Shaya, change the confirm_authority select
					// to examine only rules for low-level authority (less than 25).
					// DonR 15Feb2011: Tuned WHERE clause for better performance.
					// DonR 23Mar2011: Use the drug_list rule_status flag so we don't do a table lookup for
					// drugs that aren't in drug_extension.
					// DonR 10Jul2011: Since we now can report multiple errors for each drug, suppress
					// this test only if a fatal error has already occurred.
					// DonR 14Nov2011: Because Magen Kesef is being "turned off" (except for a few members who still
					// have Kesef and not Zahav), suppress the "discount if you weren't such a cheapskate" message
					// if the only rule that would give the discount is a Kesef rule.
					// DonR 20Dec2011: Per Iris Shaya, give this message only for "automatic" rules with
					// confirm_authority == 0.
					// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
					// DonR 12Jun2012: SomeRuleApplies now implies that a whole bunch of conditions have been
					// met: the sale is not discounted or subject to an AS/400 ishur, the member isn't a Kishon
					// diver, the drug has a "nohal", and so on; so there's no point in testing the same
					// variables again!
					// DonR 06Dec2012 "Yahalom": Changed SQL to reflect new "insurance_type" field; also, there is no
					// point in testing member's insurance status in SQL, since it's faster to check it in normal C code.
					// DonR 11Dec2012 "Yahalom": Add a new message (6149) if a "Yahalom" rule exists that would be
					// applicable. Only if no Yahalom rules are found will we check for Zahav rules.
					// DonR 19Jan2015: In order to permit sales of "shaban" drugs at 100%, we need to identify not
					// only situations where member doesn't have "shaban" and would get a discount if s/he did;
					// we also need to identify situations where member *does* have "shaban", but the discount
					// wasn't granted - presumably because s/he signed up too recently for discounts to take effect.
					// in order to accomplish this, we will now test rules here even for members who do have
					// "shaban", and then apply a new, non-reported-to-pharmacy error code to indicate that the
					// member isn't getting a discount but *does* have "shaban".
					if (SomeRuleApplies)	// DonR 19Jan2015: Member may or may not have "shaban".
					{
						strcpy (InsuranceTypeToCheck, "Y");

						ExecSQL (	MAIN_DB, READ_test_for_Maccabi_Sheli_or_Zahav_rule,
									&RowsFound,				&PossibleInsuranceType,

									&SPres[i].DrugCode,		&PR_AsIf_Preferred_Largo[i],
									&Member.age_months,		&Member.age_months,
									&v_MemberGender,		&SysDate,
									&ROW_NOT_DELETED,		&Member.MemberMaccabi,
									&Member.MemberHova,		&Member.MemberKeva,
									&InsuranceTypeToCheck,	END_OF_ARG_LIST					);
//GerrLogMini (GerrId, "READ_test_for_Maccabi_Sheli_or_Zahav_rule returns %d/%s, SQLCODE %d.", RowsFound, PossibleInsuranceType, SQLCODE);


						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
							break;
						}

						// If we got here, we know that member doesn't have Yahalom. If (A) no Yahalom
						// rules were found, and (B) member doesn't have Zahav either, check for applicable
						// Zahav rules. Note that we don't need to check for previous Zahav insurance, since
						// the only members for whom previous Zahav insurance is relevant are those with Yahalom.
						if (RowsFound < 1)		// DonR 19Jan2015: Member may or may not have "shaban".
						{
							strcpy (InsuranceTypeToCheck, "Z");

							ExecSQL (	MAIN_DB, READ_test_for_Maccabi_Sheli_or_Zahav_rule,
										&RowsFound,				&PossibleInsuranceType,

										&SPres[i].DrugCode,		&PR_AsIf_Preferred_Largo[i],
										&Member.age_months,		&Member.age_months,
										&v_MemberGender,		&SysDate,
										&ROW_NOT_DELETED,		&Member.MemberMaccabi,
										&Member.MemberHova,		&Member.MemberKeva,
										&InsuranceTypeToCheck,	END_OF_ARG_LIST					);

							Conflict_Test (reStart);

							if (SQLERR_error_test ())
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								break;
							}
						}	// No Yahalom rules were found, and member doesn't have Zahav.

						// If at least one applicable rule was found, send the appropriate message.
						// DonR 19Jan2015: Add a third "error" to indicate that member *does* have appropriate
						// insurance but still didn't get a discount - presumably because the new insurance is
						// not yet in force.
						if (RowsFound > 0)
						{
							if ((*PossibleInsuranceType == 'Y') && (Member.InsuranceType != 'Y'))
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DISCOUNT_IF_HAD_YAHALOM, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}
							else
							if ((*PossibleInsuranceType == 'Z') && (Member.InsuranceType != 'Z') && (Member.InsuranceType != 'Y'))
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_DISCOUNT_IF_HAD_ZAHAV, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}
							else
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, SHABAN_NOT_YET_APPLICABLE, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}
						}

					}	// Some rule applies AND member doesn't have Yahalom.


					// DonR 14Sep2021 User Story #163882: All the Maccabi Price / Sale Price / MaccabiCare
					// discounts are disabled for "Type 1" Darkonaim (people who pay 100% for everything)
					// when they're buying stuff with a prescription.
					// DonR 18Nov2021 User Story #196891: Add support for Largo-specific blocking.
					if (((!Member.force_100_percent_ptn) && (!SPres[i].LargoBlockedForMember)) || (SPres[i].PrescSource == RECIP_SRC_NO_PRESC))
					{
						// 11Dec2003: Per Iris Shaya, substituting the Maccabi Price is a last resort.
						// Therefore, we should do it *after* checking for Pharmacy Ishur.

						// 25Mar2003: Per Iris Shaya, the logic for use of Maccabi Price is changing.
						// For normal participation calculation, we will always use the Yarpa
						// (i.e. regular) price; at the end, we'll use the Maccabi Price as
						// a fixed participation price if:
						//     A) A Maccabi Price exists for this drug in the pharmacy's default price list;
						//     B) Participation is 100%; and
						//     C) No fixed participation has been set from other sources, such as
						//        Drug-Extension.
						// Note that we're assuming that the Maccabi Price will be less than the
						// regular price!

						// 18Apr2004: This logic has to happen *before* the check for medicines that can
						// be sold only with a Special Prescription, since the Maccabi Price is a fixed
						// price that "turns off" the Special Prescription requirement check.
						// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
						// DonR 16Dec2013: If this is a sale of a "treatment"-type drug with a
						// prescription, at a Maccabi pharmacy, to a Maccabi member, Maccabi-price
						// discounts are disabled.
						// DonR 24Dec2014: We no longer disable Maccabi Price for prescription sales
						// to Maccabi members at Maccabi pharmacies; this backs out the change from 16Dec2013.
						// DonR 09Jan2019: Use Maccabi Price only if it's less than the default price.
						if ((SPres[i].MacabiDrugPrice > 0)							&&
							(SPres[i].MacabiDrugPrice < SPres[i].RetOpDrugPrice)	&&
							(FULL_PRICE_SALE(i)))
						{
							SPres[i].PriceSwap				= SPres[i].MacabiDrugPrice;
							SPres[i].MacabiPriceFlg			= MAC_TRUE;
							SPres[i].ret_part_source.table	= FROM_MACCABI_PRICE;
						}


						// DonR 28Jun2016: Add capability of getting a discounted price from the sale
						// tables sale/sale_bonus_recv.
						// DonR 11Jul2016: Re-enabled this feature, controlled by the new global flag
						// UseSaleTableDiscounts, set from sysparams/use_sale_tables.
						if ((MACCABI_PHARMACY)																	&&
							(UseSaleTableDiscounts)																&&
							(SPres[i].PrescSource	!= RECIP_SRC_NO_PRESC)										&&
//							(SPres[i].PrescSource	!= RECIP_SRC_EMERGENCY_NO_RX)								&&
							((FULL_PRICE_SALE(i))	|| (SPres[i].ret_part_source.table == FROM_MACCABI_PRICE)))
						{
							// Set up the current OP price as a default.
							Yarpa_Price		= (SPres[i].PriceSwap > 0) ? SPres[i].PriceSwap : SPres[i].RetOpDrugPrice;
							v_DrugCode		= SPres[i].DrugCode;
							SysDate_copy	= SysDate;

							ExecSQL (	MAIN_DB, READ_price_from_sale_bonus_recv,
										&Macabi_Price,
										&v_DrugCode,		&Yarpa_Price,
										&SysDate,			&SysDate_copy,
										END_OF_ARG_LIST								);

							Conflict_Test (reStart);

							if (SQLCODE == 0)
							{
								SPres[i].PriceSwap				= Macabi_Price;
								SPres[i].MacabiPriceFlg			= MAC_TRUE;
								SPres[i].ret_part_source.table	= FROM_MACCABI_PRICE;
							}
						}


						// 21Dec2006: Per Iris Shaya, if after everything else the member is still
						// paying 100% with no fixed-price reduction, AND the sale is at a Maccabi
						// pharmacy, AND we aren't already working with the MaccabiCare price (i.e.
						// the price-list code we already read is *not* 800), AND a MaccabiCare price
						// exists, then use it.
						// 23Feb2008: Moved all the Price List 800 stuff down here. We use the
						// Maccabi Price from this price list if:
						// A) We haven't found any other discount;
						// B) The selling pharmacy and the drug are both in the Maccabicare program.
						// C) The sale is at a Maccabi pharmacy, OR it's a prescription sale (in
						//    which case the type of pharmacy is irrelevant).
						// In the special case of a non-prescription sale at a private pharmacy,
						// we also use the Maccabi price from Price List 800 - but in this case we
						// treat it as the "normal" drug price, and return Participation Code 97.
						// DonR 07Apr2008: To avoid unnecessary database lookups, added an
						// additional condition here. If a non-Maccabi member is purchasing
						// a drug without a prescription at a non-Maccabi pharmacy, all the
						// Maccabicare logic is irrelevant.
						//
						// DonR 02Aug2009: Per Iris Shaya, the Maccabicare logic now applies to both
						// Maccabi members and non-Maccabi members, at all private pharmacies.
						// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
						// DonR 16Dec2013: If this is a sale of a "treatment"-type drug with a
						// prescription, at a Maccabi pharmacy, to a Maccabi member, Maccabi-price
						// discounts are disabled.
						// DonR 24Dec2014: We no longer disable Maccabi Price for prescription sales
						// to Maccabi members at Maccabi pharmacies; this backs out the change from
						// 16Dec2013.
						// DonR 28Jun2016: Add global parameter to enable/disable Price List 800
						// lookup. For now at least, this flag will always be zero, but this could
						// change in the future.
						// DonR 11Jul2016: "Flipped" the global parameter - if UseSaleTableDiscounts is
						// set true, we *don't* want to look up Maccabi Price in Price List 800. The
						// parameter is now set from sysparams/use_sale_tables. 
						// DonR 07Jan2019: In fact, the global UseSaleTableDiscounts parameter is irrelevant
						// to Price List 800 lookups. Also, read the Maccabi Price from Price List 800
						// only if it's less than the default price.
						if ((FULL_PRICE_SALE(i))						&&	// DonR 09Jan2012
							(MACCABICARE_PHARM)							&&
							(SPres[i].DL.maccabicare_flag	!= 0))
						{
							v_DrugCode	= SPres[i].DrugCode;
							Yarpa_Price	= SPres[i].RetOpDrugPrice;	// This gets overwritten if we read something, but that's harmless.

							ExecSQL (	MAIN_DB, READ_PriceList, READ_PriceList_800_conditional,
										&Yarpa_Price,	&Macabi_Price,		&Supplier_Price,
										&v_DrugCode,	&Yarpa_Price,		END_OF_ARG_LIST		);

							Conflict_Test (reStart);

							if (SQLCODE == 0)
							{
								// DonR 23Aug2011: For VAT-exempt pharmacies (e.g. in Eilat), deduct VAT from prices.
								// For now, adjust only the Yarpa price; but in future we may need to do the same
								// for the Maccabi (discounted) price.
								// DonR 19Feb2012: Added a separate price variable for calculating member participation, since Eilat
								// pharmacies are still supposed to see the VAT-inclusive price as the per-OP price.
								if (vat_exempt != 0)
								{
									SPres[i].PriceForPtnCalc = (int)(((double)Yarpa_Price * no_vat_multiplier) + .5001);
								}
								else
								{
									SPres[i].PriceForPtnCalc = Yarpa_Price;
								}

								SPres[i].YarpaDrugPrice			= Yarpa_Price;
								SPres[i].MacabiDrugPrice		= Macabi_Price;
								SPres[i].SupplierDrugPrice		= Supplier_Price;
								SPres[i].ret_part_source.table	= FROM_MACCABI_PRICE;
								// (Is the last line correct for private-pharmacy
								// non-prescription sales?

								if ((MACCABI_PHARMACY) ||
									((SPres[i].PrescSource != RECIP_SRC_NO_PRESC) && (SPres[i].PrescSource != RECIP_SRC_EMERGENCY_NO_RX)))
								{
									// "Conventional" situation: use Maccabicare price from
									// Price List 800 as a discounted fixed price.
									SPres[i].RetOpDrugPrice			= Yarpa_Price;
									SPres[i].PriceSwap				= Macabi_Price;
									SPres[i].MacabiPriceFlg			= MAC_TRUE;
									SPres[i].RetPartCode			= PARTI_CODE_MACCABICARE;	// = 17.
								}
								else
								{
									// Private pharmacy non-prescription Maccabicare sale.
									SPres[i].RetPartCode = PARTI_MACCABICARE_PVT;	// = 97.

									// DonR 05Aug2009: Bug fix - even though everyone gets Price Code 97
									// for these sales, only Maccabi members get the special Maccabi price.
									if (v_MemberBelongCode == MACABI_INSTITUTE)
										SPres[i].RetOpDrugPrice = Macabi_Price;
								}
							}	// Read something for Price List 800.

							if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
							{
								if (SQLERR_error_test ())
								{
									SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
									break;
								}
							}
						}	// Need to check for Price-list 800 price.

					}	// DonR 14Sep2021 User Story #163882 end: All the Maccabi Price / Sale Price / MaccabiCare
						// discounts are disabled for "Type 1" Darkonaim


					// DonR 04Dec2011: If the person making the purchase is a soldier and participation is 100%
					// (even if we're applying the Maccabi Price discount), send a warning message so pharmacist
					// will tell the soldier that s/he has to pay for the medication.
					// DonR 08Jan2012: If "Meishar" has given a fixed price of zero, that's a real fixed price,
					// so don't give this message.
					if ((SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)								&&
						(Member.MemberTzahal			>  0)												&&
						(SPres[i].RetPartCode			== 1)												&&
						(SPres[i].ret_part_source.table	!= FROM_GADGET_APP)									&&	// DonR 08Jan2012
						((SPres[i].PriceSwap			== 0) || (SPres[i].ret_part_source.table == FROM_MACCABI_PRICE)))
					{
						SetErrorVarArr (&SPres[i].DrugAnswerCode, WARN_TZAHAL_NO_DISCOUNT,
										SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
					}


					// DonR 25Mar2004: Per Iris Shaya, if participation is 100% (without Fixed Price)
					// after all our machinations, AND no specialist participation exists for this drug,
					// AND NO RULES EXIST for low-level authorizing  authorities for this drug, AND one
					// or more rules exist which would allow some unspecified member to get a Special
					// Prescription for this drug, send an error message to pharmacy. This combination of
					// circumstances indicates that this drug is not available without an AS400 Ishur,
					// even if the member is willing to pay 100%.
					// DonR 11Aug2005: Per Iris Shaya, change the confirm_authority select
					// to examine only rules for low-level authority (less than 25).
					//
					// DonR 26Apr2007: Per Iris Shaya, changed conditions for error 6033. We
					// don't need to check drug_extension or spclty_largo_prcnt any more; we
					// just have to check the following conditions:
					// 1) 100% participation.
					// 2) No special price.
					// 3) No AS400 ishur with "tikra" flag set for this member/drug.
					// 4) Drug has "ishur required" flag set to 9.
					//
					// DonR 13Jul2011: Per Iris Shaya, changed criterion #3 (see above) so that an
					// AS/400 ishur without its "tikra" flag set *and* without any price reduction
					// can still enable the sale of a drug.
					// DonR 09Jan2012: Replaced three conditions with macro FULL_PRICE_SALE.
					if ((FULL_PRICE_SALE(i))										&&	// DonR 09Jan2012
						(SPres[i].ret_part_source.table	!= FROM_SPEC_PRESCS_TBL)	&&
						(SPres[i].DL.ishur_required		== 9))
					{
						SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_ISHUR_POSSIBLE_ERR,
										SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
					}

					// DonR 24Jul2023 User Story #448931: Relocated the MemberPharm narcotics restriction
					// logic here, so we know the results of all the "hishtatfut" calculations. The new
					// version of the logic permits the member to "violate" the restriction under the
					// following conditions:
					//
					// 1) The drug has been flagged for this purpose (using the member_blocked_drugs table
					//    with Restriction Type 3).
					// 2) The member is normally restricted to buy narcotics at a Maccabi pharmacy. (CHANGED -
					//    SEE BELOW.)
					// 3) The drug is being sold at 100% "hishtatfut" at a private pharmacy (not on consignment).
					//
					// The reason for the new logic is that Maccabi pharmacies *can't* sell prescription
					// drugs at 100% hishtatfut, so we need to allow members some way to buy things like
					// Fentanyl patches when there's no other option.
					//
					// DonR 12Dec2006: Check drug against applicable member-pharmacy restrictions.
					// We're interested here only in Hypnotics and Narcotics.
					//
					// DonR 06Sep2023 User Story #448931 (amended): Private-pharmacy full-price
					// exceptions to member-pharmacy restrictions are now applicable whether the
					// restriction is for narcotics/hypnotics *or* for all drugs. To avoid giving
					// errors for OTC purchases, added a condition so we check only if Prescription
					// Source is non-zero. (Hypnotics/narcotics are not sold without a prescription!)
					// DonR 22Jul2025 User Story #427521: Use new is_narcotic flag instead of Drug Type.
					if (	(v_MemPharm_Exists)									&&
							(SPres[i].PrescSource != RECIP_SRC_NO_PRESC)		&&
//							((SPres[i].DL.drug_type == 'H') || (SPres[i].DL.drug_type == 'N') || (v_MemPharm_ResType == 9))	)
							((SPres[i].DL.drug_type == 'H') || (SPres[i].DL.is_narcotic) || (v_MemPharm_ResType == 9))	)
							
					{
						// DonR 14Sep2023: By default, we're going to assign the error/message code we set up
						// when we read the MemberPharm row for this member.
						ErrorCodeToAssign = MemPharm_Result;

						// DonR 24Jul2023 User Story #448931: If this sale would otherwise have been
						// blocked, determine if the conditions are right for an exception.
						if (	(MemPharm_Result								== ERR_MEMBER_PHARM_SALE_FORBIDDEN)		&&	// Not at the permitted pharmacy.
								(SPres[i].DL.bypass_member_pharm_restriction	!= 0)									&&	// Drug has a bypass enabled.
								(v_MemPharm_PermittedOwner						== 0)									&&	// Permitted pharmacy is Maccabi.
								(PRIVATE_PHARMACY)																		&&	// Current pharmacy is private.
								(!CONSIGNMENT_SALE(SPres[i].DL))														&&	// NOT a conignment sale.
								(FULL_PRICE_SALE(i))																)
						{
							// At least for now, we're *not* giving a special message code for this
							// situation - just the regular "member-pharm permitted" one.
							// DonR 08Aug2023: Use the new message code ERR_MEMBER_PHARM_EXCEPTION to
							// indicate why we're permitting this sale to go through.
							// DonR 14Sep2023: *DO NOT* overwrite MemPharm_Result, since it may be
							// relevant to other drugs in the same transaction!
							ErrorCodeToAssign = ERR_MEMBER_PHARM_EXCEPTION;
//							MemPharm_Result = ERR_MEMBER_PHARM_EXCEPTION;
						}

						// Remember that the "error code" may be just telling the pharmacy
						// that the sale is permitted!
						SetErrorVarArr (&SPres[i].DrugAnswerCode, ErrorCodeToAssign, SPres[i].DL.largo_code, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
					}	// Member with applicable restriction is buying narcotics/hypnotics.


					// DonR 04Dec2013: Maccabi pharmacies are not allowed to sell "treatment" drugs
					// with presccription to Maccabi members at full price.
					// DonR 26Dec2013: If the sale is being rejected because the person buying drugs isn't a Maccabi
					// member, don't bother giving the "100% Forbidden" error.
					// DonR 26Oct2014: take out the "flg = 1" bit, since we're adding new logic that will allow the sale
					// to go through under some conditions.
					// DonR 23Nov2014: Having a severe error code set for this drug prevented the program from
					// calling the Nihul Tikrot application; so instead, use a new "placeholder" error code, which
					// will either be converted to the real error, or else deleted.
					// DonR 24Dec2014: Give this error only for drugs that require a prescription. Error 6173
					// (COULD_BUY_WITHOUT_PRESC) is thus no longer relevant.
					// DonR 09Aug2021 User Story #163882: Darkonai-Plus purchasers who are not supposed to get any discounts
					// (other than shovarim provided by their insurance company) are allowed to buy drugs at 100% from
					// Maccabi pharmacies.
					// DonR 20Apr2023 User Story #432608: "Consignatzia" pharmacies selling drug on consignment are acting
					// as proxies for MaccabiPharm, and thus these items are also subject to the "100% forbidden" rule.
					// Marianna 22Feb2024 User Story #540234: even though MaccabiPharm is not going to sell cannabis (at least for now), 
					// some "consignatzia" pharmacies may *also* be cannabis pharmacies, and we *do* want them to be able to sell cannabis at 100% hishtatfut!
//					if ((MACCABI_PHARMACY)												&&
					if ((MACCABI_PHARMACY || (CONSIGNMENT_SALE(SPres[i].DL)))			&&	// DonR 20Apr2023 User Story #432608.
						(v_MemberBelongCode				== MACABI_INSTITUTE)			&&
						(v_ErrorCode					!= ERR_MEMBER_NOT_ELEGEBLE)		&&	// DonR 26Dec2013
						(SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)			&&
						(SPres[i].PrescSource			!= RECIP_SRC_EMERGENCY_NO_RX)	&&
						(SPres[i].DL.largo_type			== 'T')							&&
						(SPres[i].DL.no_presc_sale_flag	== MAC_FALS)					&&	// DonR 24Dec2014
						(SPres[i].ret_part_source.table	!= FROM_SPEC_PRESCS_TBL)		&&
						(Member.force_100_percent_ptn	== 0)							&&	// DonR 09Aug2021 User Story #163882
						(SPres[i].LargoBlockedForMember	== 0)							&&	// DonR 18Nov2021 User Story #196891 - or should we send the "Maccabi 100%" message anyway?
						(FULL_PRICE_SALE(i))											&&
						(!CannabisForce100Percent) )										// Marianna 22Feb2024 User Story #540234
					{
						SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_MACCABI_100_PER_CENT,
										SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
					}


					// DonR 17May2023 User Story #450542: Maccabi pharmacies are not allowed to sell prescribed items
					// at 100% participation. Private pharmacies, however, are. Normally, if a private pharmacy tries
					// to do so but there is a cheaper generic substitute, the pharmacy will get an appropriate message;
					// however, there are some items that have a Preferred Status of 3, meaning that the pharmacy *is*
					// allowed to sell them at full price even if there is a cheaper generic alternative. In this case,
					// we want to send a (new) warning message ("the Lipsky Warning"), so at least the pharmacy is aware
					// that there is a generic option. (And if they're out of stock on the generic version, they can list
					// "out of stock" as a reason to sell the non-generic item at a "generic" discount.)
					if ((PRIVATE_PHARMACY && (!CONSIGNMENT_SALE(SPres[i].DL)))			&&	// Actual private sale.
						(v_MemberBelongCode				== MACABI_INSTITUTE)			&&
						(v_ErrorCode					!= ERR_MEMBER_NOT_ELEGEBLE)		&&
						(SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)			&&
						(SPres[i].PrescSource			!= RECIP_SRC_EMERGENCY_NO_RX)	&&
						(SPres[i].ret_part_source.table	!= FROM_SPEC_PRESCS_TBL)		&&
						(Member.force_100_percent_ptn	== 0)							&&
						(SPres[i].LargoBlockedForMember	== 0)							&&
						(SPres[i].DL.preferred_flg		== 3)							&&	// Drug that private pharmacy *can* sell at full price.
						(SPres[i].DL.preferred_largo	>  0)							&&	// Drug actually does have a preferred alternative.
						(FULL_PRICE_SALE(i)))
					{
						// It appears that all drugs with Preferred Flag = 3 and non-zero Preferred Largo do in fact
						// have a valid generic equivalent - so we don't need to bother calling find_preferred_drug().

						// Note that we do *not* want to test for a fatal error here: Preferred Flag 3 basically means
						// that the pharmacy *is* allowed to complete the sale, so a warning message is all we'll send.
						SetErrorVarArr (&SPres[i].DrugAnswerCode, GENERIC_SUBSTITUTE_AVAILABLE,
										SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
					}


					// DonR 29Jun2006: If necessary, check Drug Purchase Limits.
					// Note that if the member has an AS400 Special Prescription
					// with a quantity limit for this drug, that's enough - we
					// don't need to check the Drug Purchase Limit as well.
					//
					// First, mark all drugs which are being bought at some kind
					// of discount; this allows test_purchase_limits() to run
					// faster, since it doesn't have to make the same checks
					// multiple times.
					if (i == 0)	// Do this only once!
					{
						for (is = 0; is < v_NumOfDrugLinesRecs; is++)
						{
							// Just to be paranoid, repeat the default initialization.
							SPres[is].BoughtAtDiscount = MAC_FALS;

							// DonR 08Jan2012: If "Meishar" has given a fixed price of zero, that's a real
							// fixed price - so don't look for further discount possibilities.
							// DonR 07Apr2013: Per Iris Shaya, drugs that got their participation from an AS/400
							// ishur are considered "discounted" even if they were bought at full price. (This
							// happens, for example, when they are subject to an "ishur with tikra".)
							if (((SPres[is].PriceSwap > 0) && (SPres[is].MacabiPriceFlg == 0))	||
								( SPres[is].ret_part_source.table == FROM_SPEC_PRESCS_TBL)		||	// DonR 07Apr2013
								( SPres[is].ret_part_source.table == FROM_GADGET_APP))				// DonR 08Jan2012
							{
								// Member got a fixed price other than Maccabi Price.
								SPres[is].BoughtAtDiscount = MAC_TRUE;
							}
							else
							{
								// If member paid 100% and didn't get a "real" discounted
								// fixed price, this drug was not bought at discount.
								switch (SPres[is].RetPartCode)
								{
									case  1:
									case 11:
									case 19:
									case 50:
									case PARTI_MACCABICARE_PVT:
									case 98:
												break;

									// Any other price code indicates some kind of discount.
									default:
												SPres[is].BoughtAtDiscount = MAC_TRUE;
												break;
								}	// Switch on member_price_code.
							}	// Member didn't get a discounted fixed price.
						}	// Loop through drugs to see which ones are being bought at a discount.
					}	// Execute inner loop only once.

					// If this drug needs to have Purchase Limit checking performed, go do it.
					// DonR 23Aug2010: Per Iris Shaya, Drug Purchase Limits should not be checked for those
					// special "members" with check_od_interact set FALSE.
					// DonR 01Dec2016: Added macro to implement the option of exempting ill members from
					// certain drug purchase limits. This is passed to test_purchase_limits(), since
					// prescription-source validation applies even if  "real" quantity limits do not.
					// DonR 14Dec2021 User Story #205423: If the drug is being purchased without a
					// prescription, test purchase limits without regard for whether a discount is being
					// applied. This is because new Method 7/8 limits exist for safety rather than
					// economic purposes.
					// DonR 13Feb2022: Add another way to force the system to apply Bakara Kamutit to
					// purchases: a new "purchase_lim_without_discount" flag. For now, this applies only
					// to three Libre sensors, but it may be used for other items in future.
					// DonR 23Jul2025 User Story #427783: Now there is also a "check limits including
					// full-price purchases" option at the drug_purchase_lim level, to support new
					// safety restrictions on opioids and other dangerous drugs.
					if (	(	SPres[i].DL.purchase_limit_flg > 0)	&&
							(	!SPres[i].HasIshurWithLimit)		&&
							(	Member.check_od_interact)			&&				// DonR 23Jan2018 CR #13937
							(	(SPres[i].BoughtAtDiscount					)	||
								(SPres[i].PrescSource == RECIP_SRC_NO_PRESC	)	||
								(SPres[i].PurchaseLimitIncludeFullPrice		)	||	// DonR 23Jul2025 User Story #427783
								(SPres[i].DL.purchase_lim_without_discount	)	)	)
					{
						flg = test_purchase_limits (&SPres[i],
													&SPres[0],
													v_NumOfDrugLinesRecs,
													&Member,
													MACCABI_PHARMACY,
													OVERSEAS_MEMBER,
													EXEMPT_FROM_LIMIT,
													v_PharmNum,
													&FunctionError);
					}


					// DonR 05Mar2017: If necessary, reject this drug line based on its Permit Sales flag
					// in the prescr_source table, possibly modified by an applicable Method 2 "limit"
					// from drug_purchase_lim.
					if (SPres[i].PurchaseLimitSourceReject)
					{
						SetErrorVarArr (&SPres[i].DrugAnswerCode, DRUG_RX_SOURCE_MEMBER_FORBIDDEN, SPres[i].DrugCode, i + 1, &SPres[i].DFatalErr, &ErrOverflow);
					}


					// DonR 17Jan2006: Per Iris Shaya, check for early refills.
					// DonR 21Mar2006: If this drug is being sold according to an AS400 Ishur
					// with quantity limits, there is no need to check for early refill as well.
					// DonR 23Aug2010: Per Iris Shaya, don't check for early refills for those "members"
					// exempt from OD/interaction testing.
					// DonR 21Nov2024 User Story #366220: Exclude OTC/GSL items from this logic. Also, replace
					// the previous version of the "BMT" logic to use a single strchr() call instead of three
					// comparisons OR'ed together.
					// DonR 17Dec2024 User Story #366220 UPDATE: Send early-refill warnings to private
					// pharmacies as well as MaccabiPharm.
					// DonR 25Feb2025 User Story #395096: Reverse the last change - only MaccabiPharm
					// should get these early-refill warnings.
//					if ((SPres[i].PrescSource	!= RECIP_SRC_NO_PRESC)			&&
					if ((MACCABI_PHARMACY)										&&
						(SPres[i].PrescSource	!= RECIP_SRC_NO_PRESC)			&&
						(Member.check_od_interact)								&&	// DonR 23Jan2018 CR #13937
						(!SPres[i].HasIshurWithLimit)							&&	// DonR 21Mar2006.
						(strchr ("BMT",	SPres[i].DL.largo_type)	!= NULL)		&&	// DonR 21Nov2024: Instead of three different "==" conditions OR'ed.
						(strchr ("OQ",	SPres[i].DL.drug_type)	== NULL))			// DonR 21Nov2024 User Story #366220: Exclude OTC/GSL items.
					{
						MaxRefillDate	= IncrementDate (SysDate, (0 - min_refill_days));

						// DonR 24Nov2024 User Story #366220: Select prior sales of generic equivalents
						// as well as sales of the drug currently being sold.
						ExecSQL (	MAIN_DB, READ_check_for_early_refill,
									&RowsFound,
									&v_MemberIdentification,		&SPres[i].DrugCode,
									&SPres[i].DL.economypri_group,	&MaxRefillDate,
									&v_IdentificationCode,			END_OF_ARG_LIST			);

						Conflict_Test (reStart);

						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							RowsFound = 0;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								break;
							}
						}

						if (RowsFound > 0)
						{
							// DonR 23Jun2024 User Story #318200: Decide whether this is an expensive drug based on
							// different prices for Maccabi doctor prescriptions versus all other prescription types.
							int	expensive_drug_prc;

							expensive_drug_prc = (SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR) ? ExpensiveDrugMacDocRx : ExpensiveDrugNotMacDocRx;

							if (SPres[i].YarpaDrugPrice >= expensive_drug_prc)
							{
								SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_EARLY_REFILL_EXPENSIVE_WARN,
												SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
							}

							// DonR 21Sep2008: Per Iris Shaya, for one special pharmacy (which sells to
							// hospitals, etc. rather than "frontally"), we want to give the early-refill
							// warning even for inexpensive drugs.
							// DonR 19Apr2010: Changed #define from ...WARNING to ...CHEAP_WARNING.
							// DonR 26Mar2014: Pharmacy 997582 works the same as Pharmacy 995482.
							else
							{
								if ((v_PharmNum == 995482) || (v_PharmNum == 997582))
								{
									SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_EARLY_REFILL_CHEAP_WARNING,
													SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
								}
							}
						}	// Found recent purchase of same drug.
					}	// Need to perform early-refill tests.

				}	// Loop through drugs prescribed.
			}	// Current action is a drug sale. (This "if" started about 1,900 lines ago!)


			// If we've hit a serious error, break out of outer loop.
			if (flg == 1)
			{
				// Note that this won't override ERR_DATABASE_ERROR or other severity >= 10 errors.
				SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
				break;
			}

		}
		while (0);
		// End of Big Dummy Loop #2.


		// We don't need to calculate participation/insurance for deletions.
		// DonR 19Feb2019: Skip participation calculations if the pharmacy isn't allowed
		// to execute this transaction at all.
		if ((v_ActionType != SALE_DELETION) && (PHARM_LEGAL_FOR_TRN))
		{
			// Calculate actual member participation for each drug being sold.
			// Also, calculate insurance stuff here, so we'll already know it when we call
			// the "Nihul Tikrot" program on AS/400.
			// DonR 12Mar2012: Added (redundant and paranoid) initialization of FullPriceTotal to the
			// for-loop.
			for (i = FullPriceTotal = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// First, calculate participation per OP.
				//
				// Fixed prices still apply (in theory) to the main ingredient of a "preparation";
				// but for all other ingredients, participation is zero even if they would normally
				// have a fixed price.
				// DonR 26Jan2011: MaccabiCare discount prices (either at Maccabi pharmacies or with a prescription)
				// are also used in calculating participation in place of the default RetOpDrugPrice.
				// DonR 08Jan2012: If "Meishar" has given a fixed price of zero, that's a real
				// fixed price.
				if (((SPres[i].RetPartCode	== 1) || (SPres[i].RetPartCode				== PARTI_CODE_MACCABICARE))	&&
					((SPres[i].PriceSwap	!= 0) || (SPres[i].ret_part_source.table	== FROM_GADGET_APP)))
				{
					if ((PreparationLinkLargo == 0) || (SPres[i].DrugCode == PreparationLinkLargo))
					{
						// DonR 25Mar2012: For members buying stuff at VAT-exempt pharmacies (i.e. in Eilat),
						// take VAT off the fixed price, UNLESS it's a fixed price received from the AS/400 "meishar"
						// application. In the latter case, VAT should already have been taken off, so we don't want
						// to take it off twice.
						// DonR 25Jun2024 User Story #327482: Eilat pharmacies already send cannabis prices with VAT
						// deducted, and we don't want to deduct it again - so add NOT IsCannabisSale to the condition.
						// This should be irrelevant for "preparations", but I'll copy the fix here just in case.
						if ((vat_exempt != 0) && (!IsCannabisSale) && (SPres[i].ret_part_source.table != FROM_GADGET_APP))
						{
							// Note that casting the result of a floating-point computation to long results in
							// truncation rather than rounding - so adding .5001 beforehand won't cause member
							// to be charged one agora for a VAT-exempt freebie.
							SPres[i].PriceSwap = (int)(((double)SPres[i].PriceSwap * no_vat_multiplier) + .5001);

							// DonR 16Dec2013: If this is a prescription purchase receiving a "Maccabi Price"
							// discount, the price needs to be rounded to the nearest 10-agorot value.
							if ((SPres[i].PrescSource			!= RECIP_SRC_NO_PRESC)		&&
								(SPres[i].PriceSwap				>  0)						&&
								(SPres[i].MacabiPriceFlg		== MAC_TRUE)				&&
								(SPres[i].ret_part_source.table	== FROM_MACCABI_PRICE))
							{
								Agorot = SPres[i].PriceSwap % 10;
								if (Agorot > 4)
									SPres[i].PriceSwap += 10;	// Round up.
								SPres[i].PriceSwap -= Agorot;	// Set the Agorot digit to zero.
							}
						}


						PtnWorkVar = (double)SPres[i].PriceSwap;
					}
					else
					{
						PtnWorkVar = 0.0;	// Non-main ingredient of "preparation".
					}
				}	// Some form of fixed-price participation.
				else
				{	// Something other than fixed-price participation.
					// If we're dealing with a "preparation", participation is based on the "chemical price" sent
					// by the pharmacy. This is used as the OP Price for the main ingredient, with all other items
					// in the sale priced at zero. If this is a conventional sale, we use the normal OP price.
					if (PreparationLinkLargo > 0)
					{
						PtnOpPrice = (SPres[i].DrugCode == PreparationLinkLargo) ? ChemicalPrice : 0.0;
					}
					else
					{
						// DonR 20Feb2012: I've made a fix for Eilat pharmacies. Since the per-package price
						// sent to pharmacies is supposed to include VAT even though these pharmacies are exempt
						// from VAT, I've set up a separate variable PriceForPtnCalc to hold the price to be used
						// in calculating member participation - with or without VAT, as appropriate. RetOpDrugPrice
						// will always have the per-package price inclusive of VAT.
						PtnOpPrice = SPres[i].PriceForPtnCalc;	// Was "= SPres[i].RetOpDrugPrice".

						// DonR 29Jun2023 User Story #461368: In order to reduce inflation, the Ministry of Health has
						// ordered a six-month price freeze on member participation for drugs in the Health Basket. We
						// are implementing this by adding a special price list (Price List Code = 21) that will store
						// the June 2023 prices; the Yarpa Price from this list will be used for participation calculation
						// in place of the new, higher Yarpa Price if all the conditions are met. Note that the "treatments
						// only" logic is being implemented on the AS/400 feed to the RK9017P/price_list table, so we
						// don't need it here - but I'm leaving it here in remarked-out form anyway, just in case we
						// decide later to enable it.
						// DonR 04Jul2023 User Story #461368: Updated criteria to match what Orli Spiegel is doing on AS/400.
						// Now we *do* check for "trufot", but we do *not* check Insurance Used. In real life, the results
						// should be the same, since Health Basket is normally FALSE when non-basic insurance is used and
						// only "trufot" should be included in Price List 21 anyway.
						// Marianna 09Jul2023 User Story #463302: Add a new sysparams flag, alt_price_list_only_if_cheaper, to
						// allow the "frozen" alternate Yarpa Price to be used unconditionally, even if it's higher than the
						// price from the current price list.
						if ((SysDate									>= alt_price_list_first_date	)	&&
							(SysDate									<= alt_price_list_last_date		)	&&
							(alt_price_list_code						>  0							)	&&
							(SPres[i].DL.largo_type						== 'T'							)	&&	// This is a "treatment" (i.e. a normal drug).
//							(SPres[i].in_health_pack					!= 0							)	&&	// Implies a prescription sale.
//							(SPres[i].ret_part_source.insurance_used	== BASIC_INS_USED				))
							(SPres[i].in_health_pack					!= 0							))
						{
							ExecSQL (	MAIN_DB, READ_AlternateYarpaPrice,
										&SPres[i].AlternateYarpaPrice,
										&SPres[i].DrugCode,				&alt_price_list_code,
										&SPres[i].YarpaDrugPrice,		&alt_price_list_only_if_cheaper,	// Marianna 09Jul2023 User Story #463302.
										END_OF_ARG_LIST														);

							Conflict_Test (reStart);

							if (SQLCODE ==  0)
							{
// if (!TikrotProductionMode) GerrLogMini (GerrId, "PrID %d: Substituting Price List %d price of %d for default Yarpa Price %d for Largo %d.",
//	v_RecipeIdentifier, alt_price_list_code, SPres[i].AlternateYarpaPrice, SPres[i].YarpaDrugPrice, SPres[i].DrugCode);
								// SPres[i].AlternateYarpaPrice will be stored in prescription_drugs/alternate_yarpa_price
								// and RKFILPRD/RK9022P/E2JDST, and used to calculate member participation.
								if (vat_exempt != 0)
								{
									PtnOpPrice = (int)(((double)SPres[i].AlternateYarpaPrice * no_vat_multiplier) + .5001);
								}
								else
								{
									PtnOpPrice = SPres[i].AlternateYarpaPrice;
								}
							}	// Successful read of alternate (frozen) Yarpa Price.
							else
							{	// Did NOT read an alternate (frozen) Yarpa Price. PtnOpPrice will retain its default value.
								SPres[i].AlternateYarpaPrice = 0;	// Redundant and paranoid re-initialization.

								if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
								{
									// Not Found is perfectly OK - take no action other than (redundantly)
									// setting SPres[i].AlternateYarpaPrice to zero.
// if (!TikrotProductionMode) GerrLogMini (GerrId, "PrID %d: Did NOT find a Price List %d price better than the default Yarpa Price %d for Largo %d.",
//	v_RecipeIdentifier, alt_price_list_code, SPres[i].YarpaDrugPrice, SPres[i].DrugCode);
								}
								else
								{
									if (SQLERR_error_test ())
									{
if (!TikrotProductionMode) GerrLogMini (GerrId, "PrID %d: SQLCODE %d trying to read Price List %d for a price better than the default Yarpa Price %d for Largo %d.",
	v_RecipeIdentifier, SQLCODE, alt_price_list_code, SPres[i].YarpaDrugPrice, SPres[i].DrugCode);
										SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
										break;
									}
								}	// Some SQL error other than not-found.
							}	// Did NOT successfully read an alternate (frozen) Yarpa Price.
						}	// We want to try reading an alternate (frozen) Yarpa Price for this item.
							// DonR 29Jun2023 User Story #461368 end.

					}	// Item being bought does not have a fixed price, and is not a chemical preparation.

					GET_MEMBER_PRICE_ROW (SPres[i].RetPartCode, &PriceRow);

					// If there is a minimum discounted price, use that if the package price is within range.
					// If price is below the minimum, there is no discount.
					if ((PriceRow.min_reduced_price > 0) && (PriceRow.max_pkg_price > 0))
					{
						if ((PtnOpPrice >= PriceRow.min_reduced_price) &&
							(PtnOpPrice <= PriceRow.max_pkg_price))	// Or just "<"?
						{
							PtnWorkVar = (double)PriceRow.min_reduced_price;
						}
						else
						{
							// If price is above the top of the range for the minimum discounted price,
							// apply percentage discount.
							if (PtnOpPrice > PriceRow.max_pkg_price)
							{
								PtnWorkVar =
									(double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
							}
							else
							{
								PtnWorkVar =
									(double)PtnOpPrice;	// Cheap drug = no discount.
							}
						}
					}	// Participation type has a minumum per-package price.
					else
					{
						// For any other participation code, just apply the discount.
						PtnWorkVar =
							(double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
					}
				}	// Not a fixed price.


				// Next, multiply by number of packages and units. To avoid size-of-variable limitations,
				// use a double-precision float variable for calculations.
				// DonR 08Dec2010: If this is a "preparation" sale, the price sent by the pharmacy represents
				// the full quantities being sold - so don't do the multiplication.
				if (PreparationLinkLargo == 0)
					PtnWorkVar *= (((double)SPres[i].Units / (double)SPres[i].DL.package_size) + (double)SPres[i].Op);

				// DonR 08Apr2024 User Story #540234: For Cannabis sales, the pharmacy sends the total member
				// participation, which we store separately in SPres[i].CannabisParticipation to protect it
				// from rounding errors when we divide and multiply by the number of OP. So at this point,
				// use that number instead of the computed value if we see that we've lost a few agorot.
				// (Note that I compare the "lost" participation to the number of OP - if the difference is
				// a rounding error, it should come to less than 1 agora per OP.)
				if (( IsCannabisSale)									&&
					( SPres[i].CannabisParticipation > (int)PtnWorkVar)	&&
					((SPres[i].CannabisParticipation - (int)PtnWorkVar) <= SPres[i].Op))
				{
					PtnWorkVar = (double)SPres[i].CannabisParticipation;
				}

				// DonR 11Jun2017 CR #8425: Remember the computed participation amount before applying member discount.
				// If there's no member discount, we'll just assign this value to MemberPtnAmount[i] below.
				// We add a smidgin in case any precision issue causes us to lose an agora.
				PtnBeforeDiscount = (int)(PtnWorkVar + 0.5001);

				// Apply any member discount.
				if (SPres[i].AdditionToPrice > 0)
				{
					PtnWorkVar *= (((double)10000 - (double)SPres[i].AdditionToPrice) / (double)10000);

					// Assign float value back to integer variable - adding a smidgin in case any precision
					// issue causes us to lose an agora.
					MemberPtnAmount [i] = (int)(PtnWorkVar + 0.5001);

					// DonR 11Jun2017 CR #8425: If there is a member discount, store it in SPres[i].DiscountApplied.
					SPres[i].DiscountApplied = PtnBeforeDiscount - MemberPtnAmount [i];
				}
				else	// No discount - just copy PtnBeforeDiscount to MemberPtnAmount [i].
				{
					MemberPtnAmount [i] = PtnBeforeDiscount;
				}


				// DonR 12Mar2012: Add new logic to compute the total *non-discounted* price of the current sale.
				// This will be used below to issue a message to pharmacies if a member who has resided overseas
				// for two years or more (maccabi_code == 22 or 23) is attempting to purchase more than a set
				// amount of prescription drugs (defaulting to NIS 500).
				// Note that we treat preparation stuff the same as any other item for this purpose.
				OverseasWorkVar	=  (double)SPres[i].YarpaDrugPrice;
				OverseasWorkVar	*= (((double)SPres[i].Units / (double)SPres[i].DL.package_size) + (double)SPres[i].Op);
				FullPriceTotal	+= (int)(OverseasWorkVar + 0.5001);


				// Insurance/Participation Source processing.
				// DonR 31Aug2005: If this is a supplement that gets its participation
				// (i.e. RetPartCode) from the "major" drug, then its participation
				// method must be the same as well. This is not true for "gadgets" -
				// which sometimes use the Link to Addition parameter for a different purpose.
				// DonR 13May2010: Rather than just use the subscript of the major drug,
				// actually assign the major drug's participation-source data to the
				// supplement. This makes things simpler for the "Nihul Tikrot" RPC
				// routine below.
				if ((SPres[i].LinkDrugToAddition	>  0	)	&&
					(SPres[i].DL.largo_type			!= 'X'	)	&&
					(SPres[i].DL.in_gadget_table	== 0	)	&&
					(MajorDrugIndex[i]				>= 0	))
				{
					j = MajorDrugIndex[i];
					SPres[i].ret_part_source.insurance_used	= SPres[j].ret_part_source.insurance_used;
					SPres[i].ret_part_source.table			= SPres[j].ret_part_source.table;
					SPres[i].WhySpecialistPtnGiven			= SPres[j].WhySpecialistPtnGiven;
				}

				// DonR 23Sep2004: Compute new participation source as a two-digit number, with
				// the "tens" digit indicating the insurance used and the "ones" digit
				// indicating the participation source.
				SPres[i].InsPlusPtnSource =   (10 * SPres[i].ret_part_source.insurance_used)
												+	SPres[i].ret_part_source.table;

				// DonR 14Jan2009: If we've assigned specialist participation (which can come
				// "directly" or through a Pharmacy Ishur), there should be a reason for doing
				// so in WhySpecialistPtnGiven. Store this value (which should be between 1 and 6)
				// as the "hundreds" digit in the participation-method field.
				if (((SPres[i].ret_part_source.table == FROM_DOC_SPECIALIST)	||
					 (SPres[i].ret_part_source.table == FROM_PHARMACY_ISHUR))		&&
					((SPres[i].WhySpecialistPtnGiven > 0) && (SPres[i].WhySpecialistPtnGiven < 10)))
						// The latter condition should always be true, but just in case...
				{
					SPres[i].InsPlusPtnSource += (100 * SPres[i].WhySpecialistPtnGiven);
				}
			}	// Member participation / Insurance-plus-participation-source processing loop.


			// DonR 12Mar2012: For members who have lived overseas for two years or more
			// (maccabi_code == 22 or 23), there are restrictions on buying prescription
			// medications under certain conditions. Here we evaluate those conditions
			// and give appropriate messages to the pharmacy.
			if ((v_MemberBelongCode	== MACABI_INSTITUTE)			&&
				(RX_SOURCE_OTHER_THAN (RECIP_SRC_NO_PRESC))			&&
				(OVERSEAS_MEMBER))
			{
				// For certain prescription sources, we need to send the error without regard to the size of
				// the sale. For all other sources, we compare the full, non-discounted price of the sale
				// to the limit stored in the sysparams table.
				if ((RX_SOURCE_IN_REQUEST (RECIP_SRC_HOSPITAL))			||
					(RX_SOURCE_IN_REQUEST (RECIP_SRC_OLD_PEOPLE_HOUSE))	||
					(RX_SOURCE_IN_REQUEST (RECIP_SRC_DENTIST))			||
					(RX_SOURCE_IN_REQUEST (RECIP_SRC_PRIVATE))			||
					(FullPriceTotal >  OverseasMaxSaleAmt))
				{
					SetErrorVarArr (&v_ErrorCode,
									((PRIVATE_PHARMACY) ? ERR_MEMBER_LIVES_OVERSEAS : WARN_MEMBER_LIVES_OVERSEAS),
									0, 0, NULL, &ErrOverflow);
				}
			}	// Prescription drugs being sold to Maccabi member living overseas.


			// DonR 11Jul2012: Provide error/warning message if member is exceeding the daily limit on
			// buying prescription stuff, based on the pharmacy-type-specific limit set in sysparams.
			// Note that since we're looking only at current-day sales, we won't bother with old_member_id.
			// DonR 09Jun2014: For efficiency in case this feature is disabled (by setting the limit equal
			// to zero), make the whole section of code conditional on a non-zero daily limit.
			if ((RX_SOURCE_OTHER_THAN (RECIP_SRC_NO_PRESC)) && (MaxDailyBuy [Phrm_info.pharmacy_permission] > 0))
			{
				if (FullPriceTotal < MaxDailyBuy [Phrm_info.pharmacy_permission])	// If we're already over limit, don't check DB.
				{
					ExecSQL (	MAIN_DB, READ_AlreadyBoughtToday,
								&AlreadyBoughtToday,
								&v_MemberIdentification,	&SysDate,
								&v_PharmNum,				&v_IdentificationCode,
								END_OF_ARG_LIST											);

					// Don't bother with "real" error-checking here - at least for now.
					if (SQLCODE != 0)
						AlreadyBoughtToday = 0;
				}
				else AlreadyBoughtToday = 0;

				if ((FullPriceTotal + AlreadyBoughtToday) > MaxDailyBuy [Phrm_info.pharmacy_permission])
				{
					// DonR 12Sep2012: Separate message for Maccabi pharmacies.
					SetErrorVarArr (&v_ErrorCode,
									MACCABI_PHARMACY ? DAILY_PURCH_LIM_EXCD_MACCABI : DAILY_PURCHASE_LIMIT_EXCEEDED,
									0, 0, NULL, &ErrOverflow);
				}
			}	// Not a non-prescription sale, so need to check daily purchase limit.

		}	// Current action is a drug sale.


		// DonR 19Aug2018 CR #15260: If the member has "shovarim", check their expiry status, and,
		// if necessary, send an appropriate message to the pharmacy. NOTE that at least for now,
		// we're assuming that Expiry Status (fed from RK9059P/B5HXAW) is all we have to look at -
		// we don't need to check the Expiry Date or the Fund Code. (Note also that for now at
		// least, we are SELECTing *only* rows with Expiry Status of 1 or 2; if someone adds another
		// meaningful value, we'll have to change the WHERE criteria accordingly.)
		// DonR 19Feb2019: Skip this check if the pharmacy isn't legal for this transaction.
		// DonR 09Aug2021 User Story #163882: Do *not* send these warnings for darkonaim-plus
		// purchasers whose "shovarim" are provided by their (non-Maccabi) insurance company.
		if ((Member.has_coupon) && (PHARM_LEGAL_FOR_TRN) && (!Member.force_100_percent_ptn))
		{
			ExecSQL (	MAIN_DB, TR6003_READ_CheckCouponExpiryStatus,
						&expiry_status,
						&v_MemberIdentification,	&v_IdentificationCode,
						&ROW_NOT_DELETED,			END_OF_ARG_LIST			);

			if (SQLCODE == 0)
			{
				// If we get here, the member's shovarim *are* due to expire soon!
				// Note that the second line of the message is (at least for now) the same whether
				// the member's shovarim are due to expire in one month or in two months.
				SetErrorVarArr (&v_ErrorCode,
								(expiry_status == 1) ? COUPON_EXPIRES_WITHIN_1_MONTH : COUPON_EXPIRES_WITHIN_2_MONTHS,
								0, 0, NULL, &ErrOverflow);

				SetErrorVarArr (&v_ErrorCode, COUPON_EXPIRING_ADDITIONAL_TEXT, 0, 0, NULL, &ErrOverflow);
			}
		}


		// DonR 04Aug2010: For Nihul Tikrot calls, we want to know how many drugs in the requested
		// sale are actually sellable - so let's count how many do NOT have fatal errors. No point
		// in executing this conditionally, since it will take almost no time to execute.
		for (i = v_NumValidDrugLines = 0;
			 (i < v_NumOfDrugLinesRecs) && (v_NumValidDrugLines < MAX_TIKRA_CURR_SALE);
			 i++)
		{
			if (!SPres[i].DFatalErr)
				v_NumValidDrugLines++;
		}
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003: Number of valid drug lines = %d.", v_NumValidDrugLines);


		// If necessary, call the AS/400 "Tikrot" application to get Tikrot/Coupon/Subsidy information.
		NumTikrotLines	= NumSaleLines		= NumCouponLines		= FamilySalePrID_count	= 0;
		TikrotStatus	= TikrotRPC_Called	= TikrotRPC_Error		= 0;
		*TikrotHeader	= *TikrotPriorSales	= *TikrotCurrentSale	= (char)0;

		gettimeofday (&EventTime[EVENT_START_TO_TIK], 0);

		// Contact AS/400 "Nihul Tikrot" application if:
		// (A) For cannabis items CannabisCallNihulTikrot flag must be TRUE. Marianna 12Feb2024 User Story #540234
		// (B) There hasn't been a fatal error for this sale/deletion.
		// (C) There is at least one valid drug line (i.e. with no fatal error) (DonR 04Aug2010)
		// (D) This is not a sale to an IDF soldier. (DonR 07Dec2011, "Tzahal" enhancement)
		// (E) We're not dealing with a non-prescription sale/deletion.
		// (F) The member is *not* a Darkonai who gets 100% participation on everything, OR the transaction
		//     consists of only Maccabi Doctor prescriptions. (DonR 15Aug2021 User Story #163882)
		// (G) Sale meets relevancy conditions OR current transaction is a valid sale deletion request.
		// (H) The global "Nihul Tikrot Enabled" flag is set TRUE.
		//
		// DonR 11Feb2025 User Story #376480: Added CheckMonthlyPiryonTikra to the list of relevancy
		// conditions in section G1.
		if	(	(!IsCannabisSale || CannabisCallNihulTikrot)										&&			// (A) Marianna 12Feb2024 User Story #540234
				(!SetErrorVarArr (&v_ErrorCode, 0, 0, 0, NULL, &ErrOverflow))						&&			// (B)
				(v_NumValidDrugLines	>  0)														&&			// (C)
				(Member.MemberTzahal	== 0)														&&			// (D)
				(RX_SOURCE_OTHER_THAN_EITHER (RECIP_SRC_NO_PRESC, RECIP_SRC_EMERGENCY_NO_RX))		&&			// (E)
				((HeaderPrescSource == RECIP_SRC_MACABI_DOCTOR) || (!Member.force_100_percent_ptn))	&&			// (F)	DonR 15Aug2021 User Story #163882.

				(	Member.has_tikra		||
					Member.has_coupon		||
					MemberBuyingTikMazon	||
					AnIshurHasTikra			||
					CheckMonthlyPiryonTikra	||								// (G1)
					((v_ActionType == SALE_DELETION) && (DeletionValid))	// (G2)
				)
			)
		{
			if (TikrotRPC_Enabled)																			// (H)
			{
				TikrotRPC_Called = 1;

				// Build list of up to 25 recent sales (in the last two days) to family.
				WritePtr	= TikrotPriorSales;
				Yesterday	= IncrementDate (SysDate, -1);

				gettimeofday (&EventTime[EVENT_FAM_SALES_START], 0);

				// Select cursor for recent family sales (used for "Nihul Tikrot" RPC call).
				// DonR 10Apr2011: Declare cursor only if it's needed.
				// DonR 09Jan2012: If the member's head-of-family Teudat Zehut number is
				// zero, skip the family-prescriptions check.
				if (v_FamilyHeadTZ > 0)
				{
					DeclareAndOpenCursorInto (	MAIN_DB, READ_FamilySales_cur,
												&FamilySalePrID,
												&v_FamilyHeadTZ,	&v_FamilyHeadTZCode,
												&Yesterday,			&SysDate,
												END_OF_ARG_LIST								);

					if (!SQLERR_error_test ())
					{
						// Fetch data and store in buffer.
						// For now at least, no real error checking; just quit when we hit anything.
						// We're already in "dirty read" mode, so we should be more or less OK.
						for ( ; ; )
						{
							FetchCursor (	MAIN_DB, READ_FamilySales_cur	);

							if (SQLCODE == 0)
							{
								WritePtr += sprintf (WritePtr, "%0*d", 9,	FamilySalePrID);
								if (++FamilySalePrID_count >= MAX_TIKRA_PREV_SALES)
									break;	// Buffer capacity reached.
							}
							else
							{
								break;
							}
						}
					}

					CloseCursor (	MAIN_DB, READ_FamilySales_cur	);
				}	// Non-zero head-of-family T.Z. number.
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003 set up %d prior sales.", FamilySalePrID_count);

				gettimeofday (&EventTime[EVENT_FAM_SALES_END], 0);
				// Done with recent-sales list-building.

				// Build request header.
				// DonR 04Aug2010: Send the number of valid drug lines rather than the total line count.
				// Header length is 63 characters.
				WritePtr = TikrotHeader;
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	v_RecipeIdentifier					);
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	v_DeletedPrID						);
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	v_MemberIdentification				);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	v_IdentificationCode				);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	v_ActionType						);
				WritePtr += sprintf (WritePtr, "%0*d" ,	  8,	v_DeletedPrDate						);
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	v_FamilyHeadTZ						);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	v_FamilyHeadTZCode					);
				WritePtr += sprintf (WritePtr, "%c"    ,		ONE_OR_BLANK (Member.has_coupon)	);
				WritePtr += sprintf (WritePtr, "%+0*d" , 10,	v_DeletedPrSubAmt					);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	v_NumValidDrugLines					);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	FamilySalePrID_count				);


				// Build list of drugs (up to 50) in the current sale.
				// DonR 28Jun2010: If a drug has a fatal error, DON'T send it to AS/400.
				// DonR 04Aug2010: Send up to 50 *valid* drug lines.
				// DonR 10Feb2015: Since Trn. 6003 can involve multiple prescription sources,
				// add logic to ignore non-prescription drug lines in the "Nihul Tikrot" request.
				// 34 characters per Drug Line.
				// DonR 18Nov2021 User Story #196891: Use the unused Fixed Price Flag byte to send a
				// "Largo Blocked for Member" 1/0 indicator.
				// Current Sale Line length is 35 characters (assuming new Largo Code length of 6 digits).
				WritePtr = TikrotCurrentSale;
				for (i = v_NumDrugLinesSent = 0;
					 (i < v_NumOfDrugLinesRecs) && (v_NumDrugLinesSent < MAX_TIKRA_CURR_SALE);
					 i++)
				{
					if ((!SPres[i].DFatalErr) && (SPres[i].PrescSource != RECIP_SRC_NO_PRESC))	// DonR 10Feb2015
					{
						// DonR 11May2025 User Story #394813: For Harel darkonaim with shovarim, if the drug
						// is flagged as being in the Health Basket in drug_list, send that value even though
						// participation is 100%; this way Nihul Tikrot will know to apply shovarim.
						// DonR 22May2025 User Story #394813: We need to use the new "unprocessed" copy of the
						// in-health-basket flag here.
						short health_basket_send = SPres[i].in_health_pack;

						if	(	(	Member.mem_id_extension						== DARKONAI	)		&&
								(	Member.darkonai_type						== 1		)		&&	// Harel insurance with 100% hishtatfut.
								(	Member.has_coupon										)		&&
								(	Member.force_100_percent_ptn							)		&&
								(	FULL_PRICE_SALE(i)										)		&&	// Should always be true because of Member.force_100_percent_ptn.
								(	SPres[i].DL.health_basket_new_unprocessed	>  0		)	)
						{
							health_basket_send		= SPres[i].DL.health_basket_new_unprocessed;	// Should be either 4 or 5.
							SPres[i].RetPartCode	= 11;											// == "Maccabi 100%"
						}

						// DonR 30Jul2024 User Story #338533: Largo Code Length is now a Sysparams variable (= 5 or 6).
						// DonR 11Feb2025 User Story #376480: Send "1" or "2" for Tikrat Mazon flag, not just "1". Also,
						// send the value from the new structure element "TikratMazonFlagSend" rather than from the
						// drug_list value; if the requesting pharmacy is not qualified for fertility tikrot, we want
						// to send a space instead of "2".
						WritePtr += sprintf (WritePtr, "%0*d"  ,  NihulTikrotLargoLen,	SPres[i].DrugCode				);
						WritePtr += sprintf (WritePtr, "%c "   ,		SPres[i].DL.largo_type							);
						WritePtr += sprintf (WritePtr, "%c"    ,		ONE_TWO_BLANK (SPres[i].TikratMazonFlagSend)	);
						WritePtr += sprintf (WritePtr, "%0*d"  ,  5,	SPres[i].DL.parent_group_code					);

						// DonR 08Mar2017 CR #11036: Send Ishur Source even if the ishur didn't involve Tikra.
						WritePtr += sprintf (WritePtr, "%c",			DIGIT_OR_BLANK (SPres[i].SpecPrescNumSource)	);
						WritePtr += sprintf (WritePtr, "%0*d"  ,  3,	SPres[i].IshurTikraType							);
						WritePtr += sprintf (WritePtr, "%+0*d" , 10,	MemberPtnAmount[i]								);
						WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	SPres[i].RetPartCode							);

						// DonR 15Dec2021 HOT FIX: Nihul Tikrot needs a space rather than a zero to indicate that
						// this drug is *not* blocked for this member. Accordingly, I'm changing the output to send
						// a space if LargoBlockedForMember is zero.
						WritePtr += sprintf (WritePtr, "%s"    ,		(SPres[i].LargoBlockedForMember) ? "1" : " "	);	// DonR 18Nov2021 User Story #196891 plus 15Dec2021 HOT FIX.

//						WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	SPres[i].in_health_pack						);
						WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	health_basket_send							);		// DonR 11May2025 User Story #394813
						WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	SPres[i].ret_part_source.insurance_used		);
						WritePtr += sprintf (WritePtr, " "		/* Deletion Tikra Flag - NIU */						);

						v_NumDrugLinesSent++;
					}	// Drug doesn't already have a fatal error.
				}
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003 set up %d current sales - calling stored procedure.", v_NumDrugLinesSent);


				// Finally (well, not quite finally), call the RPC to invoke the AS/400 "Tikrot" program.
				TikrotRPC_Error = CallTikrotSP (TikrotHeader,	TikrotCurrentSale,	TikrotPriorSales,
												&HeaderRtn,		&TikrotRtn,			&CurrentSaleRtn,	&CouponsRtn);

// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003 called Nihul Tikrot - TikrotRPC_Error = %d.", TikrotRPC_Error);
				// DonR 03Aug2010: If the Tikrot RPC call failed, change "Tikrot Called" from 1 to 2.
				if (TikrotRPC_Error != 0)
				{
					TikrotRPC_Called = 2;
				}

				// Pull values from output header - length = 19 characters.
				PosInBuff = HeaderRtn + 9;	// Ignore Prescription ID - we know it already!

				TikrotStatus = GetShort (&PosInBuff, 4);

				// DonR 06Jun2010: Orly Spiegel changed the status returned. Now 1 means that everything's
				// OK but no reductions in price were granted; 2 means that reductions in price were
				// granted; and any other value means that something went wrong.
				if ((TikrotStatus == 1) || (TikrotStatus == 2))
				{
					NumTikrotLines	= GetShort (&PosInBuff, 2);
					NumSaleLines	= GetShort (&PosInBuff, 2);
					NumCouponLines	= GetShort (&PosInBuff, 2);
				}
				else
				{
					NumTikrotLines = NumSaleLines = NumCouponLines = 0;

					// DonR 25Jun2020: In order to diagnose an intermittent problem in communicating with
					// the "ODBC listener" program on AS/400, dump HeaderRtn to log if TikrotStatus has
					// an unrecognized value.
					if (TikrotRPC_Error != -1)	// Don't bother logging HeaderRtn for comms errors.
					{
						// DonR 07Jul2020: Ignore known, common Nihul Tikrot error codes - we want
						// to log only the weird stuff.
						switch (TikrotStatus)
						{
							case  51:
							case  52:
							case  53:
							case 101:
							case 102:
							case 103:	break;

							// DonR 14Oct2024 User Story #237305: If Nihul Tikrot detected a duplicate Prescripton ID,
							// this indicates a serious problem - we're re-using already-in-use Prescription IDs because
							// presc_per_host hasn't been properly updated to allocate unused Prescription ID range(s).
							case 150:	do
										{
											char HostName [256];

											if (gethostname (HostName, 255))
												strcpy (HostName, "???");

											GerrLogMini (GerrId,	"Got Nihul Tikrot error %d (duplicate ID) for Prescription ID %d. "
																	"Check Prescription ID allocation for host %s immediately!",
																	TikrotStatus, v_RecipeIdentifier, HostName						);
										}
										while (0);

										break;

							default:	GerrLogMini (GerrId, "PID %d: Got HeaderRtn {%s} for Prescription ID %d, TikrotRPC_Error = %d.",
													 (int)getpid(), HeaderRtn, v_RecipeIdentifier, TikrotRPC_Error);
										break;
						}
					}	// Strange, uncommon Nihul Tikrot Status code returned, without a communications error.
				}	// TikrotStatus isn't 1 or 2.
//if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003: After CallTikrotSP, NumTikrotLines = %d, NumSaleLines = %d, NumCouponLines = %d.", NumTikrotLines, NumSaleLines, NumCouponLines);

				// Decode Tikrot Lines output.
				// 59 characters/line. We're dimensioned to handle up to 50 lines of output,
				// but in fact Nihul Tikrot gives us a maximum of 10 lines.
				PosInBuff = TikrotRtn;
				for (i = 0; i < NumTikrotLines; i++)
				{
					TikraType			[i] = GetChar	(&PosInBuff);
					TikraBasket			[i] = GetShort	(&PosInBuff,  1);
					TikraInsurance		[i] = GetShort	(&PosInBuff,  2);
					TikraAggPrevPtn		[i] = GetInt	(&PosInBuff, 10);
					TikraAggPrevWaived	[i] = GetInt	(&PosInBuff, 10);
					TikraCurrPtn		[i] = GetInt	(&PosInBuff, 10);
					TikraCurrWaived		[i] = GetInt	(&PosInBuff, 10);
					TikraCurrLevel		[i] = GetInt	(&PosInBuff,  9);
					GetString (&PosInBuff, TikraPeriodDesc [i],  6);

//					// DonR 18Oct2010: Convert AS/400 Windows (1255) Hebrew to DOS (862) Hebrew - and
//					// then reverse it, since AS/400 has strange ways of dealing with Hebrew.
//					WinHebToDosHeb ((unsigned char *)TikraPeriodDesc [i]);	// DonR 18Oct2010
					// DonR 17Jul2023: AS/400 gives us the Tikra Period Description reversed from all
					// the other Hebrew we get from the database - so reverse it to match. (Note that
					// this is not a new functional change - I'm just commenting it more clearly, and
					// changing the function name from buf_convert() to buf_reverse() for clarity.)
					buf_reverse ((unsigned char *)TikraPeriodDesc [i], 6);

					// DonR 09Aug2016: Keep track of total Tikra discount sent to pharmacy.
					tikra_discount += TikraCurrWaived [i];
				}

				// Decode Current Sale Lines output.
				// 18 characters/line, assuming 6-digit Largo Code.
				PosInBuff = CurrentSaleRtn;
				for (i = 0; i < NumSaleLines; i++)
				{
					// DonR 30Jul2024 User Story #338533: Largo Code Length is now a Sysparams variable (= 5 or 6).
					PosInBuff += NihulTikrotLargoLen;	// Ignore Largo Code - array order will be unchanged!
					DrugTikraType		[i] = GetChar	(&PosInBuff);
					DrugCoupon			[i] = GetChar	(&PosInBuff);
					DrugRefundOffset	[i] = GetInt	(&PosInBuff, 10);

					// DonR 13Jul2010: Drug Refund Offset needs to be used to reduce the Member
					// Participation Amount for sale deletions. Since this is sent from AS/400
					// as a negative number, we add it to the Participation Amount.
					// DonR 14Jul2010: Oops! Forgot that MemberPtnAmount is a negative number
					// for deletions; so we need to *subtract* the Refund Offset rather than add it.
					if (v_ActionType == SALE_DELETION)
						MemberPtnAmount [i] -= DrugRefundOffset [i];
				}

				// Decode Coupon Lines output - 13 characters per line.
				PosInBuff = CouponsRtn;
				for (i = 0; i < NumCouponLines; i++)
				{
					TikraCouponCode		[i] = GetShort	(&PosInBuff,  3);
					TikraCouponAmt		[i] = GetInt	(&PosInBuff, 10);

					// DonR 09Aug2016: Keep track of total subsidy amount sent to pharmacy.
					subsidy_amount += TikraCouponAmt [i];
				}
			}	// "Nihul Tikrot" calls are enabled.
			else
			{
				GerrLogMini (GerrId, "AS/400 not contacted - \"Nihul Tikrot\" calls are disabled!");
			}
		}	// Need to call AS/400 "Tikrot" program via ODBC RPC.


		// DonR 26Oct2014: "Maccabi Pharmacy Sale at 100% Participation Not Allowed" is now conditional: if
		// the member could receive a discount by signing up for a "shaban" service (Zahav or Maccabi Sheli)
		// or the member is getting a member-based discount for this drug (either because of a global percentage
		// discount or because of a serious illness/accident discount), we want to allow the sale to go through.
		// DonR 19Feb2019: Skip this logic if the pharmacy isn't legal for this transaction.
		if ((v_ActionType != SALE_DELETION) && (PHARM_LEGAL_FOR_TRN))
		{
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// For each drug in the sale, see if we've previously assigned the relevant "you can't buy
				// this at full price" error.
				// DonR 23Nov2014: Note that we're now using a non-severe "placeholder" error code, which
				// will either be replaced by the real thing or else deleted.
				if (SetErrorVarExists (ERR_MACCABI_100_PER_CENT, SPres[i].DrugCode))
				{
					Permit100PercentSale = 0;	// Default: we will in fact prevent the sale.
					
					// DonR 03Dec2014: Per Iris Shaya, this change is no longer contingent on the member
					// receiving a subsidy for the drug.
					// DonR 19Jan2015: Added a new non-reported error code for members who do have
					// "shaban" but didn't get a discount - presumably because they just signed up
					// and the 90-day waiting period hasn't been completed.
					// DonR 08Jun2016: If the member is getting a full or partial member-based discount
					// (based on an all-drugs percentage or on a match between serious illness and the
					// drug in question), permit the sale to go through. Also, combine multiple tests
					// into a single "if".
					// Note that the first condition will be true only for work accidents, where we sometimes
					// give a member discount even if the Health Basket parameter is zero. Otherwise we give
					// memer discounts only when participation is already less than 100%.
					if ((SPres[i].AdditionToPrice > 0)												||	// Member has a member/illness-based discount.
						(SetErrorVarExists (ERR_DISCOUNT_IF_HAD_ZAHAV,		SPres[i].DrugCode))		||	// Zahav discount possible.
						(SetErrorVarExists (ERR_DISCOUNT_IF_HAD_YAHALOM,	SPres[i].DrugCode))		||	// Maccabi Sheli discount possible.
						(SetErrorVarExists (SHABAN_NOT_YET_APPLICABLE,		SPres[i].DrugCode)))		// Member has signed up for "shaban" but it hasn't kicked in yet.
					{
						Permit100PercentSale = 1;	// Let the sale go through!
					}
					else

					// For the moment at least, we don't give a message for "Member could get a Specialist
					// discount with supplemental insurance" - so we need to check for this condition with
					// a separate SQL query. We already know that member *isn't* getting a specialist discount
					// on this sale, so we don't need to compare the spclty_largo_prcnt row's insurance with
					// the member's insurance - just that the spclty_largo_prcnt row's insurance type is
					// "Y" or "Z" (= Maccabi Sheli or Magen Zahav).
					{
						// This test applies to Maccabi prescribing physicians and specialist drugs only.
						if (( SPres[i].DocIDType != 1) &&
							((SPres[i].DL.specialist_drug > 0) || (PR_AsIf_Preferred_SpDrug[i] > 0)))
						{
							ExecSQL (	MAIN_DB, READ_check_for_specialist_discount_to_enable_full_price_sale,
										&RowsFound,
										&SPres[i].DocID,		&ROW_NOT_DELETED,
										&SPres[i].DrugCode,		&PR_AsIf_Preferred_Largo[i],
										&Member.MemberMaccabi,	&Member.MemberHova,
										&Member.MemberKeva,		&ROW_NOT_DELETED,
										END_OF_ARG_LIST											);

							Conflict_Test (reStart);

							if (SQLERR_error_test ())
							{
								SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
								break;
							}
							else
							{
								if (RowsFound > 0)
								{
									Permit100PercentSale = 1;	// Specialist discount possible - let the sale go through!
								}
							}
						}	// Maccabi Doctor and specialist drug.
					}	// Didn't find a "hit" on drug_extension or member/illness-based possibilities.


					// At this point, we have two possibilities: either Permit100PercentSale == 1, in which case we want
					// to suppress the "sale forbidden" messages; or Permit100PercentSale == 0, in which case we want to
					// go ahead and prevent the entire drug sale from going through.
					if (Permit100PercentSale)
					{
						SetErrorVarDelete (ERR_MACCABI_100_PER_CENT,	SPres[i].DrugCode);
					}
					else
					{
						// Swap in the real error code in place of the "placeholder".
						SetErrorVarSwap (&SPres[i].DrugAnswerCode,
										 ERR_MACCABI_100_PER_CENT,
										 ERR_MACCABI_100PCT_FORBIDDEN,
										 SPres[i].DrugCode,
										 NULL);

						// Flag the entire drug sale as invalid.
						SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
					}

				}	// "Sale at 100%" placeholder error was previously assigned for this drug.
			}	// Loop through all drugs in sale.
		}	// Current action is a drug-sale request, so check for "100% forbidden" situations.
		// DonR 26Oct2014 end.


		// DonR 30Aug2015: Check if this member needs a Form 29-G for this drug; and whether a current
		// Form 29-G will expire soon.
		// DonR 19Feb2019: Disable 29-G logic for pharmacies that aren't legal for this transaction.
// DonR 21Oct2015: TEMPORARY - CONDITIONALLY DISABLED, SO PROGRAM CAN BE PUT INTO PRODUCTION BEFORE THIS FEATURE IS TESTED.
// (Form29gMessagesEnabled will be TRUE if the member_drug_29g table is populated.)
// GerrLogMini (GerrId, "%s to check Form 29G because checking %s enabled.", (Form29gMessagesEnabled) ? "About" : "Not going", (Form29gMessagesEnabled) ? "is" : "is NOT");
if (Form29gMessagesEnabled)
{
		if ((v_ActionType == DRUG_SALE) && (PHARM_LEGAL_FOR_TRN))
		{
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				FunctionError = CheckMember29G (&Member, &SPres[i], &Phrm_info);

				if (FunctionError == ERR_DATABASE_ERROR)
				{
					SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
				}
				else
				{
					if (FunctionError > 0)
					{
						SetErrorVarArr (&SPres[i].DrugAnswerCode, FunctionError, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
					}
					else
					{
						if (FunctionError == -1)
						{
							reStart = MAC_TRUE;
							break;
						}
					}
				}
			}	// Loop through drugs checking 29-G status.

			if (reStart == MAC_TRUE)
			{
				continue;
			}

		}	// This is a drug-sale transaction, so we need to check Form 29-G status.
}	// TEMPORARY!


		// DonR 04Sep2003: Members pay via credit line (i.e. not through pharmacy) under the following conditions:
		//
		// 1) Drugs were prescribed by a doctor (not over-the-counter), and
		//
		// 2) Member has arranged a bank credit line with Maccabi, and
		//
		// 3) Member has chronic illness, no matter what pharmacy prescription is filled at.
		//
		// 4) Pharmacy has its "credit" flag set, no matter whether member is chronically ill or not.
		//
		// "Card passed" logic is irrelevant here.
		//
		// DonR 10Aug2004: Non-chronically-ill patients buying drugs at pharmacies that work
		// with credit lines will be given the option of paying through the credit line even
		// for non-prescription drugs. In this case we'll pass a 10 to the pharmacy, and the
		// pharmacy will pass back a 9 in Transaction 2005 to indicate that the member is
		// going to pay through his/her credit line.
		//
		// DonR 05Aug2009: Credit Type 9 is now sent to all pharmacies, Maccabi and private.
		// DonR 05Feb2023 User Story #424990: Add 4 to the list of Maccabi Center Credit Type
		// values that disable payment by credit line at Maccabi pharmacies.
		// Marianna 22Feb2024 User Story #540234 - disable the "horat keva" for Cannabis Sale
		if ((RX_SOURCE_OTHER_THAN_EITHER (RECIP_SRC_NO_PRESC, RECIP_SRC_EMERGENCY_NO_RX))		&&	// NOT entirely non-prescription
			((v_CreditYesNo			== 2) || (v_CreditYesNo == 4))								&&	// Member has Credit Line
			(v_insurance_status		== 1)														&&	// Chronic illness
			(PHARM_LEGAL_FOR_TRN)																&&	// DonR 19Feb2019: Pharmacy must be legal for this transaction.
			(PRIVATE_PHARMACY	||	(	(v_MacCent_cred_flg != 2)	&&
										(v_MacCent_cred_flg != 4)	&&
										(v_MacCent_cred_flg != 7)		)	)					&&	// DonR 05Feb2023 User Story #424990 added 4 to list.
			(!IsCannabisSale))																		// User Story #540234 - disable the "horat keva" for Cannabis Sale
		{
			// DonR 10Apr2013: Add additional conditions for automatic credit-line payment. If these
			// are not met, send a message to the pharmacy and fall through to the next (optional
			// credit-line payment) section of code. Anyone otherwise eligible pays this way if
			// his/her magnetic card is used; otherwise, the purchase must be made at a Maccabi
			// pharmacy, and the member must be getting drugs through an old-age home with Credit Flag
			// equal to 1, 5, or 9.
			// DonR 05Apr2017 CR #11541: Automatic credit-line payment requires the use of a *current*
			// Maccabi card - so instead of using MEMBER_USED_MAG_CARD, use the new macro
			// MEMBER_USED_CURRENT_MAG_CARD which also tests whether we've issued an ERR_CARD_EXPIRED
			// message (or warning).
			// DonR 01Feb2023 User Story #424990: Add 3 and 8 to the list of Maccabi Center Credit Type
			// values that do *not* require using the member's magnetic card to allow payment by credit line.
			// DonR 03Jul2024 User Story #309736: Add additional logic to permit "cardless" payment by credit
			// line under specific conditions.
			// NOTE: The condition here does *not* include "v_ClientLocationCode > 1" - but in fact, if the
			// pharmacy has sent Client Location Code 1 for a "frontal" sale, v_MacCent_cred_flg will be
			// zero and the condition will evaluate FALSE.
			if (	(MEMBER_USED_CURRENT_MAG_CARD ||					// Patient used magnetic card OR...
						(	(MACCABI_PHARMACY)			&&				// Sale is at a Maccabi pharmacy, and...
							(	(v_MacCent_cred_flg == 1) ||			// (Note that "1" is for automatic credit-line pmt only.)
								(v_MacCent_cred_flg == 3) ||			// DonR 05Feb2023 User Story #424990 added 3 to list.
								(v_MacCent_cred_flg == 5) ||
								(v_MacCent_cred_flg == 8) ||			// DonR 01Feb2023 User Story #424990 added 8 to list.
								(v_MacCent_cred_flg == 9)	)	)	)

					||

					// ...Or second, the person responsible for paying for the member's drugs is a member
					// of the same family, the item is being sold under a Maccabi doctor's prescription,
					// and there is a valid service-without-card request.
					// (NOTE: For efficiency, we would prefer not to check for service without card unless
					// the other conditions are met, since CheckForServiceWithoutCard() performs database
					// lookups to see if a request has been invalidated by a recent pharmacy sale. Putting
					// this as the last condition in the "if" should do the job; but even if it doesn't, it
					// doesn't make all that much difference since the first two conditions will all be
					// TRUE in the majority of cases.)
					(	(Member.payer_is_in_family)							&&
						(HeaderPrescSource == RECIP_SRC_MACABI_DOCTOR)		&&
						(CheckForServiceWithoutCard (&Member, Phrm_info))		)

				)	// Member used mag card OR qualifying MaccabiPharm sale OR qualifying service-without-card request.
			{
				v_CreditYesNo = 9;	// Payment is direct from bank to pharmacy.

				// DonR 19May2024 User Story #309734: Add info message for automatic credit-line payment.
				SetErrorVarArr (&v_ErrorCode, AUTO_CREDIT_LINE_PMT_AUTHORIZED, 0, 0, NULL, &ErrOverflow);

			}
			else
			{
				// DonR 27May2013: Send Error 6160 only if this is a drug sale.
				if (v_ActionType == DRUG_SALE)
					SetErrorVarArr (&v_ErrorCode, ERR_AUTO_CREDIT_PMT_W_CARD_MSG, 0, 0, NULL, &ErrOverflow);
			}
		}

		// DonR 10Apr2013: It is now possible that someone can meet most of the criteria for Credit Type 9
		// (automatic payment through credit line), but not have this option set because s/he didn't have
		// a magnetic card at the pharmacy. In this case, we want to fall through to the next section,
		// since the member may still qualify for optional credit-line payment. Accordingly, the next block
		// of code is no longer in an "else"; if v_CreditYesNo has been set to 9, the "if" will be false
		// in any case.

		// DonR 14Oct2004: If Client Location Code is greater than one (e.g. member
		// lives in an old-age home), offer payment by credit line only if that
		// location has a Credit Flag of 9 and the prescription is being filled
		// at a Maccabi pharmacy; in this case, we don't worry about
		// the member's Maccabi Card or the pharmacy's Credit Flag. If the Client
		// Location Code is zero or one, operate "normally" - that is, offer credit
		// if the card has been scanned.
		// DonR 10Jan2005: 1 is a valid card date!
		// DonR 30Oct2006: Per Iris Shaya, added Maccabi Centers Credit Flag of 5
		// to the condition (to join with 9) to pay by credit line w/o using member's card.
		// DonR 05Apr2017 CR #11541: Optional credit-line payment requires the use of a *current*
		// Maccabi card - so instead of using MEMBER_USED_MAG_CARD, use the new macro
		// MEMBER_USED_CURRENT_MAG_CARD which also tests whether we've issued an ERR_CARD_EXPIRED
		// message (or warning).
		// DonR 01Feb2023 User Story #424990: Add 3 and 8 to the list of Maccabi Center Credit Type
		// values that do *not* require using the member's magnetic card to allow payment by credit line.
		// DonR 05Feb2023 User Story #424990: Add 4 to the list of Maccabi Center Credit Type
		// values that disable payment by credit line at Maccabi pharmacies.
		// Marianna 22Feb2024 User Story #540234 - disable the "horat keva" for Cannabis Sale.
		// DonR 16May2024 User Story #309736: Move the magnetic-card logic inside the main "if", and add
		// additional logic to permit "cardless" payment by credit line under specific conditions.
		if (((v_CreditYesNo			== 2) || (v_CreditYesNo == 4))	&&	// Member has Credit Line
			(PHARM_LEGAL_FOR_TRN)									&&	// DonR 19Feb2019: Pharmacy must be legal for this transaction.
			(v_CreditPharm			!= 0)							&&	// Pharmacy works with Credit Lines
			(PRIVATE_PHARMACY	||	(	(v_MacCent_cred_flg != 2)	&&
										(v_MacCent_cred_flg != 4)	&&
										(v_MacCent_cred_flg != 7)))	&&	// DonR 05Feb2023 User Story #424990 added 4 to list.
			(!IsCannabisSale) )							// Marianna User Story #540234 - Cannabis Sale can't pay "horat keva"
														// ...Magnetic card not required.
		{
					// DonR 16May2024 User Story #309736: Assuming all the "outer if" conditions are met,
					// we let the member pay via credit line under two broad conditions: First, either the
					// member used a magnetic card or else the sale is a "non-frontal" one at a Maccabi
					// pharmacy and the member lives in a facility with one of the permitted credit flags...
					// NOTE: In fact, "v_ClientLocationCode > 1" is not needed because if the Client
					// Location Code is 1 or less (i.e. the member is "frontally" there at the pharmacy)
					// we know that v_MacCent_cred_flg will have a value of zero and the condition will
					// evaluate to FALSE.
			if (	(MEMBER_USED_CURRENT_MAG_CARD ||					// Patient used magnetic card OR...
						(	(v_ClientLocationCode >  1)	&&				// NOT a "frontal" sale, and...
							(MACCABI_PHARMACY)			&&				// Sale is at a Maccabi pharmacy, and...
							(	(v_MacCent_cred_flg == 3) ||			// DonR 05Feb2023 User Story #424990 added 3 to list.
								(v_MacCent_cred_flg == 5) ||
								(v_MacCent_cred_flg == 8) ||			// DonR 01Feb2023 User Story #424990 added 8 to list.
								(v_MacCent_cred_flg == 9)	)	)	)

					||

					// ...Or second, the person responsible for paying for the member's drugs is a member
					// of the same family, the item is being sold under a Maccabi doctor's prescription,
					// and there is a valid service-without-card request.
					// (NOTE: For efficiency, we would prefer not to check for service without card unless
					// the other conditions are met, since CheckForServiceWithoutCard() performs database
					// lookups to see if a request has been invalidated by a recent pharmacy sale. Putting
					// this as the last condition in the "if" should do the job; but even if it doesn't, it
					// doesn't make all that much difference since the first two conditions will all be
					// TRUE in the majority of cases.)
					(	(Member.payer_is_in_family)							&&
						(HeaderPrescSource == RECIP_SRC_MACABI_DOCTOR)		&&
						(CheckForServiceWithoutCard (&Member, Phrm_info))		)

				)	// Member used mag card OR qualifying non-frontal MaccabiPharm sale OR qualifying service-without-card request.
			{
				// 23Nov2005: Per Iris Shaya, Member Credit type 4 indicates that member
				// prefers to pay through multiple payments ("tashlumim"), even though
				// they are known to be a tool of the devil.
				v_CreditYesNo = (v_CreditYesNo == 4) ? 11 : 10;	// Pharmacy will give option to patient
																// to pay through Credit Line.


				// DonR 20Mar2006: Don't perform family purchase check for Member ID zero!
				// Also, this check applies only to purchases, not to deletions.
				// NOTE: As of 1 April 2011, credit_type_code will be populated in prescription_drugs;
				// this should mean that the prescriptions table can be dropped from this query.
				// DonR 03Apr2011: Revamped SELECT for better performance - we now need to use only
				// members and prescription_drugs.
				// DonR 07Apr2019: This SELECT needs the following changes: (A) Instead of looking at the
				// credit_type_code in prescription_drugs, we should be looking at prescriptions/credit_type_used,
				// which reflects the member's decision whether to pay by credit line; and (B) the value to look for
				// is 9 -  the only alternative is 0, which means the member paid by cash or credit card.
				if ((RX_SOURCE_IN_REQUEST (RECIP_SRC_NO_PRESC))	&&
					(v_MemberIdentification > 0)				&&
					(v_ActionType != SALE_DELETION))
				{
					v_FirstOfMonth = SysDate + 1 - (SysDate % 100);

					ExecSQL (	MAIN_DB, READ_check_family_credit_used,
								&v_FamilyCreditUsed,
								&v_FamilyHeadTZ,	&v_FamilyHeadTZCode,
								&v_FirstOfMonth,	END_OF_ARG_LIST			);

					v_FamilyCreditInd = ColumnOutputLengths [1];

					if (SQLMD_is_null (v_FamilyCreditInd))
						v_FamilyCreditUsed = 0;

					// Compute anticipated total of the current sale.
					v_CreditToBeUsed = 0;
					for (i = 0; i < v_NumOfDrugLinesRecs; i++)
					{
						if (SPres[i].DFatalErr == MAC_TRUE )
							continue;

						// Compute participation per OP.
						// DonR 08Jan2012: If "Meishar" has given a fixed price of zero, that's a real
						// fixed price.
						if ((SPres[i].PriceSwap == 0) && (SPres[i].ret_part_source.table != FROM_GADGET_APP))
						{
							// DonR 28Mar2010: Since we're only executing this block of code if the current
							// purchase is being made without a prescription - and non-prescription sales
							// are always charged 100% participation - the business about the 12-shekel
							// minimum when participation is 15% should really be irrelevant. This is worth
							// noting since I've just been told that the 12-skekel minimum has been changed
							// to 15 shekels.
							GET_PARTICIPATING_PERCENT (SPres[i].RetPartCode, &percent1);
							v_CreditThisDrug = (int) ((float)SPres[i].RetOpDrugPrice * (float)percent1 / 10000.0);
							if ((v_CreditThisDrug < 1200) && (SPres[i].RetPartCode == PARTI_CODE_TWO))
								v_CreditThisDrug = 1200;	// Minimum NIS 12.00 for "normal" 15% participation.
						}
						else
						{
							v_CreditThisDrug = SPres[i].PriceSwap;
						}

						// Multiply by packages requested.
						if (SPres[i].Op > 1)
							v_CreditThisDrug *= SPres[i].Op;

						// Compute member discount - although I don't really think there are any
						// discounts on non-prescription medications!
						if (SPres[i].AdditionToPrice  > 0)
							v_CreditThisDrug -= (int) ((float)v_CreditThisDrug * (float)SPres[i].AdditionToPrice / 10000.0);

						// Finally, add the current drug's net-to-member price to the total.
						v_CreditToBeUsed += v_CreditThisDrug;
					}	// Loop through drugs in current purchase request.


					// DonR 10Apr2019 CR #???: Maximum monthly family OTC credit is now a sysparams parameter:
					// sysparams/max_otc_credit_mon.
					if ((v_FamilyCreditUsed + v_CreditToBeUsed) > MaxFamilyOtcCreditPerMonth)
					{
						v_CreditYesNo = 0;	// No more use of credit line this month!
						SetErrorVarArr (&v_ErrorCode, ERR_NO_MORE_OTC_CREDIT, 0, 0, NULL, &ErrOverflow);

						GerrLogFnameMini (	"otc_credit_log",
											GerrId,
											"PrID %d prev %d, now %d, tot %d, err = %d - DENIED CREDIT!\t\t\t\t\t\t",
											v_RecipeIdentifier,
											v_FamilyCreditUsed,
											v_CreditToBeUsed,
											(v_FamilyCreditUsed + v_CreditToBeUsed),
											SQLCODE);
					}	// Monthly OTC credit-line usage exceeded.
				}	// Current request is for OTC drugs.
			}	// "Inner" (magnetic-card-related) credit-line conditions met.
		}	// "Outer" (NOT magnetic-card-related) credit-line conditions met.

		// DonR 19May2024 User Story #309734: Provide some new pharmacy messages
		// for cases where we did *not* allow payment by credit line. (At least
		// for now, these messages will be sent only to Maccabi pharmacies.)
		// First, test "outer" conditions - if these are not met, the whole question
		// of optional credit-line payment is moot.
//GerrLogMini (GerrId, "CreditYN %d, MacPharm %d, LegalTrn %d, PharmCredit %d, CreditFlg %d, Cannabis %d.",
//	v_CreditYesNo, MACCABI_PHARMACY, PHARM_LEGAL_FOR_TRN, v_CreditPharm, v_MacCent_cred_flg, IsCannabisSale);
		if (	(v_CreditYesNo		<  9)		&&	// We are not allowing payment by credit line - value will be 0, 2, or 4.
				(MACCABI_PHARMACY)				&&	// Maccabi pharmacy.
				(PHARM_LEGAL_FOR_TRN)			&&	// Pharmacy must be legal for this transaction (should always be TRUE for MaccabiPharm).
				(v_CreditPharm		!= 0)		&&	// Pharmacy works with Credit Lines (should always be TRUE for MaccabiPharm).
				(v_MacCent_cred_flg != 2)		&&	// Not one of the "cash only" member locations.
				(v_MacCent_cred_flg != 4)		&&	// ""
				(v_MacCent_cred_flg != 7)		&&	// ""
				(!IsCannabisSale)			)		// Cannabis sales never pay by credit line.
		{
			if ((v_CreditYesNo != 2) && (v_CreditYesNo != 4))	// Member does *not* have an active credit line.
			{
				// Note that if the member doesn't have a credit line set up and active, there's no point
				// in sending any of the other "why we didn't give credit" messages.
				SetErrorVarArr (&v_ErrorCode, MEMBER_DOES_NOT_HAVE_CREDIT_LINE, 0, 0, NULL, &ErrOverflow);
			}
			else
			{
				// Member *does* have an active credit line, so the reason we didn't allow credit-line
				// payment is something else. There are two possibilities: If we're selling against
				// Maccabi doctor prescriptions, then either using the magnetic card *or* requesting
				// service without card would permit a credit sale; but if the prescription source for
				// this transaction is anything else, then the only option is to use a magnetic card.
				SetErrorVarArr (	&v_ErrorCode,
									(HeaderPrescSource == RECIP_SRC_MACABI_DOCTOR) ?
													CARD_OR_SVC_WITHOUT_4_CREDIT_LINE :
													USE_CARD_TO_PAY_BY_CREDIT_LINE,
									0, 0, NULL, &ErrOverflow								);
			}
		}	// "Outer" condtions for sending a "why you can't pay by credit line" message.

		// DonR 16Jun2024: Because of the other changes we made in the credit-line logic,
		// we need to take the following logic out of the "else" - otherwise in some
		// conditions we're sending a value of 2 or 4 to the pharmacy when payment by
		// credit line is not authorized.
		// DonR 28Jul2024: But since we moved this logic, we also have to change it: 9
		// is no longer the only valid value! Anything between 9 and 11 is OK, since 9
		// is for automatic credit-line payment, and 10/11 are for optional credit-line
		// payment.
		//
		// This is the "catch-all" default: if member is not an eligible chronic patient
		// and doesn't qualify for "normal" credit-line payment, s/he has to pay by
		// cash or credit card. Note that any value other than 2 or 4 in the member's
		// credit_type_code field should land him/her here!
		// DonR 10Apr2013: We can now get here if member qualified for automatic payment via
		// credit line (v_CreditYesNo == 9); accordingly, zero v_CreditYesNo conditionally.
//		if (v_CreditYesNo != 9)
		if ((v_CreditYesNo < 9) || (v_CreditYesNo > 11))	// Values > 11 should be impossible - but just in case!
			v_CreditYesNo = 0;	// Payment is made to Pharmacy.


		// DonR 19Sep2021 User Story #163882: If this is a prescription sale to a Type 1 Darkonai
		// with Prescription Source *not* equal to 1 (Maccabi Doctor), send a message to inform the
		// pharmacy that the Darkonai is paying 100% without using vouchers.
		if ((Member.force_100_percent_ptn)					&&
			(HeaderPrescSource != RECIP_SRC_NO_PRESC)		&&
			(HeaderPrescSource != RECIP_SRC_MACABI_DOCTOR))
		{
			SetErrorVarArr (&v_ErrorCode, HAND_RX_DARKONAI_PLUS_PAYS_CASH, 0, 0, NULL, &ErrOverflow);
		}


		// DonR 19Jan2005: See if there's anything in pharmacy_message for the pharmacy to see.
		v_Message = MAC_FALS;

		ExecSQL (	MAIN_DB, READ_check_pharmacy_message_count,
					&RowsFound, &v_PharmNum, END_OF_ARG_LIST		);

		Conflict_Test (reStart);

		if ((SQLCODE == 0) && (RowsFound > 0))
			v_Message = MAC_TRUE;

		if (SQLERR_error_test ())
		{
			SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
		}


		// DonR 10Apr2013: If member is buying prescription drugs without passing a magnetic card AND the
		// prescriptions are not in the doctor-prescription table (and some other conditions are met), give
		// the pharmacy a message indicating that this is a purchase that should be permitted only with the
		// use of a magnetic card. The error is of severity 2, which means that the sale is permitted, but
		// the pharmacist must authorize it specifically. We neet to check doctor_presc only for the first
		// drug on the list, since pharmacies sell either against prescriptions sent via Transaction 6001
		// or against paper prescriptions, but never against a combination of both at the same time.
		// Note regarding the v_MacCent_cred_flg test: If this is an ordinary purchase by a member who does
		// not live in an old-age home, v_ClientLocationCode will be 1 and v_MacCent_cred_flg will be zero;
		// since only values of v_ClientLocationCode > 1 will have non-zero v_MacCent_cred_flg values, there
		// is no need to test v_ClientLocationCode here. A value of 1, 5, 7, or 9 in v_MacCent_cred_flg
		// *disables* this test.
		// DonR 24Dec2013: This test now applies to all pharmacies. Also, give different error codes
		// depending on Prescription Source.
		// DonR 26Dec2013: If the sale is being rejected because the person buying drugs isn't a Maccabi
		// member, don't bother checking the prescription status.
		// DonR 28Oct2015 CR #6245: This test now applies in two cases: either the purchase is at a Maccabi
		// pharmacy, OR the member has not used his/her magnetic card. For Maccabi pharmacies, we will send
		// a new error code with severity = 4, which requires two pharmacy workers to authorize the sale.
		// DonR 29Jun2020 CR #28453: Added an additional warning for short Member TZ's, piggybacking on
		// the pre-existing logic - see below.
		if ((v_ActionType			== DRUG_SALE)					&&
			(v_ErrorCode			!= ERR_MEMBER_NOT_ELEGEBLE)		&&	// DonR 26Dec2013
			(SPres[0].PrescSource	!= RECIP_SRC_NO_PRESC)			&&
			(PHARM_LEGAL_FOR_TRN)									&&	// DonR 19Feb2019: Pharmacy must be legal for this transaction.

			// DonR 28Oct2015 part 1 begin.
			(	(MACCABI_PHARMACY)						||

				(	(v_MacCent_cred_flg	!= 1)	&&
					(v_MacCent_cred_flg	!= 5)	&&
					(v_MacCent_cred_flg	!= 7)	&&
					(v_MacCent_cred_flg	!= 9)	&&
					(!MEMBER_USED_MAG_CARD)			)		)		)
			// DonR 28Oct2015 part 1 end.
		{
			RowsFound = 0;	// Default in case we don't need to do a lookup.

			// If the prescription is not from a Maccabi doctor, don't bother looking it up in doctor_presc - we
			// already know that it's not there.
			// DonR 05Nov2014: Changing the 799/800 boundary in economypri to 999/1000. This is temporary, as the
			// code is being expanded to six digits. When the next phase comes in, the boundary will
			// be at 19999/20000.
			// DonR 31Jan2018: Instead of selecting a list of related Largo Codes from economypri, get the list
			// from drug_list. This will give exactly the same result, but avoids duplicating logic that checks
			// the economypri system_code and del_flg fields. This way, the logic that deals with this table is
			// all contained in the "pipeline" programs As400UnixServer and As400UnixClient.
			if (SPres[0].PrescSource == RECIP_SRC_MACABI_DOCTOR)
			{
				SET_ISOLATION_DIRTY;

				PW_Doc_Largo_Code	= PR_Original_Largo_Code [0];
				PW_DoctorPrID		= DocRx [1].PrID;	// DonR 25May2015: changed subscript, as 0 is a blank element and we start storing real stuff in DocRx[1].
				DocID				= SPres[0].DocID;

				ExecSQL (	MAIN_DB, READ_check_first_doctor_prescription_is_in_database,
							&RowsFound,
							&v_MemberIdentification,	&PW_DoctorPrID,
							&EarliestPrescrDate,		&LatestPrescrDate,
							&PW_Doc_Largo_Code,			&SPres[0].DL.economypri_group,
							&DocID,						&v_IdentificationCode,
							END_OF_ARG_LIST													);

				// If anything went wrong with the SQL query, just assume that we found something.
				if (SQLCODE != 0)
					RowsFound = 1;

				SET_ISOLATION_COMMITTED;
			}	// Prescriptions are from a Maccabi doctor, and thus should be found in doctor_presc.

			// If prescriptions are from a non-Maccabi doctor, or were not found in doctor_presc, notify
			// pharmacy that something is amiss.
			// DonR 28Oct2015 CR #6245 part 2: This test now applies in two cases: either the purchase is
			// at a Maccabi pharmacy, OR the member has not used his/her magnetic card. For Maccabi
			// pharmacies, we will send a new error code with severity = 4, which requires two pharmacy
			// workers to authorize the sale.
			// DonR 31Dec2015: The new error code HAND_RX_MACCABI_NEED_2_CARDS is sent *in addition to* the old
			// error codes, not instead of them.
			// DonR 03Jan2016 HOT FIX: The "old" error codes are sent *only* if magnetic card wasn't passed,
			// even if the sale is to a Maccabi pharmacy.
			if (RowsFound == 0)
			{
				// 27Jan2016: Per Iris Shaya, add conditions for sending HAND_RX_MACCABI_NEED_2_CARDS: At least
				// one item in the sale request must be a "treatment", and the purchaser must be either an
				// ordinary member (i.e. not living in an old-age home or similar facility) or the member's
				// facility must have a "first center type" other than "02".
				// DonR 01Jun2021: It's not clear to me whether something here should change to accomodate the
				// new First Center Type of 3 (= "pickup"). For now, I'm not going to change anything; we'll
				// see if there's a problem that needs a fix.
				if ((MACCABI_PHARMACY)			&&
					(ReqIncludesTreatment)		&&
					((v_ClientLocationCode == 1) || (FirstCenterTypeNum != 2)))
//					((v_ClientLocationCode == 1) || ((FirstCenterTypeNum != 1) && (FirstCenterTypeNum != 2))))   (possible alternative to not send to Al-Tor)
				{
					SetErrorVarArr (&v_ErrorCode, HAND_RX_MACCABI_NEED_2_CARDS, 0, 0, NULL, &ErrOverflow);
				}

				// DonR 22Oct2023 User Story #488068: Add 8 to list of excluded credit flags.
				if ((v_MacCent_cred_flg	!= 1)	&&
					(v_MacCent_cred_flg	!= 5)	&&
					(v_MacCent_cred_flg	!= 7)	&&
					(v_MacCent_cred_flg	!= 8)	&&	// DonR 22Oct2023 User Story #488068.
					(v_MacCent_cred_flg	!= 9)	&&
					(!MEMBER_USED_MAG_CARD))
				{
					// DonR 05Jan2026 User Story #475507: For the next three error codes, differentiate between
					// sale requests with and without "treatment" items. Requests with "treatments" will use the
					// existing error codes, which all have Severity 4 (meaning that *2* pharmacists have to use
					// their magnetic cards to authorize the sale); requests without "treatments" will get the same
					// error text, but with Severity 2 (only one pharmacist magnetic card required).
					switch (SPres[0].PrescSource)
					{
						case RECIP_SRC_MACABI_DOCTOR:		ErrorCodeToAssign =
																	(ReqIncludesTreatment) ?	ERR_MUST_PASS_2_CARDS_TO_BUY	:
																								ERR_MUST_PASS_1_CARD_TO_BUY;
															break;

						case RECIP_SRC_HOSPITAL:
						case RECIP_SRC_OLD_PEOPLE_HOUSE:
						case RECIP_SRC_PRIVATE:				ErrorCodeToAssign =
																	(ReqIncludesTreatment) ?	WHITE_PRESCRIPTION_PASS_2_CARDS	:
																								WHITE_PRESCRIPTION_PASS_1_CARD;
															break;

						default:							ErrorCodeToAssign =
																	(ReqIncludesTreatment) ?	HAND_PRESCRIPTION_PASS_2_CARDS	:
																								HAND_PRESCRIPTION_PASS_1_CARD;
															break;
					}	// Decide which error code to assign based on Prescription Source.

					SetErrorVarArr (&v_ErrorCode, ErrorCodeToAssign, 0, 0, NULL, &ErrOverflow);
				}	// Magnetic card was not passed.

				// DonR 29Jun2020 CR #28453: If the Member TZ is shorter than a configurable
				// number (= 100, at least for now) and a magnetic card wasn't used (and this
				// is a drug sale and no Maccabi Doctor prescription was read from the database -
				// both conditions that already apply to this block of code) send a warning
				// message to the pharmacy. For now at least, this applies only to Maccabi
				// pharmacies.
				// DonR 07Jul2020: Per Iris, this CR should apply to *all* pharmacies.
				if ((!MEMBER_USED_MAG_CARD)								&&	// Should this be current card only?
					(v_MemberIdentification	< MinimumNormalMemberTZ))
				{
					SetErrorVarArr (&v_ErrorCode, MEMBER_LOW_MEMBER_TZ_AND_NO_CARD, 0, 0, NULL, &ErrOverflow);
				}
				// CR #28453 end.



			}	// No electronic prescription found.

			else	// We *did* find a doctor prescription in the database. 
			{
				// DonR 04Jan2016, CR #6838: Give a message to pharmacy to suggest swiping member's magnetic card.
				// DonR 23Feb2022 Epic #155733 / User Story #227243: Don't give "card not passed" message if there's
				// a valid service-without-card request for this member AND we're at a private pharmacy.
				// DonR 22Oct2023 User Story #488068: Add 8 to list of excluded credit flags, and send the error message
				// only if there is no valid service-without-card request - previously it was sent to MaccabiPharm
				// even if a valid service-without-card request existed, which was kind of silly.
				if ((v_MacCent_cred_flg	!= 1)	&&
					(v_MacCent_cred_flg	!= 5)	&&
					(v_MacCent_cred_flg	!= 7)	&&
					(v_MacCent_cred_flg	!= 8)	&&	// DonR 22Oct2023 User Story #488068: Add 8 to list of credit flags.
					(v_MacCent_cred_flg	!= 9)	&&
					(!MEMBER_USED_MAG_CARD)		&&
					(!CheckForServiceWithoutCard (&Member, Phrm_info)))		// DonR 23Feb2022 Epic #155733 / User Story #227243 / User Story #488068.
//					((MACCABI_PHARMACY) || (!CheckForServiceWithoutCard (&Member, Phrm_info))))		// DonR 23Feb2022 Epic #155733 / User Story #227243.
				{
					SetErrorVarArr (&v_ErrorCode, RX_FOUND_BUT_CARD_NOT_PASSED, 0, 0, NULL, &ErrOverflow);
				}
			}	// Electronic prescription *was* found.

		}	// Prescription drug sale without member's magnetic card having been passed OR at a Maccabi pharmacy.


		// DonR 08Feb2016, CR 36237: If at least one doctor prescription in this sale request has already been
		// partially filled, send a message to the (Maccabi) pharmacy. If member's magnetic card was used, the
		// message will have severity 2 (requiring one pharmacist to swipe his/her card); if member's magnetic
		// card was not used, the message will be the same but will have severity 4, requiring two pharmacists'
		// cards to be swiped.
		// DonR 20Nov2016: Incorporated this logic into Trn. 6003; it was initially implemented only in Trn. 5003.
		// In this version we scan the DocRX array rather than the drug-line array. Note that DocRx[0] is a blank
		// dummy row, so we start scanning at position 1 in the array.
		if ((v_ActionType == DRUG_SALE) && (MACCABI_PHARMACY))
		{
			for (i = 1, found_partially_sold_rx = 0; i < MaxRx ; i++)
			{
				// Don't check unless this is a Maccabi doctor prescription with a non-zero prescription ID.
				if ((DocRx [i].DocID == 0) || (DocRx [i].PrID == 0))
					continue;

				// To save on database access time, check to see if the current prescription has already
				// been checked.
                for (j = 1, rx_already_checked = 0; j < i; j++)
				{
					// Skip past stuff we've already checked.
					if ((DocRx [j].DocID == DocRx [i].DocID) && (DocRx [j].PrID == DocRx [i].PrID))
					{
						rx_already_checked = 1;
						break;
					}
				}	// Loop to check if the current doctor prescription has already been looked up.

				// If this is a repeat of a doctor prescription found earlier in the list, skip to
				// the next drug line.
				if (rx_already_checked)
					continue;

				// If we get here, the doctor prescription at position i is non-zero and has not been checked
				// for previous partial sales yet.
				found_partially_sold_rx = CheckForPartiallySoldDoctorPrescription (v_MemberIdentification,
																				   v_IdentificationCode,
																				   DocRx [i].DocID,
																				   DocRx [i].PrID,
																				   EarliestPrescrDate,
																				   LatestPrescrDate);

				// If we've found one partially-sold prescription, there's no need to look for more.
				if (found_partially_sold_rx)
					break;
			}	// Loop through prescriptions in this sale to check for at least one partially-sold prescription.

			if (found_partially_sold_rx)
			{
				SetErrorVarArr (&v_ErrorCode, MEMBER_USED_MAG_CARD ? PREV_PARTIAL_SALE_NEED_1_CARD : PREV_PARTIAL_SALE_NEED_2_CARDS, 0, 0, NULL, &ErrOverflow);
			}

		}	// Need to test for presence of partially-sold prescription(s) in sale request.
		// DonR 08Feb2016/20Nov2016, CR 36237 end.


		// DonR 29Jun2020 CR #31742: For private pharmacies, check for partial sales of the same
		// drug from the same prescription at the same pharmacy today.
		if ((v_ActionType == DRUG_SALE) && (PRIVATE_PHARMACY))
		{
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// We're interested only in Maccabi Doctor prescriptions.
				if ((SPres[i].PrescSource != RECIP_SRC_MACABI_DOCTOR) || (SPres[i].NumDocRxes < 1))
					continue;

				for (Rx = SPres[i].FirstRx; Rx < (SPres[i].FirstRx + SPres[i].NumDocRxes); Rx++)
				{
					// Don't check unless this is a valid Maccabi doctor prescription with a
					// non-zero prescription ID.
					if ((DocRx [Rx].DocID == 0) || (DocRx [Rx].PrID == 0))
						continue;

					// See how many matching partially-sold prescriptions exist. (Should be 1 or 0.)
					ExecSQL	(	MAIN_DB, CheckForPartlySoldPrescriptionSamePharmSameDay,
								&RowsFound,
								&Member.ID,						&DocRx [Rx].PrID,	&DocRx [Rx].FromDate,
								&DocRx [Rx].LargoPrescribed,	&DocRx [Rx].DocID,	&Member.ID_code,
								&SysDate,						&v_PharmNum,		END_OF_ARG_LIST			);

					if (RowsFound > 0)
					{
						if (SetErrorVarArr (&SPres[i].DrugAnswerCode, RX_PARTLY_SOLD_SAME_PHARM_TODAY, SPres[i].DrugCode, i + 1, NULL, &ErrOverflow))
						{
							SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
						}

						// Once we've set the error for this drug line, break out of the inner loop -
						// there's no point in checking more prescriptions for the same drug line.
						break;
					}	// We found a matching partial sale.
				}	// Loop through doctor prescriptions for this drug line.
			}	// Loop through all drug lines for this sale request.
		}	// This is a drug sale at a private pharmacy - CR #31742 end.


		// DonR 08Apr2014: Call new routine to generate Health Alert Messages for this member.
		// (Note that we don't give Health Alerts for sale deletions.)
		// DonR 19Feb2019: Disable health alerts if the pharmacy is not permitted to send this transaction.
		// DonR 11Sep2024 Bug #350304: Add address of v_ErrorCode to the argument list for CheckHealthAlerts,
		// so that critical errors from the module will be written to prescriptions/error_code and sale
		// completion by the pharmacy will be prevented.
		// DonR 04Nov2024 Bug #350304 revisited: CheckHealthAlerts needs to be called *before* writing
		// to prescriptions and prescription_drugs. Otherwise there's no point in assigning a value to
		// v_ErrorCode, since the presriptions row is already stored with the previous value.
		if ((v_ActionType == DRUG_SALE) && (PHARM_LEGAL_FOR_TRN))
			CheckHealthAlerts	(	CHECK_MEMBER, &Member, SPres, v_NumOfDrugLinesRecs, DocRx,
									&v_DrugsBuf, &Phrm_info, HeaderPrescSource, &v_ErrorCode	);

		// If we've hit a severe error, clear any "Meishar participation granted"
		// messages on any items in the sale, since they're no longer relevant.
		// DonR 04Nov2024 Bug #350304 revisited: This code also has to be moved, so we don't
		// write stuff to prescriptions/error_code that should actually be deleted.
		if ((SetErrorVarArr (&v_ErrorCode, 0, 0, 0, NULL, NULL)) || (reStart == MAC_TRUE))
		{
			SetErrorVarDelete (ERR_GADGET_OP_REDUCED_BASIC,		0);
			SetErrorVarDelete (ERR_GADGET_OP_REDUCED_MAGEN,		0);
			SetErrorVarDelete (ERR_GADGET_OP_REDUCED_KEREN,		0);
			SetErrorVarDelete (ERR_GADGET_OP_REDUCED_YAHALOM,	0);
			SetErrorVarDelete (ERR_GADGET_OP_REDUCED_UNKNOWN,	0);
			SetErrorVarDelete (ERR_GADGET_APPROVED_BASIC,		0);
			SetErrorVarDelete (ERR_GADGET_APPROVED_MAGEN,		0);
			SetErrorVarDelete (ERR_GADGET_APPROVED_KEREN,		0);
			SetErrorVarDelete (ERR_GADGET_APPROVED_YAHALOM,		0);
			SetErrorVarDelete (ERR_GADGET_APPROVED_UNKNOWN,		0);
		}
		else
		{	// Nothing terrible happened. Any additional messages to pharmacy get assigned here.
			if ((v_ActionType == DRUG_SALE) && (RX_SOURCE_IN_REQUEST (RECIP_SRC_EMERGENCY_NO_RX)))
			{
				SetErrorVarArr (&v_ErrorCode, EMERGENCY_SUPPLY_100_PERCENT, 0, 0, NULL, &ErrOverflow);
			}
		}


		// DonR 01Sep2013: In case we hit a fatal error but didn't assign Error 6089 (which
		// pharmacies use to indicate a "chasima" for a drug), make sure that we did assign it.
		// (SetErrorVarArr is smart enough not to set the same error twice, so we don't actually
		// need to check whether we've already assigned it.)
		for (i = 0; i < v_NumOfDrugLinesRecs ; i++)
		{
			if (SPres[i].DFatalErr)
			{
				SetErrorVarArr (&v_ErrorCode, ERR_DRUG_S_WRONG_IN_PRESC, 0, 0, NULL, &ErrOverflow);
				break;
			}
		}

		// UPDATE TABLES.
		// Set up dummy loop to facilitate error-handling.
		do
		{
			// DonR 29Jul2003: If we've already hit a fatal database error, skip
			// past the record-writing stuff.
			if (v_ErrorCode == ERR_DATABASE_ERROR)
				break;

			// DonR 20Jul2010: For sale deletions, the Credit Type Used value from the original sale
			// overrides whatever we've calculated for the current transaction's credit type.
			if (v_ActionType == SALE_DELETION)
			{
				v_CreditYesNo = v_DeletedPrCredit;
			}

			// Insert into PRESCRIPTIONS table.
			// DonR 23May2019 CR #29169: Populate member_discount_pt from members table.
			// DonR Feb2023 User Story #232220: Add paid_for to columns INSERTed.
			// DonR 20Apr2023 User Story #432608: Add dummy value for Magento Order Number.
			ExecSQL (	MAIN_DB, INS_prescriptions,
						&v_PharmNum,			&v_InstituteCode,
						&v_PriceListCode,		&v_MemberIdentification,
						&v_IdentificationCode,	&v_MemberBelongCode,
						&DocID,					&v_TypeDocID,
						&HeaderPrescSource,		&v_RecipeIdentifier,

						&v_SpecialConfNum,		&v_SpecialConfSource,
						&SysDate,				&SysTime,
						&v_ErrorCode,			&v_NumOfDrugLinesRecs,
						&v_CreditYesNo,			&v_MoveCard,
						&v_MemberDiscPercent,	&v_TerminalNum,

						&IntZero,				&IntZero,
						&IntZero,				&Member.maccabi_code,
						&IntZero,				&NOT_REPORTED_TO_AS400,
						&ShortZero,				&ShortZero,
						&ShortZero,				&v_ClientLocationCode,

						&IntZero,				&ShortZero,
						&v_PriceListCode,		&IntZero,
						&IntZero,				&v_MsgExistsFlg,
						&DRUG_NOT_DELIVERED,	&ROW_NOT_DELETED,
						&IntZero,				&ShortZero,

						&v_ActionType,			&v_DeletedPrID,
						&v_DeletedPrPharm,		&v_DeletedPrDate,
						&v_DeletedPrPhID,		&IntZero,
						&ShortZero,				&ShortZero,
						&ShortZero,				&ShortZero,

						&TikrotRPC_Called,		&TikrotRPC_Error,
						&tikra_discount,		&subsidy_amount,
						&OriginCode,			&ShortZero,
						&TikrotStatus,			&Member.insurance_type,
						&online_order_num,		&ShortZero,

						&ShortZero,				&Member.darkonai_type,
						&ShortZero,				&LongZero,				// DonR Feb2023 User Story #232220 & 20Apr2023 User Story #432608.
						END_OF_ARG_LIST									);

			Conflict_Test (reStart);

			if (SQLERR_error_test ())
			{
				SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
				break;
			}


			// Insert into PRESCRIPTION_DRUGS table.
			for (i = 0; i < v_NumOfDrugLinesRecs ; i++)
			{
				// Prepare SQL variables.
				LineNum			= i + 1;
				PrsLinP			= &SPres[i];
				StopUseDate		= AddDays (SysDate, PrsLinP->Duration);
				StopBloodDate	= AddDays (SysDate, (PrsLinP->Duration + PrsLinP->DL.t_half));	// Note that as of July 2023, t_half is *always* zero.

				PW_Doc_Largo_Code	= PR_Original_Largo_Code	[i];
				PW_DoctorPrID		= DocRx [SPres[i].FirstRx].PrID;
				PW_Pr_Date			= DocRx [SPres[i].FirstRx].FromDate;
				sprintf (v_DrugTikraType, "%c", DrugTikraType [i]);	// DonR 09Jul2020 BUG FIX: ODBC doesn't support single-character input columns, so tikra_type_code wasn't be written to DB!
				DL_TikratMazonFlag	= SPres[i].DL.tikrat_mazon_flag;
				MemberPtnAmt		= MemberPtnAmount			[i];
				v_DrugSubsidized	= (DrugCoupon[i] == '1') ? 1 : 0;

				// DonR 11Jul2011: In case an error has been set and subsequently deleted, reset drug_answer_code
				// with the most severe error found for this drug.
				SetErrorVarTop (&PrsLinP->DrugAnswerCode, PrsLinP->DrugCode, NULL);


				// DonR 14Jan2009: We now write the substitution-permitted data using two variables:
				// first, a new flag explaining why a non-preferred drug was sold; and second, the
				// reason, if any, supplied by the pharmacy. The pharmacy-supplied value of 99
				// accordingly needs to be truncated to 9.
				PW_SubstPermitted = (SPres[i].WhyNonPreferredSold * 10) + (PR_WhyNonPreferredSold[i] % 10);


//				if (v_ActionType != SALE_DELETION)
//				{
//					// If this is a sale against a prescription that should be in the database, try reading
//					// the doctor_presc row to get some information about it.
//					if (SPres[i].PrescSource == RECIP_SRC_MACABI_DOCTOR)	// This is not an OTC prescription!
//					{
				// DonR 21Mar2006: If this drug is being sold according to an AS400 Ishur
				// with quantity limits, there is no need to check for early refill as well.
				// DonR 23Aug2010: Per Iris Shaya, don't check for early refills for those "members"
				// who are exempted from interaction/OD testing.
				// DonR 21Nov2024 User Story #366220: This message should be sent for all prescription
				// sources other than OTC - *not* just for Maccabi Doctor prescriptions. Also, since
				// the early-refill logic was the only thing in this "not a sale deletion" block,
				// consolidated that condition into a single "if".
				// DonR 17Dec2024 User Story #366220 UPDATE: Send early-refill warnings to private
				// pharmacies as well as MaccabiPharm.
				// DonR 25Feb2025 User Story #395096: Reverse the last change - only MaccabiPharm
				// should get these early-refill warnings.
				if ((v_ActionType != SALE_DELETION)						&&	// DonR 21Nov2024: made this into a single "if".
					(MACCABI_PHARMACY)									&&
					(SPres[i].PrescSource	!= RECIP_SRC_NO_PRESC)		&&	// DonR 21Nov2024 User Story #366220.
					(Member.check_od_interact)							&&	// DonR 23Jan2018 CR #13937
					(!SPres[i].HasIshurWithLimit)						&&	// DonR 21Mar2006.
					(strchr ("BMT",	SPres[i].DL.largo_type)	!= NULL)	&&
					(strchr ("OQ",	SPres[i].DL.drug_type)	== NULL))
				{
					// DonR 19Apr2010: Add additional warning message for early refill, with slightly
					// different conditions than the other early-refill messages.
					// DonR 24Jul2013: Add criteria to avoid giving this message if the current sale
					// is against a prescription found in doctor_presc AND the previous sale was at
					// the same pharmacy with a prescription from the same doctor written on the
					// same day.
					// 11Mar2015 - REVISED VERSION for Digital Prescriptions:
					// 1) We use pd_rx_link to see if the relevant previous sale was complete for *all*
					//    its affected doctor prescriptions; if even one doctor prescription was left
					//    partially filled, we won't give an early-refill warning.
					// 2) Took out the criterion for the current sale being "non-electronic".
					// 3) Took out the criterion that would trigger the warning if the prior sale was
					//    at the same pharmacy, took place today, was for a prescription from the same
					//    doctor, but that prescription was written on a different day. Since one drug
					//    line can now relate to multiple doctor prescriptions from multiple visits,
					//    this criterion is very difficult to implement, and probably irrelevant in
					//    any case.
					SET_ISOLATION_DIRTY;

					ShortOverlapDate	= IncrementDate (SysDate, MaxShortDurationOverlapDays);
					LongOverlapDate		= IncrementDate (SysDate, MaxLongDurationOverlapDays);

					// DonR 24Nov2024 User Story #366220: Select prior sales of generic equivalents
					// as well as sales of the drug currently being sold. There are a bunch of other
					// changes in the SQL logic - see the SQL code.
					ExecSQL (	MAIN_DB, READ_test_for_ERR_EARLY_REFILL_WARNING,
								&RowsFound,
								&v_MemberIdentification,	&SPres[i].DrugCode,		&SPres[i].DL.economypri_group,
								&v_IdentificationCode,		&SysDate,				&MaxShortDurationDays,
								&ShortOverlapDate,			&MaxShortDurationDays,	&LongOverlapDate,
								&SysDate,					END_OF_ARG_LIST											);

					Conflict_Test (reStart);

					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
					else
					{
						if (RowsFound > 0)
						{
							SetErrorVarArr (&SPres[i].DrugAnswerCode, ERR_EARLY_REFILL_WARNING,
											SPres[i].DrugCode, i + 1, NULL, &ErrOverflow);
						}	// Found recent purchase of same drug.
					}	// Succeeded in getting purchase-count.

					// DonR 14Mar2005: Restore "isolation" to normal level.
					SET_ISOLATION_COMMITTED;
				}	// Need to perform early-refill test.
//					}	// This is a Maccabi Doctor prescription.
//				}	// This is not a deletion transaction.


				// DonR 05May2004: If pharmacy sent a Special Prescription number AND
				// we didn't find an AS400 Special Prescription for this drug, copy the
				// pharmacy's number to the drug's variables - otherwise the number (used
				// for things like overriding interaction/overdose messages) is lost.
				// WORKINGPOINT: Check if this logic is obsolete and should be deleted.
				if ((v_SpecialConfNum > 0) && (PrsLinP->SpecPrescNum == 0))
				{
					PrsLinP->SpecPrescNum		= v_SpecialConfNum;
					PrsLinP->SpecPrescNumSource	= v_SpecialConfSource;
				}


				// DonR 13Jan2009: If drugs are being sold without a prescription, swap in a value of 8
				// for the "in health basket" parameter. This doesn't change any logic in how the Unix
				// programs handle the sale, but is needed by the AS/400.
				// DonR 10Oct2016: For emergency-supply sales, force in zero for "in health basket".
				if (SPres[i].PrescSource == RECIP_SRC_NO_PRESC)
					PrsLinP->in_health_pack = 8;
				else
				if (SPres[i].PrescSource == RECIP_SRC_EMERGENCY_NO_RX)
					PrsLinP->in_health_pack = 0;

				// If participation isn't coming from a drug_extension rule, force rule_number to zero.
				// DonR 20Jul2010: If this is a sale deletion, the Rule Number comes from the original
				// sale; accept it unconditionally.
				// DonR 30Jan2024 Bug #547018: We also need to preserve Rule Numbers from Pharmacy
				// Ishurim, as long as the ishur specified a "real" nohal with Rule Number > 4.
				// DonR 24Apr2025 User Story #390071: Also preserve Rule Numbers when the rule was
				// chosen by the doctor.
				if ((PrsLinP->ret_part_source.table	!= FROM_DRUG_EXTENSION)		&&
					(PrsLinP->ret_part_source.table	!= FROM_PHARMACY_ISHUR)		&&
					(PrsLinP->ret_part_source.table	!= FROM_DOCTOR_NOHAL)		&&
					(v_ActionType					!= SALE_DELETION))
				{
					PrsLinP->rule_number = 0;
				}

				// DonR 08Apr2024 User Story #540234: For Cannabis sales, we're supposed to report
				// (and store) zero for the per-package price; so now that we've done all our
				// "hishtatfut" stuff, we'll set RetOpDrugPrice to zero.
				if (IsCannabisSale)
				{
					PrsLinP->RetOpDrugPrice = 0;
				}

				// DonR 09Jul2003: Switched storage of basic and computed participation codes,
				// so that the correct code for the actual purchase goes to the AS400. Now we
				// will store BasePartCode (normally from drug_list) in calc_member_price, and
				// RetPartCode (the participation code we actually send to the pharmacy) will
				// be in member_price_code. The latter field is the one sent to the AS400.
				// Note that this change will not affect pharmacy operations at all - just
				// a switch in which number is stored in which field, and which number is
				// sent to the AS400.
				// DonR 23May2019 CR #29169: Populate member_discount_pt from members table.
				// DonR 29Jun2023 User Story #461368: Added AlternateYarpaPrice/alternate_yarpa_price.
				// DonR 31Jul2023 User Story #469361: Add 4 columns for new blood-duration logic.
				ExecSQL (	MAIN_DB, TR6003_INS_prescription_drugs,
							&v_RecipeIdentifier,				&LineNum,
							&v_MemberIdentification,			&v_IdentificationCode,
							&PrsLinP->DrugCode,					&NOT_REPORTED_TO_AS400,
							&PrsLinP->Op,						&PrsLinP->Units,
							&PrsLinP->Duration,					&StopUseDate,

							&SysDate,							&SysTime,
							&ROW_NOT_DELETED,					&DRUG_NOT_DELIVERED,
							&PrsLinP->PriceSwap,				&PrsLinP->AdditionToPrice,
							&PrsLinP->LinkDrugToAddition,		&PrsLinP->RetOpDrugPrice,
							&v_ActionType,						&PrsLinP->DrugAnswerCode,

							&PrsLinP->RetPartCode,				&PrsLinP->BasePartCode,
							&PrsLinP->PrescSource,				&PrsLinP->MacabiPriceFlg,
							&v_PharmNum,						&v_InstituteCode,
							&PrsLinP->SupplierDrugPrice,		&StopBloodDate,
							&IntZero,							&IntZero,

							&IntZero,							&IntZero,
							&ShortZero,							&PrsLinP->DL.t_half,
							&PrsLinP->DocID,					&PrsLinP->DocIDType,
							&PW_DoctorPrID,						&PW_Pr_Date,
							&PW_Doc_Largo_Code,					&PW_SubstPermitted,

							&PrsLinP->Units,					&PrsLinP->Op,
							&IntZero,							&IntZero,
							&PrsLinP->InsPlusPtnSource,			&IntZero,
							&PrsLinP->in_health_pack,			&PrsLinP->SpecPrescNum,
							&PrsLinP->SpecPrescNumSource,		&PrsLinP->IshurWithTikra,

							&PrsLinP->IshurTikraType,			&PrsLinP->Doctor_Op,
							&PrsLinP->Doctor_Units,				&PrsLinP->rule_number,
							&v_DrugTikraType,					&v_DrugSubsidized,
							&DL_TikratMazonFlag,				&MemberPtnAmt,
							&ShortZero,							&v_CreditYesNo,

							&ShortZero,							&PrsLinP->why_future_sale_ok,
							&PrsLinP->qty_limit_chk_type,		&PrsLinP->qty_lim_ishur_num,
							&PrsLinP->vacation_ishur_num,		&PrsLinP->DocFacility,
							&PrsLinP->DiscountApplied,			&PrsLinP->BarcodeScanned,
							&PrsLinP->IsDigital,				&PrsLinP->member_diagnosis,

							&PrsLinP->ph_OTC_unit_price,		&v_MemberDiscPercent,
							&PrsLinP->qty_limit_class_code,		&PrsLinP->IsConsignment,
							&PrsLinP->AlternateYarpaPrice,		END_OF_ARG_LIST					);

				Conflict_Test (reStart);
				
				if (SQLERR_error_test ())
				{
					SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
					break;
				}


				// DonR 12Sep2013: If we've performed actual-usage testing (for ampoules sold
				// against an AS/400 ishur with quantity limits), write to the new
				// prescription_usage table as well.
				if (PrsLinP->actual_usage_checked)
				{
					ExecSQL (	MAIN_DB, INS_prescription_usage,
								&v_RecipeIdentifier,			&LineNum,
								&PrsLinP->DrugCode,				&PrsLinP->course_len,
								&PrsLinP->course_treat_days,	&PrsLinP->Duration,
								&PrsLinP->calc_courses,			&PrsLinP->calc_treat_days,
								&PrsLinP->total_units,			&PrsLinP->fully_used_units,

								&PrsLinP->partly_used_units,	&PrsLinP->discarded_units,
								&PrsLinP->avg_partial_unit,		&PrsLinP->proportion_used,
								&PrsLinP->net_lim_ingr_used,	&SysDate,
								&SysTime,						&DRUG_NOT_DELIVERED,
								&NOT_REPORTED_TO_AS400,			END_OF_ARG_LIST					);

					Conflict_Test (reStart);
				
					if (SQLERR_error_test ())
					{
						SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
						break;
					}
				}	// Need to write to prescription_usage.

			}	// End of drugs-in-prescription loop.


			// DonR 11Apr2013: Write all error codes to prescription_msgs.
			ErrorCount = SetErrorVarTell (&ErrorArray, NULL);

			for (i = 0; i < ErrorCount; i++)
			{
				v_DrugCode		= ErrorArray [i].LargoCode;
				v_ArrayErrCode	= ErrorArray [i].Error;
				v_ArraySeverity	= ErrorArray [i].Severity;
				v_ArrayLineNo	= ErrorArray [i].LineNo;

				ExecSQL (	MAIN_DB, INS_prescription_msgs,
							&v_RecipeIdentifier,	&v_DrugCode,			&v_ArrayLineNo,
							&v_ArrayErrCode, 		&v_ArraySeverity,		&SysDate,
							&SysTime,				&DRUG_NOT_DELIVERED,	&NOT_REPORTED_TO_AS400,
							END_OF_ARG_LIST																);

				Conflict_Test (reStart);
				
				if (SQLERR_error_test ())
				{
					SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
					break;
				}
			}	// End of error-writing loop.

		}
		while (0);	// Dummy loop should run only once.


		// Commit the transaction.
		if (reStart == MAC_FALS)	// No DB errors - OK to commit work.
		{
			CommitAllWork ();

			if (SQLERR_error_test ())	// Could not COMMIT
			{
				SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
			}
		}
		else
		{
			// We saw some kind of DB error - try to restart.
			if (TransactionRestart () != MAC_OK)
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			}
			
			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogReturn (GerrId, "Table is locked for the <%d> time", tries);
			
			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}	// DB error occurred.

	}	// End of Database Retries loop.
	
	
	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVarArr (&v_ErrorCode, ERR_DATABASE_ERROR, 0, 0, NULL, &ErrOverflow);
	}


	// Prepare and send Response Message (Message ID 5004/6004).

	// DonR 02Mar2011: Per Iris Shaya, if we've hit a severe error, clear any
	// "Mishur participation granted" messages on any items in the sale,
	// since they're no longer relevant.
	// DonR 11Apr2013: Note that this code appears twice, and is going to be redundant
	// in most cases. However, it is possible that we'll hit a database error "davka" when
	// writing error codes to prescription_msgs (see above), so we have to execute this
	// code again after all the database stuff is over, just in case.
	if (SetErrorVarArr (&v_ErrorCode, 0, 0, 0, NULL, NULL))
	{
		SetErrorVarDelete (ERR_GADGET_OP_REDUCED_BASIC,		0);
		SetErrorVarDelete (ERR_GADGET_OP_REDUCED_MAGEN,		0);
		SetErrorVarDelete (ERR_GADGET_OP_REDUCED_KEREN,		0);
		SetErrorVarDelete (ERR_GADGET_OP_REDUCED_YAHALOM,	0);
		SetErrorVarDelete (ERR_GADGET_OP_REDUCED_UNKNOWN,	0);
		SetErrorVarDelete (ERR_GADGET_APPROVED_BASIC,		0);
		SetErrorVarDelete (ERR_GADGET_APPROVED_MAGEN,		0);
		SetErrorVarDelete (ERR_GADGET_APPROVED_KEREN,		0);
		SetErrorVarDelete (ERR_GADGET_APPROVED_YAHALOM,		0);
		SetErrorVarDelete (ERR_GADGET_APPROVED_UNKNOWN,		0);
	}

	nOut =  sprintf (OBuffer,		 "%0*d",	MSG_ID_LEN,			TrNum + 1				);	// 6004.
	nOut += sprintf (OBuffer + nOut, "%0*d",	MSG_ERROR_CODE_LEN,	MAC_OK					);
	nOut += sprintf (OBuffer + nOut, "%0*d",	7,					v_PharmNum				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	2,					v_InstituteCode			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	2,					v_TerminalNum			);
	nOut += sprintf	(OBuffer + nOut, "%0*d",	9,					v_MemberIdentification	);
	nOut += sprintf (OBuffer + nOut, "%0*d",	1,					v_IdentificationCode	);
	nOut += sprintf (OBuffer + nOut, "%-*.*s",	14, 14,				v_MemberFamilyName		);
	nOut += sprintf (OBuffer + nOut, "%-*.*s",	8,  8,				v_MemberFirstName		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	8,					Member.date_of_bearth	);
	nOut += sprintf (OBuffer + nOut, "%0*d",	8,					SysDate					);
	nOut += sprintf (OBuffer + nOut, "%0*d",	6,					SysTime					);
	nOut += sprintf (OBuffer + nOut, "%0*d",	1,					v_MsgExistsFlg			);	// From Interaction/Overdose checking.
	nOut += sprintf (OBuffer + nOut, "%0*d",	1,					v_Message				);	// From pharmacy_message table.
	nOut += sprintf (OBuffer + nOut, "%0*d",	9,					v_RecipeIdentifier		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	2,					v_CreditYesNo			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	2,					v_NumOfDrugLinesRecs	);

	// Drug lines.
	for (i = 0; i < v_NumOfDrugLinesRecs; i++)
	{
		// DonR 05Jul2010: Per Iris Shaya, if this is a deletion we need to "flip" the OP/Units and
		// the total participation amount from negative back to positive before sending them to the
		// pharmacy.
		if (v_ActionType == SALE_DELETION)
		{
			SPres[i].Op			*= -1;
			SPres[i].Units		*= -1;
			MemberPtnAmount	[i]	*= -1;
		}

		// Line Number.
		nOut += sprintf (OBuffer + nOut, "%0*d",   2,			(i + 1)						);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			SPres[i].DrugCode			);
		nOut += sprintf (OBuffer + nOut, "%0*d",   5,			SPres[i].Units				);
		nOut += sprintf (OBuffer + nOut, "%0*d",   5,			SPres[i].Op					);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			SPres[i].RetOpDrugPrice		);

		// DonR 30Jul2023 User Story #468171: If this is a genuine consignment sale,
		// send zero instead of the Supplier Drug Price.
		nOut += sprintf	(OBuffer + nOut, "%0*d",   9,			(SPres[i].ValidConsignmentSale) ? 0 : SPres[i].SupplierDrugPrice	);

		nOut += sprintf (OBuffer + nOut, "%0*d",   4,			SPres[i].RetPartCode		);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			SPres[i].PriceSwap			);
		nOut += sprintf (OBuffer + nOut, "%0*d",   5,			SPres[i].AdditionToPrice	);

		// DonR 15Jan2009: Because we now add a "hundreds" digit to this variable to indicate why
		// specialist participation was given, we need to ensure that only the last two digits are
		// sent to the pharmacy - thus we send the variable "MOD 100".
		nOut += sprintf (OBuffer + nOut, "%0*d",   2,			(SPres[i].InsPlusPtnSource % 100));

		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			MemberPtnAmount[i]			);

		// Insurance type - isn't this redundant? (It's already the "tens" digit two fields up!)
		nOut += sprintf (OBuffer + nOut, "%0*d",   2,			((SPres[i].InsPlusPtnSource % 100) / 10));

		nOut += sprintf (OBuffer + nOut, "%c",					DrugTikraType	[i]			);
		nOut += sprintf (OBuffer + nOut, "%c",					DrugCoupon		[i]			);
		nOut += sprintf (OBuffer + nOut, "%0*d",   1,			SPres[i].in_health_pack		);
	}	// Output drug lines.


	// Output "Tikra" and "Coupon" lines (in same format).
	nOut += sprintf (OBuffer + nOut, "%0*d",   2,		(NumTikrotLines + NumCouponLines)	);

	// "Tikra" lines.
	for (i = 0; i < NumTikrotLines; i++)
	{
		nOut += sprintf (OBuffer + nOut, "%0*d",	2,			(i + 1)						);	// Line Number.
		nOut += sprintf (OBuffer + nOut, "2"												);	// = Tikra Line
		nOut += sprintf (OBuffer + nOut, "%c"  ,  				TikraType			[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	1,			TikraBasket			[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	2,			TikraInsurance		[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			TikraAggPrevPtn		[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			TikraAggPrevWaived	[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			TikraCurrPtn		[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			TikraCurrWaived		[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			TikraCurrLevel		[i]		);
		nOut += sprintf (OBuffer + nOut, "%-*.*s",	6, 6,		TikraPeriodDesc		[i]		);
		nOut += sprintf (OBuffer + nOut, "%0*d",	3,			0							);	// Coupon field - all zero for Tikra lines.
		nOut += sprintf (OBuffer + nOut, "%0*d",	9,			0							);	// Coupon field - all zero for Tikra lines.
	}

	// Coupon lines.
	for (i = 0; i < NumCouponLines; i++)
	{
		nOut += sprintf (OBuffer + nOut, "%0*d" ,  2,			(i + 1 + NumTikrotLines)	);	// Line Number - consecutive with Tikra lines.
		nOut += sprintf (OBuffer + nOut, "1"												);	// = "Shovar" (coupon) line.

		// Tikra Line fields are blank or zero for Coupons.
		nOut += sprintf (OBuffer + nOut, " "					  /* Tikra Type			*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d" ,  1,			0 /* TikraBasket		*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d" ,  2,			0 /* TikraInsurance		*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			0 /* TikraAggPrevPtn	*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			0 /* TikraAggPrevWaived	*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			0 /* TikraCurrPtn		*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			0 /* TikraCurrWaived	*/	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			0 /* TikraCurrLevel		*/	);
		nOut += sprintf (OBuffer + nOut, "      "				  /* TikraPeriodDesc	*/	);

		// Actual Coupon fields.
		nOut += sprintf (OBuffer + nOut, "%0*d",   3,			TikraCouponCode	[i]			);
		nOut += sprintf (OBuffer + nOut, "%0*d",   9,			TikraCouponAmt	[i]			);
	}


	// Output family T.Z. numbers.
	// DonR 29Jun2010: TEMPORARY FOR PILOT: Force family size to zero, since pharmacy-side
	// software isn't ready to deal with this stuff.
	FamilySize = 0;

	nOut += sprintf (OBuffer + nOut, "%0*d",	   2,				FamilySize				);
	for (i = 0; i < FamilySize; i++)
	{
		nOut += sprintf (OBuffer + nOut, "%0*d",   2,				(i + 1)					);
		nOut += sprintf	(OBuffer + nOut, "%0*d",   9,				FamilyMemberTZ		[i]	);
		nOut += sprintf (OBuffer + nOut, "%0*d",   1,				FamilyMemberTZCode	[i]	);
	}


	// Output error codes with associated Largo Codes.
	// DonR 25Jul2013: Added new parameter to SetErrorVarTell to give us the number of reportable errors -
	// since we're now sometimes creating "errors" that we don't send to the pharmacy. We put this number
	// into the variable j, send it to the pharmacy, and then immediately re-use the variable for something
	// different.
	ErrorCount = SetErrorVarTell (&ErrorArray, &j);
	nOut += sprintf (OBuffer + nOut, "%0*d",  3, j);	// = the number of "reportable" errors.

	for (i = 0, j = 0; i < ErrorCount; i++)
	{
		// DonR 24Jul2013: Added new "ReportToPharm" element in TErrorArray structure; this allows us
		// to assign error codes that are never to be sent to pharmacies. Note that we have to use
		// j instead of i to send the error line number to the pharmacy, since we may be skipping
		// some elements of the array.
		if (ErrorArray [i].ReportToPharm)
		{
			j++;
			nOut += sprintf (OBuffer + nOut, "%0*d",  3,					j							);
			nOut += sprintf (OBuffer + nOut, "%0*d",  9,					ErrorArray [i].LargoCode	);
			nOut += sprintf (OBuffer + nOut, "%0*d",  4,					ErrorArray [i].Error		);
		}	// Error is one that is to be reported to pharmacy.
	}

	// Output doctor information.
	if (VersionNumber > 0)
	{
		nOut += sprintf (OBuffer + nOut, "%0*d",  2,					NumDoctors		);

		for (i = 0; i < NumDoctors; i++)
		{
			nOut += sprintf (OBuffer + nOut, "%0*d",	 1,			Doctors[i].DocIDType		);
			nOut += sprintf (OBuffer + nOut, "%0*d",	 9,			Doctors[i].DocID			);
			nOut += sprintf (OBuffer + nOut, "%-*.*s",	14, 14,		Doctors[i].DoctorFamilyName	);
			nOut += sprintf (OBuffer + nOut, "%-*.*s",	 8,  8,		Doctors[i].DoctorFirstName	);
		}
	}


	// Return the size in Bytes of response message.
	*p_outputWritten			= nOut;
	*output_type_flg			= ANSWER_IN_BUFFER;
	ssmd_data_ptr->error_code	= v_ErrorCode;
	ssmd_data_ptr->pharmacy_num	= v_PharmNum;
	ssmd_data_ptr->terminal_num	= v_TerminalNum;


	// DonR 23Nov2017: Store number of drug lines in audit-trail variable.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = v_NumOfDrugLinesRecs;


	RESTORE_ISOLATION;

	return  RC_SUCCESS;

}	// End of 6003 handler.



/*=======================================================================
||																		||
||			 HandlerToMsg_6005											||
||	Message handler for message 6005:									||
||        Drugs Delivery - "Digital Prescription" version				||
||																		||
||																		||
 =======================================================================*/

int HandlerToMsg_6005 (	char		*IBuffer,
						int			TotalInputLen,
						char		*OBuffer,
						int			*p_outputWritten,
						int			*output_type_flg,
						SSMD_DATA	*ssmd_data_ptr,
						int			*NumProcessed_out)

{
	// Variable declarations
	ISOLATION_VAR;
	int				nOut;
	int				i;
	int				j;
	int				is;
	int				reStart;
	int				ElyCount;
	int				flg;
	int				UnitsSellable;
	int				UnitsSold;
	int				ComparePharmPtn;
	int				CarryForwardUnits	= 0;
	int				RowsFound;
	short			MaxRx				= 1;	// Element 0 is blank; real data is loaded starting at 1.
	short			MaxPrescSource		= 0;
	short			dummy;
	TErrorCode		err;
	TErrorSevirity	Sever;
	TMonthLog		MonthLogCalc_next;
	TMonthLog		MonthLogCalc;
	short			NextMonthMinDay;
	ACTION_TYPE		AS400_Gadget_Action;
	int				GadgetPharm;
	char			filler [256];

	// Message fields variables

	// Prescription Lines structure
	Msg6005Drugs	phDrgs				[MAX_REC_ELECTRONIC];
	Msg6005Drugs	*phDrgPtr;
	Msg6005Drugs	dbDrgs;
	TDocRx			DocRx				[1001];
	TDocRx			DbRx;
	TDocRx			*DocRxPtr;
	short			NumVouchers			= 0;	// DonR 02Jun2021 User Story #163882.
	short			VoucherNum;					// DonR 02Jun2021 User Story #163882.
	TVoucherUsed	Voucher				[1000];	// DonR 02Jun2021 User Story #163882.
	short			NumOtherSales;
	short			OtherSaleNum;
	int				OtherSaleID			[MAX_REC_ELECTRONIC];
	short			OtherSaleCredLine	[MAX_REC_ELECTRONIC];
	short			OtherSalePmtType	[MAX_REC_ELECTRONIC];

	// New stuff for "Nihul Tikrot"
	short						v_ActionType;
	short						v_RetnReasonCode;
	short						v_6003CommError;
	int							v_CardOwnerID;			// Actually Second Pharmacist TZ - written to RK9021P/EAZHZR.
	short						v_CardOwnerIDCode;		// Actually reserved for future use - written to RK9021P/EAPUUA.
	short						v_CreditLinePmts = 0;	// DonR 17May2016: For now at least, we are *not* getting this from pharmacy!
	short						v_PaymentType;
	int							v_TotalTikraDisc;
	int							v_TotalCouponDisc;
	short						v_PharmPtnCode;

	// Variables for deletion/refund of previous sales.
	int							v_DeletedPrID;
	int							sq_DeletedPrID;		// DonR 15Mar2011 - in case original sale came via spool.
	int							v_DeletedPrDate;
	int							v_DeletedPrPharm;
	short						v_DeletedPrYYMM;
	int							v_DeletedPrPhID;
	int							v_DeletedRxLargo;

	// Pharmacy Daily Sum.
	int							PDS_sum				= 0;
	int							PDS_prt_sum			= 0;
	int							PDS_lines			= 0;
	int							PDS_count			= 0;
	int							PDS_purch_sum		= 0;
	int							PDS_del_sum			= 0;
	int							PDS_del_prt_sum		= 0;
	int							PDS_del_lines		= 0;
	int							PDS_del_count		= 0;
	int							PDS_del_purch_sum	= 0;
	int							PDS_date			= 0;

	short						Rx_OpUpdate;
	short						Rx_UnitsUpdate;
	short						Rx_status;

	int							v_ClientLocationCode;
	short						v_ReasonToDispense;
	short						v_in_gadget_table;

	// DonR 12Feb2006: Ingredients-sold fields.
	double						v_package_volume;
	short						v_ingr_1_code;
	short						v_ingr_2_code;
	short						v_ingr_3_code;
	double						v_ingr_1_quant;
	double						v_ingr_2_quant;
	double						v_ingr_3_quant;
	double						v_ingr_1_quant_std;
	double						v_ingr_2_quant_std;
	double						v_ingr_3_quant_std;
	double						v_per_1_quant;
	double						v_per_2_quant;
	double						v_per_3_quant;

	// DonR 01Feb2024 User Story #540234: Add reporting of cannabis product details.
	short						TotalNumCannabisProducts	= 0;
	short						Product;
	TCannabisProducts			CannabisProduct [MAX_CANNABIS_PRODUCTS];

	TDrugListRow				DL;
	PHARMACY_INFO				Phrm_info;
	int							v_PharmNum;
	short						v_InstituteCode;
	short						v_TerminalNum;
	TMemberBelongCode			v_MemberBelongCode;
	int							v_MemberID;
	TIdentificationCode			v_IDCode;
	TMoveCard					v_MoveCard;
	int							v_DoctorID;
	short						v_ElectPrStatus		= 0;
	int							v_InvoiceNum;
	int							v_UserIdentification;
	int							v_PharmRecipeNum;
	int							v_RecipeIdentifier;
	int							ALT_RecipeIdentifier;	// DonR 29Dec2020 TEMPORARY for volume testing. VOLUME-TEST-HACK
	int							ALT_MinimumSaleTime;	// DonR 29Dec2020 TEMPORARY for volume testing. VOLUME-TEST-HACK
	int							SaleDate;
	int							SaleTime;
	short						v_MonthLog;
	short						v_NumOfDrugLinesRecs;
	short						v_CreditYesNo;
	short						paid_for;				// DonR 05Feb2023 User Story #232220

	int							v_SpecialConfNum;
	short						v_SpecialConfSource;

	// Remote order variables.
	long						online_order_num	= 0L;
	long						OnlineOrderNum_6005	= 0L;	// DonR 20Apr2023 User Story #432608 - only to check against value from Trn. 6003.
	long						MagentoOrderNum		= 0L;	// DonR 20Apr2023 User Story #432608.
	int							OO_made_pr_id;

	// Gadgets/Gadget_spool tables.
	short						v_action;
	int							v_service_code;
	int							v_gadget_code;
	int							v_service_number;
	int							v_service_type;
	int							v_DrugCode;
	int							Unit_Price;
	int							v_DoctorPrID;
	int							v_DoctorPrDate;
	short						PRW_OriginCode;
	TErrorCode					GadgetError;
	int							GadgetRecipeID;

	// Return-message variables
	int							SysDate;
	int							SysTime;
	TErrorCode					v_ErrorCode;


	// Miscellaneous DB variables
	short						sq_ActionType;
	int							sq_pharmnum;
	TInstituteCode				sq_institutecode;
	TTerminalNum				sq_terminalnum;
	TPriceListNum				sq_pricelistnum;
	int							sq_doctorprescid;
	TMemberBelongCode			sq_memberbelongcode;
	int							sq_MemberID;
	TIdentificationCode			sq_identificationcode;
	short						sq_DocIDType;				// Read from DB, but not used for anything.
	int							sq_doctoridentification;	// Read from DB, but not used for anything.
	TRecipeSource				sq_recipesource;
	TNumOfDrugLinesRecs			sq_numofdruglinesrecs;
	short						sq_errorcode;
	short						prev_pr_errorcode;
	int							sq_TotalMemberPrice;
	int							sq_TotalDrugPrice;
	int							sq_TotSuppPrice;
	int							sq_member_discount;
	int							sq_stopusedate;
	int							sq_maxdrugdate;
	int							max_drug_date;
	short						sq_thalf;
	int							sq_DateDB;
	TMonthLog					sq_MonthLogDB;
	int							v_count_double_rec;
	short						v_MemberSpecPresc;
	int							sq_Op;
	int							sq_Units;
	int							sq_tikra_discount;
	int							sq_subsidy_amount;
	int							sq_VoucherAmtUsed;
	int							tr6003_date;
	int							tr6003_time;
	int							earliest_tr6003_date;
	int							earliest_tr6003_time;
	short						Rx;
	short						NeedToQueueSaleStatusUpdates = MAC_FALS;

	// DonR 01Jun2022: Add some "counter" variables to diagnose sporadic
	// cases where sale deletions don't update prescription_drugs or other
	// tables - meaning that the deletion doesn't actually delete anything.
	int							AuditNumLines			= 0;
	int							AuditNumDrugsMatched	= 0;
	int							AuditNumRxRead			= 0;
	int							AuditNumDrugsLooped		= 0;
	int							AuditNumDrugsAttempted	= 0;
	int							AuditNumDrugsUpdated	= 0;


	// Body of function.

	// Initialize variables.
	REMEMBER_ISOLATION;
	PosInBuff	= IBuffer;
	v_ErrorCode	= NO_ERROR;
	SysDate		= GetDate ();
	SysTime		= GetTime ();
	memset ((char *)phDrgs,				0, sizeof (phDrgs));
	memset ((char *)&dbDrgs,			0, sizeof (dbDrgs));			// (This one is not an array.)
	memset ((char *)DocRx,				0, sizeof (DocRx));
	memset ((char *)CannabisProduct,	0, sizeof (CannabisProduct));	// DonR 01Feb2024 User Story #540234.


	// Read message fields data into variables.
	// NOTE: Field offsets are calculated based on the most recent version of the transaction. To
	// "deconstruct" an incoming message with an earlier transaction version number, adjust accordingly.
	// DonR 13Aug2024: Copy Pharmacy Code and Member TZ/Code to SSMD structure as soon as they're read;
	// this will give more informative error messages if we hit an error parsing the pharmacy request.
	v_PharmNum					= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//   1:  10,  7
	ssmd_data_ptr->pharmacy_num = v_PharmNum;

	v_InstituteCode				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   2:  17,  2
	v_TerminalNum				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   3:  19,  2
	v_ActionType				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   4:  21,  2
	v_RetnReasonCode			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   5:  23,  2
	v_6003CommError				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//   6:  25,  4
	v_DeletedPrID				= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//   7:  29,  9
	v_DeletedPrPharm			= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//   8:  38,  7
	v_DeletedPrYYMM				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//   9:  45,  4
	v_DeletedPrPhID				= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  10:  49,  6
	v_DeletedPrDate				= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  11:  55,  8

	v_MemberID					= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  12:  63,  9
	ssmd_data_ptr->member_id = v_MemberID;

	v_IDCode					= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  13:  72,  1
	ssmd_data_ptr->member_id_ext = v_IDCode;

	v_MemberBelongCode			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  14:  73,  2

	// DonR 20Aug2018: "Card Owner ID" is in fact the TZ of the second pharmacist, for those cases where
	// two pharmacists have to pass their cards to permit a drug sale to happen. It's written to
	// RKFILPRD/RK9021P/EAZHZR. "Card Owner ID Code" is written to EAPUUA, but in fact it's a "reserved
	// for future use" field at present.
	v_CardOwnerID				= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  15:  75,  9
	v_CardOwnerIDCode			= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  16:  84,  1

	v_MoveCard					= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  17:  85,  4
	v_UserIdentification		= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  18:  89,  9
	v_SpecialConfSource			= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  19:  98,  1
	v_SpecialConfNum			= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  20:  99,  8
	v_PharmRecipeNum			= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  21: 107,  6
	v_RecipeIdentifier			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  22: 113,  9
	SaleDate					= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  23: 122,  8
	SaleTime					= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  24: 130,  6

	// Note: This will be the Credit Type Used. In some circumstances, it may be
	// different from the Credit Type that was sent to the pharmacy - for example,
	// the member may elect to pay in cash even though s/he has an automated
	// payment ("orat keva") set up. This value will be stored in the new database
	// field credit_type_used.
	v_CreditYesNo				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  25: 136,  2

	// 19Mar2023: Current versions running in Production are 1 and 3
	// (plus a very small number of 2's). Next Version Number will be 4.
	VersionNumber				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  26: 138,  2

	v_PaymentType				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  27: 140,  2
	v_InvoiceNum			 	= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//  28: 142,  7
	v_ClientLocationCode		= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//  29: 149,  7
	v_MonthLog					= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  30: 156,  4
	v_ReasonToDispense			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  31: 160,  2
	v_TotalTikraDisc			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  32: 162,  9
	v_TotalCouponDisc			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  33: 171,  9
	v_PharmPtnCode				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  34: 180,  4

	// DonR 20Mar2023 User Story #432608: For Transaction Version 4, add two order-number fields, plus a
	// new "reserved" field for future use. Magento Order Number is the internal order number created by
	// Magento for the Virtual Pharmacy system; Online Order Number links to our own Online Orders table.
	if (VersionNumber > 3)
	{
		MagentoOrderNum			= GetLong	(&PosInBuff, 10				); CHECK_ERROR();	//  35: 184, 10
		OnlineOrderNum_6005		= GetLong	(&PosInBuff, 10				); CHECK_ERROR();	//  36: 194, 10
		GetNothing							(&PosInBuff, 20				); 					//  37: 204, 20
	}

	// If Version Number < 4, subtract 40 bytes from the offsets!
	v_NumOfDrugLinesRecs		= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  38: 224,  2

	// DonR 01Jun2022: For diagnostic purposes, save v_NumOfDrugLinesRecs to an "audit" variable.
	AuditNumLines = v_NumOfDrugLinesRecs;

	// Get drug lines. (679 characters/line, not including doctor-prescriptions of 45 characters each.)
	for (i = 0; i < v_NumOfDrugLinesRecs; i++)
	{
		phDrgs[i].LineNumber		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  39: 226,  2

		// DonR 02Mar2016: For now, Largo Codes are only five digits even though the message space for them
		// has expanded. Since six-digit Largo Codes blow up transmission of tables to AS/400 (and we've seen
		// this happen only for Doctor Largo Code), catch this problem right at the outset and reject the
		// transaction.
		// DonR 15Jul2024 User Story #349368: Largo Codes are being expanded to 6 digits on AS/400.
		// Accordingly, adjust the "sanity check" to allow one more digit.
		phDrgs[i].Orig_Largo_Code	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  40: 228,  9
		if (phDrgs[i].Orig_Largo_Code > 999999)
			SET_ERROR (ERR_WRONG_FORMAT_FILE);

		phDrgs[i].DrugCode			= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  41: 237,  9
		phDrgs[i].SubstPermitted	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  42: 246,  2
		phDrgs[i].Units				= GetInt	(&PosInBuff,  5			); CHECK_ERROR();	//  43: 248,  5
		phDrgs[i].Op				= GetInt	(&PosInBuff,  5			); CHECK_ERROR();	//  44: 253,  5
		phDrgs[i].use_instr_template= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  45: 258,  1
		phDrgs[i].how_to_take_code	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  46: 259,  3

		// NumPerDose is now in hundredths - so 1 is sent as 000100, and 2 1/2 is sent as 000250.
		phDrgs[i].NumPerDose		= GetInt	(&PosInBuff,  6			); CHECK_ERROR();	//  47: 262,  6

		GetString	(&PosInBuff, phDrgs[i].unit_code,		  3			); CHECK_ERROR();	//  48: 268,  3

		phDrgs[i].DosesPerDay		= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  49: 271,  1
		phDrgs[i].Duration			= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  50: 272,  3
		phDrgs[i].course_treat_days	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  51: 275,  3

		if (VersionNumber > 0)
		{
			phDrgs[i].course_len_days	= GetShort	(&PosInBuff,  3		); CHECK_ERROR();	//  52: 278,  3
		}

		phDrgs[i].course_len		= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  53: 281,  3
		GetString	(&PosInBuff, phDrgs[i].course_len_units, 10			); CHECK_ERROR();	//  54: 284, 10
		GetString	(&PosInBuff, phDrgs[i].days_of_week,	 20			); CHECK_ERROR();	//  55: 294, 20
		GetString	(&PosInBuff, phDrgs[i].times_of_day,	 (VersionNumber > 0) ? 200 : 40	); CHECK_ERROR();	// 56: 294, CHANGE FROM 40 TO 200.
		GetString	(&PosInBuff, phDrgs[i].side_of_body,	 10			); CHECK_ERROR();	//  57: 514, 10
		phDrgs[i].LinkToAddition	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  58: 524,  9
		phDrgs[i].OpDrugPrice		= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  59: 533,  9
		phDrgs[i].SupplierDrugPrice	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  60: 542,  9
		phDrgs[i].MemberPtnCode		= GetShort	(&PosInBuff,  4			); CHECK_ERROR();	//  61: 551,  4
		phDrgs[i].FixedPrice		= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  62: 555,  9
		phDrgs[i].MemberDiscPC		= GetShort	(&PosInBuff,  5			); CHECK_ERROR();	//  63: 564,  5
		phDrgs[i].TotalDrugPrice	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  64: 569,  9
		phDrgs[i].TotalPtn			= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  65: 578,  9
		phDrgs[i].DrugDiscountAmt	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  66: 587,  9

		// Normally, this can be ignored - since it's written to the DB by Trn. 6003.
		phDrgs[i].ParticipMethod	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  67: 596,  2

		phDrgs[i].StockOP			= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  68: 598,  7
		phDrgs[i].StockUnits		= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  69: 605,  7
		phDrgs[i].DrugDiscountCode	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  70: 612,  3
		phDrgs[i].InsuranceUsed		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  71: 615,  2
		phDrgs[i].DrugTikraType		= GetChar	(&PosInBuff				); CHECK_ERROR();	//  72: 617,  1
		phDrgs[i].DrugSubsidized	= GetChar	(&PosInBuff				); CHECK_ERROR();	//  73: 618,  1
		phDrgs[i].InHealthBasket	= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  74: 619,  1

		// If Version > 0, Electronic Pr. Status gets sent with length = 2.
		phDrgs[i].ElectPrStatus		= GetShort	(&PosInBuff,  (VersionNumber > 0) ? 2 : 1	); CHECK_ERROR();	// 75: 620,  2

		phDrgs[i].DocIDType			= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  76: 622,  1
		phDrgs[i].DocID				= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  77: 623,  9
		phDrgs[i].PrescSource		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  78: 632,  2
		phDrgs[i].DocFacility		= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  79: 634,  7

		// DonR 29Oct2018: Fixed version number - Version 2 already got rid of Visit Number.
		if (VersionNumber > 1)
		{
			phDrgs[i].NumCourses		= GetShort	(&PosInBuff,  3		); CHECK_ERROR();	//  80: 641,  3	(Treatment Length in Course units)
			phDrgs[i].IsDigital			= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  81: 644,  1
			phDrgs[i].VoucherAmtUsed	= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  82: 645,  6 (DonR 07Jun2021 User Story #163882 - flip negative for deletions!)
			phDrgs[i].BarcodeScanned	= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  83: 651,  1

			phDrgs[i].VisitNumber		= 0L;
		}
		else
		{
			phDrgs[i].VisitNumber		= GetLong	(&PosInBuff, 11		); CHECK_ERROR();	// (78: 621, 11) ==> Change to 3 (num_courses) + 8 (reserved) for Version > 0

			phDrgs[i].IsDigital			= 0;
			phDrgs[i].BarcodeScanned	= 0;
		}

		phDrgs[i].use_instr_changed	= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  84: 652,  1

		// DonR 21Mar2023 User Story #432608: For Transaction Version Number 4, add eight new
		// fields plus a 20-byte reserve (169 bytes total, plus the 40 bytes for Version > 3 above = 209).
		if (VersionNumber > 3)
		{
			GetString	(&PosInBuff, phDrgs[i].UsageInstrGiven,	100		); CHECK_ERROR();	//  85: 653, 100

			// An explanation of new OTC price/sale/discount numbers, courtesy of Iris Shaya:
			// 1) MaccabiOtcPrice is a discount price, normally set in the price_list table.
			// 2) SalePkgPrice, when present, is normally lower than the Maccabi price; it's
			//    set by the sale tables and typically has a time limit.
			// 3) "Buy1Get1" is a *further* reduction; it can be in the form of "Buy 1, get
			//    the second at a lower price," or it can be "Buy Item X, get Y at a special
			//    price." Basically, it's some form of "basket" discount *on top of* any
			//    Maccabi Price and Sale Price discounts.
			// 4) "By Hand" reductions are *additional* reductions given on a case-by-case
			//    basis by the pharmacy; for example, if the price tag on an item shows a
			//    lower price than any of the discount prices in the database, the pharmacy
			//    is normally obligated to sell the item at that price.
			// 5) The two Sale Number values refer to the Sale tables that give SalePkgPrice
			//    and/or Buy1Get1 discounts.
			// 6) IsConsignment indicates that this is an item normally available only at
			//    Maccabi pharmacies, but sold by specific private pharmacies (all SuperPharm,
			//    I believe) "on consignment". Since the private pharmacy is acting basically
			//    as an agent for MaccabiPharm, I believe the "consignment" (a.k.a. "consignatzia")
			//    item will be sold with terms as if it were being sold at a Maccabi pharmacy.
			phDrgs[i].MaccabiOtcPrice	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  86: 753,   9
			phDrgs[i].SalePkgPrice		= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  87: 762,   9
			phDrgs[i].SaleNum4Price		= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  88: 771,   6
			phDrgs[i].SaleNumBuy1Get1	= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  89: 777,   6
			phDrgs[i].Buy1Get1Savings	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  90: 783,   9
			phDrgs[i].ByHandReduction	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  91: 792,   9
			phDrgs[i].IsConsignment		= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  92: 801,   1
			GetNothing								(&PosInBuff, 20		); 					//  93: 802,  20	(Reserved for expansion)
		}	// DonR 21Mar2023 User Story #432608 end.

		// For Transaction Version Number < 4, subtract 209 from the byte offsets below!

		phDrgs[i].NumDocRxes		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  94: 822,  2

		// Set starting point for this drug-line in the Doctor Prescription array.
		if (phDrgs[i].NumDocRxes > 0)
			phDrgs[i].FirstRx = MaxRx;
		else
			phDrgs[i].FirstRx = 0;	// Should already be zero (pointing to a blank array element), but let's be sure!

		if (phDrgs[i].PrescSource > MaxPrescSource)
			MaxPrescSource = phDrgs[i].PrescSource;


		// Read in the specific prescriptions that are combined in this drug-line. (45 characters/Rx)
		// DonR 09Jul2015: Per Iris Shaya, for deletions we don't want to read doctor-prescription stuff
		// from the incoming transaction even if the pharmacy has supplied them.
		if (v_ActionType == SALE_DELETION)
		{
			for (Rx = 0; Rx < phDrgs[i].NumDocRxes; Rx++)
			{
				if (VersionNumber > 0)
				{
					GetNothing	(&PosInBuff,  21);	// Visit Number and OP/Units Unsold: 11 + 5 + 5.
				}

				GetNothing	(&PosInBuff,  24);	// PrID, FromDate, Units, OP: 6 + 8 + 5 + 5.
			}

			phDrgs[i].NumDocRxes = phDrgs[i].FirstRx = 0;
		}	// Ignore incoming doctor-prescription information for deletions.

		else
		{	// We're not deleting, so go ahead and read the doctor-prescription data.
			for (Rx = 0; Rx < phDrgs[i].NumDocRxes; Rx++, MaxRx++)
			{
				if (VersionNumber > 0)
				{
					DocRx [MaxRx].VisitNumber	= GetLong	(&PosInBuff, 11	); CHECK_ERROR ();	//  95: 824, 11
				}
				else
				{
					DocRx [MaxRx].VisitNumber	= phDrgs[i].VisitNumber;
				}

				DocRx [MaxRx].PrID		= GetInt	(&PosInBuff,  6			); CHECK_ERROR ();	//  96: 835,  6
				DocRx [MaxRx].FromDate	= GetInt	(&PosInBuff,  8			); CHECK_ERROR ();	//  97: 841,  8
				DocRx [MaxRx].Units		= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	//  98: 849,  5
				DocRx [MaxRx].OP		= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	//  99: 854,  5

				if (VersionNumber > 0)
				{
					// These are the numbers that were sent in Transaction 6001; comparing them with
					// OP/Units Sold will tell us if this is a full or a partial sale.
					DocRx [MaxRx].UnitsUnsold	= GetInt	(&PosInBuff,  5	); CHECK_ERROR ();	// 100: 859,  5
					DocRx [MaxRx].OP_Unsold		= GetInt	(&PosInBuff,  5	); CHECK_ERROR ();	// 101: 864,  5
				}

			}	// Loop through doctor prescriptions combined in this drug line.

		}	// We're not deleting, so go ahead and read the doctor-prescription data.

		// DonR 01Feb2024 User Story #540234: Read in cannabis product details. Note that at least
		// for now, we will read this infomation for deletions the same as we do for sales.
		// NOTE: Offsets assume NO doctor prescriptions. For each doctor prescription, add 45 bytes.
		// Also note: Each Cannabis line is 79 bytes.
		if (VersionNumber > 4)
		{
			phDrgs[i].NumCannabisProducts	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  102: 824,  2

			for (Product = 0; Product < phDrgs[i].NumCannabisProducts; Product++, TotalNumCannabisProducts++)
			{
				CannabisProduct [TotalNumCannabisProducts].DrugLineSubscript		= i;
				CannabisProduct [TotalNumCannabisProducts].cannabis_product_code	= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 103: 826,  9
				CannabisProduct [TotalNumCannabisProducts].cannabis_product_barcode	= GetLong	(&PosInBuff, 13	); CHECK_ERROR ();	// 104: 835, 13
				CannabisProduct [TotalNumCannabisProducts].op						= GetShort	(&PosInBuff,  5	); CHECK_ERROR ();	// 105: 848,  5
				CannabisProduct [TotalNumCannabisProducts].units					= GetShort	(&PosInBuff,  5	); CHECK_ERROR ();	// 106: 853,  5
				CannabisProduct [TotalNumCannabisProducts].price_per_op				= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 107: 858,  9
				CannabisProduct [TotalNumCannabisProducts].product_sale_amount		= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 108: 867,  9
				CannabisProduct [TotalNumCannabisProducts].product_ptn_amount		= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 109: 876,  9
				GetNothing	(&PosInBuff,  20);																						// 110: 885, 20 Reserved for future use.
			}
		}

		// DonR 11Jan2021: Times_of_day is only 40 characters in the database, at least for now; to
		// avoid database errors (which I see in MS-SQL testing, although not in Informix), truncate
		// the field so the database server doesn't kvetch.
		// DonR 18Apr2023 User Story #432608: Times of Day is now 200 characters in the database,
		// so there's no need to truncate it anymore.
//		phDrgs[i].times_of_day [40] = (char)0;

		// DonR 20Feb2022: Just to make things neat and tidy in the database, strip
		// leading and trailing spaces from Course Length Units.
		StripAllSpaces (phDrgs[i].course_len_units);

	}	// Drug-line reading loop.

	// DonR 02Jun2021 User Story #163882: Instead of unfilled prescriptions (which was never put into
	// real-world use), get a list of vouchers applied by the pharmacy to each relevant drug line.
	NumVouchers											= GetShort	(&PosInBuff,  2		); CHECK_ERROR ();	// 111: 950,  2 (assuming 45 bytes for 1 Rx)

//	if (!TikrotProductionMode) GerrLogMini (GerrId, "\nNum_vouchers = %d.", NumVouchers);

//	// Read in unfilled (or partially-filled?) prescriptions. For now at least, we
//	// aren't actually going to do anything with them.
//	// WORKINGPOINT: WHAT DO WE DO WITH UNFILLED-PRESCRIPTION INFORMATION?
	for (VoucherNum = 0; VoucherNum < NumVouchers; VoucherNum++)
	{
		Voucher [VoucherNum].voucher_num				= GetLong	(&PosInBuff, 11		); CHECK_ERROR ();	// 112: 952, 11
		GetString		(&PosInBuff, Voucher [VoucherNum].voucher_type,			 15		); CHECK_ERROR ();	// 113: 963, 15
		Voucher [VoucherNum].voucher_discount_given		= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 114: 978,  9
		Voucher [VoucherNum].voucher_amount_remaining	= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 115: 987,  9
		Voucher [VoucherNum].original_voucher_amount	= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 116: 996,  9

		GetNothing	(&PosInBuff,  20);	// Reserved for future use											   117: 1005, 20
//
//		if (!TikrotProductionMode)
//			GerrLogMini (GerrId, "Voucher #%d/%d: Discount %d, remaining %d, orig. %d.", (VoucherNum + 1), NumVouchers, Voucher [VoucherNum].voucher_discount_given,
//						 Voucher [VoucherNum].voucher_amount_remaining, Voucher [VoucherNum].original_voucher_amount);

// Previously, there was an idea of including unfilled prescriptions here. As of Mar2023, this has never been
// implemented, and it doesn't appear to be a "live" idea at present.
//		UnfilledRx [Rx].PrID			= GetInt	(&PosInBuff,  6			); CHECK_ERROR ();	//  92: 673,  6
//		UnfilledRx [Rx].FromDate		= GetInt	(&PosInBuff,  8			); CHECK_ERROR ();	//  93: 679,  8
//		UnfilledRx [Rx].Doctor_Largo	= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	//  94: 687,  9
//		UnfilledRx [Rx].Filled_Status	= GetShort	(&PosInBuff,  1			); CHECK_ERROR ();	//  95: 696,  1
//		UnfilledRx [Rx].Reason_Code		= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	//  96: 697,  3
	}


	// Read in additional drug sales being charged to the same Credit Line.
	// NIU (i.e. the number of lines should always be zero) as of 24May2010.
	// DonR 27Mar2023 User Story #232220: This code is now going into use.
	NumOtherSales = GetShort (&PosInBuff,  2); CHECK_ERROR();									// 118: 1025,  2

	for (OtherSaleNum = 0; OtherSaleNum < NumOtherSales; OtherSaleNum++)
	{
		OtherSaleID			[OtherSaleNum]	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	// 119: 1027,  9
		OtherSaleCredLine	[OtherSaleNum]	= GetShort	(&PosInBuff,  2		); CHECK_ERROR();	// 120: 1036,  2
		GetNothing	(&PosInBuff,  15);	// Reserved for future use								   121: 1038, 15
//		OtherSalePmtType	[OtherSaleNum]	= GetShort	(&PosInBuff,  2		); CHECK_ERROR();	// 121: 1038,  2 NOT IN USE, AT LEAST FOR NOW.
		OtherSalePmtType	[OtherSaleNum]	= v_PaymentType;	// At least until we get this added to the list.
		// Iris may want to add a new Number of Payments value here.

		// DonR 04Mar2024 User Story #232220: Pharmacies may, apparently, send the last 6005 in
		// the series with Credit Type 99 (= unpaid) and then include the last Prescription ID
		// in this list of transactions to mark "paid". In order to avoid duplicate updates and
		// other potential problems, change Credit Type here if the "other sale" is in fact the
		// current sale. In this case, we'll set the "other sale ID" to zero so we won't update
		// it again at the end.
		if ((v_CreditYesNo						== 99)					&&
			(OtherSaleID		[OtherSaleNum]	== v_RecipeIdentifier)	&&
			(OtherSaleCredLine	[OtherSaleNum]	!= 99))
		{
			v_CreditYesNo				= OtherSaleCredLine [OtherSaleNum];
			v_PaymentType				= OtherSalePmtType	[OtherSaleNum];
			OtherSaleID [OtherSaleNum]	= 0;
		}
	}	// Loop through "other sales" reported by pharmacy.


	// Get amount of input not eaten
	ChckInputLen( TotalInputLen - (PosInBuff - IBuffer) );
	CHECK_ERROR();

//	// Copy values to ssmd_data structure.
//	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
//	ssmd_data_ptr->member_id		= v_MemberID;
//	ssmd_data_ptr->member_id_ext	= v_IDCode;
//
	// Validate Date and Time.
	ChckDate (SaleDate); CHECK_ERROR();	 
	ChckTime (SaleTime); CHECK_ERROR();

	// DonR 05Feb2023 User Story #232220: Set paid-for flag based on Credit Used.
	// By default, any Credit Used value means that the transaction *has* been
	// paid for; the exception is 99, which means that the payment method for this
	// transaction has not yet been decided.
	paid_for = (v_CreditYesNo == 99) ? 0 : 1;

	// DonR 09May2024 User Story #309732: If this transaction is just marking already-delivered
	// stuff as "paid for", force Number of Drug Lines to zero.
	if (v_ActionType == MARK_AS_PAID)
	{
		v_NumOfDrugLinesRecs = 0;	// No matter what the pharmacy sent!
	}

	// We don't actually do anything with the Doctor Facility Code in the non-spooled version of Trn. 6005,
	// but just for consistency, we'll "fix" it the way we do in Trn. 6003.
	for (i = 0; i < v_NumOfDrugLinesRecs; i++)
	{
		if (phDrgs[i].DocFacility != 0)
		{
			phDrgs[i].DocFacility -= 990000;	// The initial "99" gets thrown away.

			if ((phDrgs[i].DocFacility < 1) || (phDrgs[i].DocFacility > 9999))
			{
				phDrgs[i].DocFacility = 0;	// So we don't blow anything up sending bogus values to the DB or AS/400.
			}
		}
	}


	// SQL Retry Loop.
	for (tries = 0, reStart = MAC_TRUE; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		// Initialize response variables.
		v_ErrorCode						= NO_ERROR;
		reStart							= MAC_FALS;
		NeedToQueueSaleStatusUpdates	= MAC_FALS;
		max_drug_date					= 0;

		memset ((char *)&dbDrgs, 0, sizeof (dbDrgs));


		// DonR 24May2022 BUG FIX: If this is a sale deletion and we're retrying the transaction,
		// re-initialize various variables and arrays. Otherwise the transaction may think it
		// finished successfully, but in fact no sold drugs were deleted at all.
		// DonR 18Jul2023: Disabled the log message, since the fix has been running OK for over a year.
		if ((tries > 0) && (v_ActionType == SALE_DELETION))
		{
//			GerrLogMini (GerrId, "6005 re-initializing deletion PrID %d for %d drugs; MaxRx was %d, tries = %d, DeletedPrID = %d.",
//						 v_RecipeIdentifier, v_NumOfDrugLinesRecs, MaxRx, tries, v_DeletedPrID);

			// Remember that for online deletions, even if the pharmacy sent doctor-prescription
			// data (which they don't), we ignore it and read doctor prescriptions from the
			// database. So if we're retrying, set everything back to zero.
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				phDrgs[i].NumDocRxes = phDrgs[i].FirstRx = 0;
			}

			MaxRx = 1;	// Reminder: Element 0 is blank; real data is loaded starting at 1.
			memset ((char *)DocRx, 0, sizeof (DocRx));
		}


		// Dummy loop to avoid GOTO.
		do		// Exiting from LOOP will send the reply to pharmacy.
		{
			// Select cursors.
			// DonR 25Jun2020: Moved this here, so we'll have logging and retry capability
			// if there's any problem declaring the cursor.
			DeclareCursorInto (	MAIN_DB, TR6005_prescription_drugs_cur,
								&dbDrgs.DrugCode,			&dbDrgs.DocID,					&dbDrgs.Op,
								&dbDrgs.Units,				&dbDrgs.LineNo,					&dbDrgs.LinkToAddition,
								&dbDrgs.OpDrugPrice,		&dbDrgs.SupplierDrugPrice,		&sq_errorcode,

								&sq_stopusedate,			&sq_thalf,						&dbDrgs.PrescWrittenID,
								&dbDrgs.ParticipMethod,		&dbDrgs.member_ptn_amt,			&dbDrgs.MacabiPriceFlag,
								&dbDrgs.StopBloodDate,		&dbDrgs.ph_otc_unit_price,		&dbDrgs.PrescSource,
				
								&v_RecipeIdentifier,		&DRUG_NOT_DELIVERED,			END_OF_ARG_LIST				);

			Conflict_Test (reStart);

			if (SQLERR_error_test ())
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			}

			// Test pharmacy data.
			v_ErrorCode = IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);

			if (v_ErrorCode != MAC_OK)
			{
				break;
			}


			// if v_MonthLog different from MonthLog  now must check
			// if lasts days of the months =>   possible next month
			MonthLogCalc		= (SysDate / 100) % 10000;	// YYMM.
			MonthLogCalc_next	= MonthLogCalc;
			NextMonthMinDay = ((MonthLogCalc % 100) == 2) ? 23 : 25;

			if (v_MonthLog != MonthLogCalc)
			{
				if (SysDate % 100 > NextMonthMinDay)	// After 25th of current month (or 23rd if it's February).
				{
					if (MonthLogCalc % 100 == 12)	// It's December today.
					{
						MonthLogCalc_next = MonthLogCalc + 89;	// January of the next year.
					}
					else
					{
						MonthLogCalc_next = MonthLogCalc + 1;	// Advance one month in same year.
					}

					if (v_MonthLog != MonthLogCalc_next)
					{
						v_ErrorCode = ERR_PRESCR_PROBL_DIARY_MONTH;   // Date of sale problem.
					}
				}

				else
				{
					v_ErrorCode = ERR_PRESCR_PROBL_DIARY_MONTH;   // Date of sale problem.
				}
			}	// v_MonthLog != MonthLogCalc


			// Get Member data.
			// If Member ID is zero and there is anything in this sale that is being sold with a prescription,
			// we've got a problem!
			if ((v_MemberID == 0) && (MaxPrescSource != RECIP_SRC_NO_PRESC))
			{
				v_ErrorCode = ERR_MEMBER_ID_CODE_WRONG;
				break;
			}

			// DonR 05Sep2006: Don't bother checking for non-Maccabi OTC purchases.
			if (v_MemberID > 0)
			{
				ExecSQL (	MAIN_DB, READ_members_MaxDrugDate_and_SpecPresc,
							&sq_maxdrugdate,	&v_MemberSpecPresc,
							&v_MemberID,		&v_IDCode,
							END_OF_ARG_LIST										);

				Conflict_Test (reStart);

				if ( SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					v_ErrorCode = ERR_MEMBER_ID_CODE_WRONG;
					break;
				}

				if (SQLERR_error_test ())
				{
					v_ErrorCode = ERR_DATABASE_ERROR;
					break;
				}
			}
			else
			{
				// Set values for non-Maccabi OTC purchase.
				sq_maxdrugdate = v_MemberSpecPresc = 0;
			}


			// User prescription global data.
			ExecSQL (	MAIN_DB, READ_prescriptions_for_sale_completion,
						&sq_pharmnum,				&sq_institutecode,
						&sq_identificationcode,		&sq_MemberID,
						&sq_memberbelongcode,		&sq_doctoridentification,
						&sq_DocIDType,				&sq_recipesource,
						&sq_errorcode,				&sq_numofdruglinesrecs,

						&sq_terminalnum,			&sq_pricelistnum,
						&sq_member_discount,		&sq_DateDB,
						&sq_MonthLogDB,				&sq_ActionType,
						&sq_DeletedPrID,			&sq_tikra_discount,
						&sq_subsidy_amount,			&online_order_num,
						&tr6003_date,				&tr6003_time,

						&v_RecipeIdentifier,		END_OF_ARG_LIST				);

			Conflict_Test (reStart);

			if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
			{
				v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_FOUND;
				break;
			}

			if (SQLERR_error_test ())
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			} 

			// DonR 24Jul2013: Remember the previous error code, so we don't overwrite it.
			prev_pr_errorcode = sq_errorcode;

			// DonR 26Dec2022: If the "maximum delay after sale request" feature is enabled, compare the current
			// time to the time when Transaction 6003 took place. If more than the configured number of minutes
			// have passed, log a message. (Eventually, the goal will be to exit this routine and force the
			// program to execute the request as a spooled sale completion - which works better for "stale"
			// requests.)
			if (SaleCompletionMaxDelay > 0)
			{
				earliest_tr6003_date = SysDate;
				earliest_tr6003_time = IncrementTime (SysTime, (SaleCompletionMaxDelay * -60), &earliest_tr6003_date);

				if (( tr6003_date <  earliest_tr6003_date)	||
					((tr6003_date == earliest_tr6003_date) && (tr6003_time < earliest_tr6003_time)))
				{
					// For now, just log a diagnostic message.
					GerrLogMini (GerrId, "PrID %d: Completion request more than %d minutes after %d @ %d.",
								 v_RecipeIdentifier, SaleCompletionMaxDelay, tr6003_date, tr6003_time);


				}	// This is a "stale" sale-completion request.
			}	// Maximum delay for sale completion has been configured > 0.


			// DonR 15Mar2011: If this is a deletion of a drug sale that arrived via spool, the pharmacy doesn't (yet)
			// know the Prescription ID of the original sale, and so v_DeletedPrID will be zero. However, in Trn. 6003
			// for the deletion, we will have already searched the database and found the original sale; so we can
			// replace the zero sent by the pharmacy with the Prescription ID we've already stored in the table.
			if ((v_ActionType == SALE_DELETION) && (v_DeletedPrID == 0))
			{
				v_DeletedPrID = sq_DeletedPrID;
// GerrLogMini (GerrId, "6005 normal deletion: Pharmacy didn't supply deleted Pr ID, so using %d pulled from database.", sq_DeletedPrID);
			}


			// Logical data tests.
			if (sq_errorcode != NO_ERROR)
			{
				Sever = GET_ERROR_SEVERITY (sq_errorcode);

				if (Sever >= FATAL_ERROR_LIMIT)
				{
					GerrLogMini (GerrId, "6005: Err %d in prescriptions for PrID %d - rejecting!",
								 sq_errorcode, v_RecipeIdentifier);
					v_ErrorCode = ERR_PRESCRIPTIONID_NOT_APPROVED;
					break;
				}
			}


			// DonR 11Aug2016: Additional checks on Total Tikra Discount and
			// Total Subsidy Discount. (Note that the actual rejection logic is below,
			// in the "ElyCount" section - this is just a diagnostic!)
//			if (v_TotalTikraDisc	!= sq_tikra_discount)
//			{
//				GerrLogMini (GerrId,
//							 "6005: %d: Tikra disc %d, pharm %d sent %d%s.",
//							 v_RecipeIdentifier, sq_tikra_discount, v_PharmNum, v_TotalTikraDisc, (TestSaleEquality) ? "" : " (test disabled)");
//			}
//
//			if (v_TotalCouponDisc	!= sq_subsidy_amount)
//			{
//				GerrLogMini (GerrId,
//							 "6005: %d: Subsidy %d, pharm %d sent %d%s.",
//							 v_RecipeIdentifier, sq_subsidy_amount, v_PharmNum, v_TotalCouponDisc, (TestSaleEquality) ? "" : " (test disabled)");
//			}


			// DonR 20Apr2023 User Story #432608: Pharmacy now reports Online Order Number in
			// Transaction 6005. In the online version of the transaction, we won't actually
			// need to do anything with it - but as long as we have it, we might as well compare
			// it to what's already in the prescriptions table and print a diagnostic if it's
			// different. (I don't think it's worth reporting an error to the pharmacy.)
			// DonR 18May2023 User Story #432608 fix: Don't do this check if the pharmacy is
			// using a version of Transaction 6005 that doesn't send us OnlineOrderNum_6005.
			// DonR 25Dec2023: Disable this message, since it's just cluttering up the log for
			// no good reason.
			if ((VersionNumber > 3) && (OnlineOrderNum_6005 != online_order_num))
			{
//				GerrLogMini (GerrId, "PrID %d: Trn. 6003 gave Online Order #%ld, but pharmacy reported Order #%ld in Trn. 6005.",
//							 v_RecipeIdentifier, online_order_num, OnlineOrderNum_6005);
			}

			// DonR 19Jun2018 Online Order processing (SuperPharm).
			// Note that if this is a sale deletion, we are *not* doing anything with online orders.
			// This may change, if SuperPharm wants to be able to delete a sale and re-sell against
			// the online order.
			if ((v_ActionType == DRUG_SALE) && (online_order_num > 0))
			{
				// If the pharmacy is not allowed to sell against online orders, set an error. In
				// this case, there's no point in reading the order itself.
				if (Phrm_info.order_fulfiller == 0)
				{
					v_ErrorCode = PHARM_NOT_ORDER_FULFILLER;
					break;
				}

				// Try to read the Online Order based on the number the pharmacy sent.
				ExecSQL (	MAIN_DB, TR6005_READ_check_online_order_validity,
							&OO_made_pr_id,
							&online_order_num,	&Phrm_info.web_pharmacy_code,
							&Phrm_info.owner,	END_OF_ARG_LIST					);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					v_ErrorCode = ONLINE_ORDER_NOT_FOUND;
					break;
				}

				if (SQLERR_error_test ())
				{
					v_ErrorCode = ERR_DATABASE_ERROR;
					break;
				}

				// If we get this far, the pharmacy is an authorized order-filler and the online
				// order exits. Now make sure the order is for the correct member and hasn't
				// already been sold.
				if (OO_made_pr_id == v_RecipeIdentifier)
				{
					v_ErrorCode = ORDER_REQ_NOT_VALID_FOR_COMPLETION;
					break;
				}
			}	// This is a sale completion for an online order.


			// DonR 08Jun2022: If this is a sale deletion and the pharmacy has sent a positive shovar-discount
			// amount instead of the correct negative amount, "flip" it and log it, but don't treat it as an
			// actual error.
			if ((v_ActionType		== SALE_DELETION)				&&		// Sale deletion.
				(TestSaleEquality)									&&		// We're testing for equality of pharmacy-supplied values.
				(v_TotalCouponDisc	>  0)							&&		// Pharmacy sent a positive shovar-discount value.
				(v_TotalCouponDisc	== (0 - sq_subsidy_amount)))			// The pharmacy value is exactly the reverse of the DB value.
			{
				GerrLogMini (GerrId, "6005: Shovar for %d: Flipping pharmacy value of %d to %d.",
							 v_RecipeIdentifier, v_TotalCouponDisc, sq_subsidy_amount);

				v_TotalCouponDisc = sq_subsidy_amount;
			}


			ElyCount = 0;

			// Insert the following line after each line in if()
			// in order to catch the first true among all conditions :
			//    || ! ++ElyCount	
			//
			// DonR 09May2024 User Story #309732: If this is a "mark as paid" request, force
			// some comparisons to give an "equal" result since they're not really relevant.
			// (The other fields should still be compared.)
			if (v_ActionType == MARK_AS_PAID)
			{
				sq_numofdruglinesrecs	= 0;
				sq_ActionType			= MARK_AS_PAID;
				sq_tikra_discount		= v_TotalTikraDisc;
				sq_subsidy_amount		= v_TotalCouponDisc;
			}

			if ((sq_pharmnum				!= v_PharmNum			)							|| ! ++ElyCount ||	//  0 = Pharmacy Number
				(sq_institutecode			!= v_InstituteCode		)							|| ! ++ElyCount ||	//  1 = Institute Code
				(sq_MemberID				!= v_MemberID			)							|| ! ++ElyCount ||	//  2 = Member ID
				(sq_identificationcode		!= v_IDCode				)							|| ! ++ElyCount ||	//  3 = Member ID Code
				(sq_memberbelongcode		!= v_MemberBelongCode	)							|| ! ++ElyCount ||	//  4 = Member Institute Code
				(sq_numofdruglinesrecs		<  v_NumOfDrugLinesRecs	)							|| ! ++ElyCount ||	//  5 = Number of Drug Lines
				(sq_ActionType				!= v_ActionType			)							|| ! ++ElyCount ||	//  6 = Action Type
				((sq_tikra_discount			!= v_TotalTikraDisc		) && (TestSaleEquality))	|| ! ++ElyCount ||	//  7 = Tikra Discount Amount
				((sq_subsidy_amount			!= v_TotalCouponDisc	) && (TestSaleEquality))	|| ! ++ElyCount ||	//  8 = Coupon Discount Amount
				(sq_terminalnum				!= v_TerminalNum		)							|| ! ++ElyCount		//  9 = Terminal ID
			   )
			{
				v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_EQUAL;

				switch (ElyCount)
				{
					case 0:	GerrLogMini (GerrId, "6005: Pharmacy Code for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_PharmNum, sq_pharmnum);
							break;

					case 1:	GerrLogMini (GerrId, "6005: Institute Code for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_InstituteCode, sq_institutecode);
							break;

					case 2:	GerrLogMini (GerrId, "6005: Member ID for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_MemberID, sq_MemberID);
							break;

					case 3:	GerrLogMini (GerrId, "6005: Member ID Code for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_IDCode, sq_identificationcode);
							break;

					case 4:	GerrLogMini (GerrId, "6005: Member Institute Code for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_MemberBelongCode, sq_memberbelongcode);
							break;

					case 5:	GerrLogMini (GerrId, "6005: Drug Lines for %d: Pharm %d sent %d, DB has %d.",
										 v_RecipeIdentifier, v_PharmNum, v_NumOfDrugLinesRecs, sq_numofdruglinesrecs);
							break;

					case 6:	GerrLogMini (GerrId, "6005: Action Type for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_ActionType, sq_ActionType);
							break;

					case 7:	GerrLogMini (GerrId, "6005: Tikra for %d: Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_TotalTikraDisc, sq_tikra_discount);
							break;

					case 8:	GerrLogMini (GerrId, "6005: Shovar for %d: Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_TotalCouponDisc, sq_subsidy_amount);
							break;

					case 9:	GerrLogMini (GerrId, "6005: Terminal ID for %d not equal - Pharm sent %d, DB has %d.",
										 v_RecipeIdentifier, v_TerminalNum, sq_terminalnum);
							break;

					default:GerrLogMini (GerrId, "Prescription data for %d not equal - ElyCount = %d.",
										 v_RecipeIdentifier, ElyCount);
							break;
				}

				break;
			}

			// Pharmacy shouldn't change the sale date between Transactions 6003 and 6005.
			if (sq_DateDB != SaleDate)
			{
				v_ErrorCode = ERR_PRESCRIPTION_PROBL_DATE;   // Date of sale problem.
				break;
			}

			// DonR 04 Mar 2003: Skip this test if the pharmacy hasn't given us a
			// Pharmacy Prescription Number.
			// DonR 23Jul2006: Don't do this test if the sale is coming from a
			// private pharmacy and the Member ID is zero.
			// DonR 09May2024 User Story #309732: If this is a "mark as paid" request,
			// don't test for already-delivered status; in this case we *expect* the
			// prescriptions/prescription_drugs rows to be marked as delivered.
			if ((v_RecipeIdentifier	>  0)					&&
				(v_PharmRecipeNum	>  0)					&&
				(v_ActionType		!= MARK_AS_PAID)		&&		// DonR 09May2024 User Story #309732.
				((MACCABI_PHARMACY) || (MaxPrescSource != RECIP_SRC_NO_PRESC)))
			{
				// Check for duplicate Pharmacy Prescription Number.
				// DonR 29Jul2007: Re-ordered selects to follow index structure; also added
				// a "dummy" select by member_price_code, just to make sure that Informix
				// uses the best applicable index.
				//
				// DonR 01Dec2009: This check doesn't need to be in committed mode, so we can set isolation
				// to "dirty" to avoid locked-record errors.
				//
				// DonR 29Jun2010: Got rid of dummy member_price_code select; I'll change the relevant index
				// to eliminate this irrelevant field as well. Also got rid of the select by date, which
				// hasn't been relevant for years.
				//
				// DonR 08Feb2011: Change test on delivered_flg, since we're no longer using only 1 and 0 there.
				SET_ISOLATION_DIRTY;

				ExecSQL (	MAIN_DB, READ_count_duplicate_drug_sales,
							&v_count_double_rec,
							&v_PharmNum,			&v_MonthLog,			&v_PharmRecipeNum,
							&v_MemberBelongCode,	&DRUG_NOT_DELIVERED,	END_OF_ARG_LIST		);

				Conflict_Test (reStart);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_FOUND;
					break;
				}

				if (SQLERR_error_test ())
				{
					v_ErrorCode = ERR_DATABASE_ERROR;
					break;
				} 

				if (v_count_double_rec > 0)
				{
					v_ErrorCode = ERR_PRESCRIPTION_DOUBLE_NUM;   // Duplicate Pharmacy Prescription ID.
					break;
				}

			}	// RecipeIdentifier > 0 and Pharmacy Prescr. ID > 0

			// Open Prescription Drugs cursor.
			//
			// DonR 09May2024 User Story #309732: Note that we're leaving this bit of code unchanged.
			// If we're in "mark as paid" mode, v_NumOfDrugLinesRecs will be zero so we won't actually
			// do anything here other than read through the prescription_drugs cursor; that's a little
			// bit wasteful, but it keeps the number of logic changes to support the new Action Type
			// down to a minimum.
			//
			// DonR 01Dec2009: Return to committed-read mode.
			SET_ISOLATION_COMMITTED;

			OpenCursor (MAIN_DB, TR6005_prescription_drugs_cur);

			if (SQLERR_error_test ())
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			}

			// Set all drug lines from the pharmacy request to "unmatched".
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				phDrgs[i].Flg = 0;
			}


			// Fetch and test prescription_drugs rows against drug lines sent by pharmacy.
			// Loop until we break out.
			do
			{
				FetchCursor (MAIN_DB, TR6005_prescription_drugs_cur);

				Conflict_Test (reStart);

				if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
				{
					break;
				}

				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}


				// Find drug in buffer and test it against database values.
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					if ((phDrgs[i].DrugCode	!= dbDrgs.DrugCode)	||
						(phDrgs[i].DocID	!= dbDrgs.DocID)	||
						(phDrgs[i].Flg		!= 0))
					{
						continue;
					}

					phDrgs[i].LineNo			= dbDrgs.LineNo;
// if (v_ActionType == SALE_DELETION) GerrLogMini (GerrId, "6005: phDrgs[i].ParticipMethod = %d, dbDrgs.ParticipMethod = %d.", phDrgs[i].ParticipMethod, dbDrgs.ParticipMethod);
					phDrgs[i].ParticipMethod	= dbDrgs.ParticipMethod;
					phDrgs[i].MacabiPriceFlag	= dbDrgs.MacabiPriceFlag;
					phDrgs[i].StopBloodDate		= dbDrgs.StopBloodDate;
					phDrgs[i].PrescWrittenID	= dbDrgs.PrescWrittenID;
					phDrgs[i].ph_otc_unit_price	= dbDrgs.ph_otc_unit_price;
					phDrgs[i].Flg				= 1;

					// DonR 14Jan2025: SuperPharm has a bug - they send 1 for Prescription Source in
					// Transaction 6005 for all prescription sources instead of the actual value. To
					// avoid unnecessary database work, correct this - and log it in Test/QA (but not
					// in Production). Note that I'm not bothering to fix this in 6005-spool, since
					// (A) it's a harmless bug and there aren't all that many cases where a spooled
					// 6005 completes a sale that was already in the database; and (B) SuperPharm is
					// supposed to fix their bug in any case.
					if (phDrgs[i].PrescSource != dbDrgs.PrescSource)
					{
						if (!TikrotProductionMode)
							GerrLogMini (	GerrId,
											"6005: Pharmacy %d sent Prescription Source %d for %d/%d - "
											"substituting correct value of %d.",
											v_PharmNum, phDrgs[i].PrescSource, v_RecipeIdentifier,
											phDrgs[i].DrugCode, dbDrgs.PrescSource							);

						phDrgs[i].PrescSource = dbDrgs.PrescSource;
					}

					// DonR 09Feb2009: Per Iris Shaya, certain pharmacies (SuperPharm
					// in Sderot and Tamarim in Eilat) can change the Supplier Drug Price
					// for certain items; in this case, we want to update the drug-sale
					// row with the new Supplier Drug Price. Since other "Maccabi"
					// pharmacies won't change the price, doing the update won't
					// change anything. But if the conditions aren't met, we want
					// to make sure the existing database value is preserved.
					if ((dbDrgs.DrugCode < 90000) || (PRIVATE_PHARMACY))
					{
						phDrgs[i].SupplierDrugPrice = dbDrgs.SupplierDrugPrice;
					}


					// Test for same Link to Addition.
					// DonR 22Jan2019: If pharmacy didn't supply the Gadget Code but we found a (unique) row
					// in the Gadgets table in Trn. 6003, simply use that instead of what the pharmacy sent.
					if (((phDrgs[i].ParticipMethod % 10)	== FROM_GADGET_APP	)	&&
						( phDrgs[i].LinkToAddition			== 0				)	&&	
						( dbDrgs.LinkToAddition				>  0				))
					{
						phDrgs[i].LinkToAddition = dbDrgs.LinkToAddition;
					}
					else
					{
						if (phDrgs[i].LinkToAddition != dbDrgs.LinkToAddition)
						{
							v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_EQUAL;
							GerrLogMini (GerrId,
										 "%d link-to-addition mismatch: 6003: %d, 6005: %d.",
										 v_RecipeIdentifier, phDrgs[i].LinkToAddition, dbDrgs.LinkToAddition);
							break;
						}
					}


					// DonR 11Aug2016: Pharmacy must send the same Member Participation Amount as they got
					// from Transaction 6003 - if not, reject the transaction. Note that if this a deletion,
					// we have to compare a "flipped" version of the participation amount, since the pharmacy
					// sends it as a positive number and the database already has it as a negative number.
					if ((phDrgs[i].PrescSource != RECIP_SRC_NO_PRESC) && (TestSaleEquality))
					{
						ComparePharmPtn = (v_ActionType == SALE_DELETION) ? (0 - phDrgs[i].TotalPtn) : phDrgs[i].TotalPtn;

						if (((PRIVATE_PHARMACY) || (phDrgs[i].DrugDiscountCode == 0)) && (ComparePharmPtn != dbDrgs.member_ptn_amt))
						{
							v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_EQUAL;
							GerrLogMini (GerrId,
										 "6005: %d/%d: Ptn = %d, pharm %d sent %d.",
										 v_RecipeIdentifier, phDrgs[i].LineNo, dbDrgs.member_ptn_amt, v_PharmNum, ComparePharmPtn);
						}
					}

					// DonR 09Oct2018 CR #15092: If this is a drug sale and we gave "hishtatfut" from the Meishar application,
					// pharmacy is not allowed to change the Participation Source or Amount.
					// DonR 17Dec2020: Created separate log messages for Participation Method and Member Participation;
					// in general, the discrepancies always seem to be in the latter, and this will create tidier log
					// messages.
					if ((v_ActionType == DRUG_SALE) && ((dbDrgs.ParticipMethod % 10) == FROM_GADGET_APP))
					{
						if ((phDrgs[i].ParticipMethod	!= dbDrgs.ParticipMethod)	||
							(phDrgs[i].TotalPtn			!= dbDrgs.member_ptn_amt))
						{
							v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_EQUAL;

							if (phDrgs[i].TotalPtn != dbDrgs.member_ptn_amt)
							{
								GerrLogMini (GerrId,
											 "6005: %d/%d: Ptn = %d, pharm %d sent %d.",
											 v_RecipeIdentifier, phDrgs[i].LineNo, dbDrgs.member_ptn_amt, v_PharmNum, phDrgs[i].TotalPtn);
							}

							if (phDrgs[i].ParticipMethod != dbDrgs.ParticipMethod)
							{
								GerrLogMini (GerrId,
											 "6005: %d/%d: Ptn method = %d, pharm %d sent %d.",
											 v_RecipeIdentifier, phDrgs[i].LineNo, dbDrgs.ParticipMethod, v_PharmNum, phDrgs[i].ParticipMethod);
							}
						}
					}


					// See if any errors discovered previously are severe enough to invalidate the drug.
					if (sq_errorcode != NO_ERROR)
					{
						Sever = GET_ERROR_SEVERITY (sq_errorcode);

						if (Sever > FATAL_ERROR_LIMIT)
						{
							GerrLogMini (GerrId, "Trn 6005 found error %d for PrID %d Line #%d (Largo %d) - aborting!",
										 sq_errorcode, v_RecipeIdentifier, phDrgs[i].LineNo, phDrgs[i].DrugCode);
							v_ErrorCode = ERR_PRESCRIPTIONID_NOT_APPROVED;
							break;
						}
					}


					// Update max drug date for member
					len   = AddDays (sq_stopusedate, sq_thalf);

					if (max_drug_date < len)
					{
						max_drug_date = len;
					}

					break;

				}	// Loop through drugs to match lines in 6005 against the current prescription_drugs row.

				// See if any errors discovered so far are severe enough to invalidate the drug.
				if (v_ErrorCode != NO_ERROR)
				{
					Sever = GET_ERROR_SEVERITY (v_ErrorCode);

					if (Sever > FATAL_ERROR_LIMIT)
					{
						break;
					}
				}

			}
			while (1);	// End of fetch-and-test prescription_drugs rows loop.

			// Close Prescription Drugs cursor.
			CloseCursor (	MAIN_DB, TR6005_prescription_drugs_cur	);


			// DonR 25Jun2020 CR #32984 Part 3: If this is a drug sale and any of the prescriptions
			// being sold now have already been fully sold, return an error and reject the
			// current sale completion. This should happen only when a pharmacy is doing
			// something fraudulent.
			if (v_ActionType == DRUG_SALE)
			{
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// Loop through individual doctor prescriptions to check for
					// fully-sold prescriptions.
					if ((phDrgs[i].PrescSource == RECIP_SRC_MACABI_DOCTOR) && (phDrgs[i].NumDocRxes > 0))
					{
						for (Rx = phDrgs[i].FirstRx; Rx < (phDrgs[i].FirstRx + phDrgs[i].NumDocRxes); Rx++)
						{
							// Don't check unless this is a Maccabi doctor prescription with a non-zero prescription ID.
							if ((phDrgs[i].DocID == 0) || (DocRx[Rx].PrID == 0))
								continue;

							ExecSQL	(	MAIN_DB, CheckForFullySoldDocRx,
										&RowsFound,
										&v_MemberID,					&DocRx[Rx].PrID,	&DocRx[Rx].FromDate,
										&phDrgs[i].Orig_Largo_Code,		&phDrgs[i].DocID,	&v_IDCode,
										END_OF_ARG_LIST																);

							if ((SQLCODE == 0) && (RowsFound > 0))
							{
								v_ErrorCode = prev_pr_errorcode = TR6005_RX_ALREADY_FULLY_SOLD;

								// Update PRESCRIPTIONS table. No error handling, as this is going to be a non-delivered
								// prescription and this update is normally informational only. OTOH it does prevent
								// a future spooled 6005 from completing a sale that shouldn't be completed.
								ExecSQL (	MAIN_DB, UPD_prescriptions_set_error_code,
											&v_ErrorCode,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);

								// Since Trn. 6005 does not normally update prescriptions/error_code, we were losing
								// the new value; the solution, inelegant as it may be, is to force a COMMIT here.
								CommitAllWork ();

								break;
							}
						}	// Loop through prescriptions for a drug line.
					}	// This drug line involves Maccabi doctor prescriptions.

					// No point in continuing to loop if we've already found a fully-sold prescription.
					if (v_ErrorCode == TR6005_RX_ALREADY_FULLY_SOLD)
					{
						break;
					}

				}	// Loop through drug lines looking for already-fully-sold prescriptions.
			}	// This is a drug sale - CR #32984 Part 3 end.


			// DonR 08Aug2016: If we discovered a fatal error in on of our inner loops,
			// we want to break out of the outer loop as well.
			// See if any errors discovered so far are severe enough to invalidate the sale.
			if (v_ErrorCode != NO_ERROR)
			{
				Sever = GET_ERROR_SEVERITY (v_ErrorCode);

				if (Sever > FATAL_ERROR_LIMIT)
				{
//					GerrLogMini (GerrId, "6005: Error %d severity = %d - breaking out of retries loop.", v_ErrorCode, Sever);
					break;
				}
			}


			// DonR 01Apr2015: If this is a deletion and pharmacy didn't send information about the
			// affected doctor prescriptions, load the data from the sale being deleted. (Note that
			// for any given drug line being deleted, the entire amount sold will be deleted - so
			// we don't have to worry about partial deletions.) We will check for missing doctor-
			// prescription data on a line-by-line basis.
			if (v_ActionType == SALE_DELETION)
			{
				SET_ISOLATION_DIRTY;
				
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					phDrgPtr	= &phDrgs[i];
					v_DrugCode	= phDrgPtr->DrugCode;
					v_DoctorID	= phDrgPtr->DocID;

					if (phDrgPtr->NumDocRxes == 0)
					{
						// DonR 24Mar2020: Moved the DECLARE here, since it seems we were getting errors on the OPEN.
						DeclareAndOpenCursorInto (	MAIN_DB, TR6005_doc_prescription_link_cur,
													&DbRx.PrID,			&DbRx.FromDate,		&DbRx.VisitNumber,
													&DbRx.OP,			&DbRx.Units,		&v_DeletedRxLargo,

													&v_DeletedPrID,		&v_DrugCode,		&v_DoctorID,
													&v_DeletedPrID,		END_OF_ARG_LIST								);

						if (SQLERR_error_test ())
						{
							v_ErrorCode = ERR_DATABASE_ERROR;
							break;
						}

						do
						{
							FetchCursor (MAIN_DB, TR6005_doc_prescription_link_cur);

							Conflict_Test (reStart);

							if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
							{
								break;
							}

							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}

							// If we get here, we actually read a doctor prescription. If this is the first one
							// for this drug line, record it.
							DocRx [MaxRx] = DbRx;
							if (phDrgPtr->NumDocRxes == 0)
							{
								phDrgPtr->FirstRx			= MaxRx;
								phDrgPtr->Orig_Largo_Code	= v_DeletedRxLargo;
							}

							// If we get here, we've succeeded in reading a relevant pd_rx_link row.
							phDrgPtr->NumDocRxes++;
							MaxRx++;
							AuditNumRxRead++;
						}
						while (1);	// End of fetch doctor-prescription rows loop.

						CloseCursor (MAIN_DB, TR6005_doc_prescription_link_cur);
					}	// No doctor-prescription data found for this drug line.
				}	// Loop through drugs in deletion request.
			}	// This is a deletion, so we need to check whether we're "missing" doctor-prescription info.


			// Test if any drugs in 6005 were not found in prescription_drugs table -
			// pharmacist is allowed to add drugs between 2001 and 6003, but
			// not between 6003 and 6005.
			//
			// While we're at it, check that drug is in the drug_list table,
			// load in its Largo Type and packaging details, and see if the
			// drug is also in the Gadgets table.

			// DonR 21Apr2005: Avoid unnecessary "table locked" errors.
			SET_ISOLATION_DIRTY;

			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				phDrgs[i].in_gadget_table = 0;

				if (phDrgs[i].Flg == 0)		// I.E. drug wasn't in DB select list.
				{
					v_ErrorCode = ERR_PRESCRIPTION_ID_NOT_EQUAL;
					GerrLogMini (GerrId, "6005: %d/%d (Largo %d) isn't in prescription_drugs.",
								 v_RecipeIdentifier, i + 1, phDrgs[i].DrugCode);
					break;
				}


				// Read drug_list data by largo code.
				// DonR 14Apr2016: Switch to using the read_drug() routine, since that includes more sophisticated
				// data-massaging logic.
				// DonR 08Apr2018: Added new "see deleted drugs" parameter to read_drug(). If we're performing a
				// sale deletion, logically-deleted drugs should be visible, so the parameter will be TRUE.
				// DonR 02Aug2023 User Story #469361: To simplify some code, copy the whole DL structure to the
				// phDrgs array. Eventually values from phDrgs[x].DL should replace individual variables.
				if (read_drug (phDrgs[i].DrugCode,
							   99999999,
							   &Phrm_info,
							   (v_ActionType == SALE_DELETION),	// Deleted drugs are "visible" if we're deleting prior sales.
							   &DL,
							   NULL))
				{
					phDrgs[i].DL				= DL;			// DonR 02Aug2023.
					phDrgs[i].LargoType			= DL.largo_type;
					phDrgs[i].package_size		= DL.package_size;
					phDrgs[i].openable_package	= DL.openable_pkg;
					v_in_gadget_table			= DL.in_gadget_table;
					v_ingr_1_code				= DL.Ingredient[0].code;
					v_ingr_2_code				= DL.Ingredient[1].code;
					v_ingr_3_code				= DL.Ingredient[2].code;
					v_ingr_1_quant				= DL.Ingredient[0].quantity;
					v_ingr_2_quant				= DL.Ingredient[1].quantity;
					v_ingr_3_quant				= DL.Ingredient[2].quantity;
					v_ingr_1_quant_std			= DL.Ingredient[0].quantity_std;
					v_ingr_2_quant_std			= DL.Ingredient[1].quantity_std;
					v_ingr_3_quant_std			= DL.Ingredient[2].quantity_std;
					v_per_1_quant				= DL.Ingredient[0].per_quant;
					v_per_2_quant				= DL.Ingredient[1].per_quant;
					v_per_3_quant				= DL.Ingredient[2].per_quant;
					v_package_volume			= DL.package_volume;
				}
				else
				{
					GerrLogMini (GerrId, "6005: read_drug() for %d returned zero; SQLCODE = %d.", SQLCODE);

					Conflict_Test (reStart);

					if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
					{
						v_ErrorCode = ERR_DRUG_CODE_NOT_FOUND;
						break;
					}

					if (SQLERR_error_test ())
					{
						v_ErrorCode = ERR_DATABASE_ERROR;
						break;
					}
				}

				// Save the drug's "in gadget table" status.
				phDrgs[i].in_gadget_table = v_in_gadget_table;

				// Save generic-ingredient fields as well.
				phDrgs[i].package_volume	    = v_package_volume;
				phDrgs[i].ingr_code			[0] = v_ingr_1_code;
				phDrgs[i].ingr_code			[1] = v_ingr_2_code;
				phDrgs[i].ingr_code			[2] = v_ingr_3_code;
				phDrgs[i].ingr_quant		[0] = v_ingr_1_quant;
				phDrgs[i].ingr_quant		[1] = v_ingr_2_quant;
				phDrgs[i].ingr_quant		[2] = v_ingr_3_quant;
				phDrgs[i].ingr_quant_std	[0] = v_ingr_1_quant_std;
				phDrgs[i].ingr_quant_std	[1] = v_ingr_2_quant_std;
				phDrgs[i].ingr_quant_std	[2] = v_ingr_3_quant_std;
				phDrgs[i].per_quant			[0] = v_per_1_quant;
				phDrgs[i].per_quant			[1] = v_per_2_quant;
				phDrgs[i].per_quant			[2] = v_per_3_quant;


				// DonR 12Mar2024 User Story #540234: If this is a deletion of a cannabis sale
				// and the pharmacy has not supplied Cannabis Product Detail information, read
				// the required data from the pd_cannabis_products table based on the sale
				// being deleted. Although it would be slightly more efficient to do the whole
				// thing in one go, we'll open the cursor separately for each drug line; this
				// will make the logic very slightly simpler, and will be more flexible just in
				// case a pharmacy sends the information for some drug lines and not for others.
				// (This is why we use whatever value TotalNumCannabisProducts already has - we
				// expect it to be zero, but theoretically it could have a positive value from
				// what the pharmacy sent.)
				if ((v_ActionType					== SALE_DELETION)	&&
					(phDrgs[i].DL.drug_type			== 'K')				&&
					(phDrgs[i].NumCannabisProducts	<  1))
				{
					DeclareAndOpenCursor (	MAIN_DB, TR6005_READ_cannabis_product_details,
											&v_DeletedPrID,		&phDrgs[i].DrugCode,		END_OF_ARG_LIST	);

					if (SQLCODE == 0)
					{
						while (1)
						{
							FetchCursorInto (	MAIN_DB, TR6005_READ_cannabis_product_details,
												&CannabisProduct [TotalNumCannabisProducts].cannabis_product_code,
												&CannabisProduct [TotalNumCannabisProducts].cannabis_product_barcode,
												&CannabisProduct [TotalNumCannabisProducts].op,
												&CannabisProduct [TotalNumCannabisProducts].units,
												&CannabisProduct [TotalNumCannabisProducts].price_per_op,
												&CannabisProduct [TotalNumCannabisProducts].product_sale_amount,
												&CannabisProduct [TotalNumCannabisProducts].product_ptn_amount,
												END_OF_ARG_LIST															);

							if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
							{
								break;
							}
							else
							{
								Conflict_Test (reStart);

								if (SQLCODE == 0)
								{
									CannabisProduct [TotalNumCannabisProducts].DrugLineSubscript = i;
									phDrgs[i].NumCannabisProducts++;
									TotalNumCannabisProducts++;
								}
								else
								{
									SQLERR_error_test ();
									break;
								}
							}
						}	// Read through Cannabis Product Details rows for this prescription_id/drug code.
					}	// Successful open of pd_cannabis_products cursor.
					else
					{
						Conflict_Test (reStart);
						SQLERR_error_test ();
					}

					CloseCursor (	MAIN_DB, TR6005_READ_cannabis_product_details	);
				}	// DonR 12Mar2024 User Story #540234 end (read Cannabis Product Details from the original sale).

			}	// Loop on drugs to get largo type, package size, and openability.


			// DonR 21Apr2005: Restore "normal" database isolation.
			SET_ISOLATION_COMMITTED;


			// If we broke out of the above loop prematurely, something went wrong!
			if (i < v_NumOfDrugLinesRecs)
			{
//				GerrLogMini (GerrId, "6005: Drug_list loop exited after %d/%d lines.", i, v_NumOfDrugLinesRecs);
				break;
			}

			// End of dummy loop to prevent goto.
		}
		while (0);	// Loop should run only once.

		// DonR 01Dec2009: Just to be on the safe side, restore normal database isolation.
		// This should be necessary only if we hit a DB error while we were in "dirty read"
		// mode.
		SET_ISOLATION_COMMITTED;

		// Update tables.
		//
		// And now...
		// Yet another dummy loop to avoid goto!
		// Reply is sent to pharmacy when we exit from loop.

		// DonR 04Aug2010: If there is an error, write it to the prescriptions table so we know
		// why the sale wasn't completed.
		if (!SetErrorVar (&v_ErrorCode, v_ErrorCode))	// No problem so far
		{
			do
			{
				// Update PHARMACY_DAILY_SUM table.
				// DonR 05Aug2009: Don't add private-pharmacy non-prescription sales to pharmacy_daily_sum.
				// DonR 05Jul2010: Note that for sale deletions, the pharmacy will report positive numbers
				// for OP/Units and Total Member Participation; we carry these numbers internally (in
				// prescriptions/prescription_drugs) as negative numbers.
				// DonR 23Aug2010: Per Iris Shaya, Total Tikra Discount and Total Coupon Discount need to be
				// subtracted from the participation amount for this sale.
				// DonR 11Jan2011: For sale deletions, AS/400 will report Tikra and Coupon reductions in
				// participation as negative numbers. This means that in calculating the member participation
				// written to pharmacy_daily_sum, these numbers need to be added, not subtracted. Accordingly,
				// this bit of math will be split into two versions and moved to the "if" based on the current
				// Action Type.
				//
				// Calculate prescription total
				sq_TotalMemberPrice	= 0;
				sq_TotalDrugPrice	= 0;
				sq_TotSuppPrice		= 0;

				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// Test the relevancy of information drug-by-drug.
					if ((MACCABI_PHARMACY) || (phDrgs[i].PrescSource != RECIP_SRC_NO_PRESC))
					{
						sq_TotalMemberPrice	+= phDrgs[i].TotalPtn;
						sq_TotalDrugPrice	+= phDrgs[i].TotalDrugPrice;

						sq_TotSuppPrice		+= phDrgs[i].SupplierDrugPrice * phDrgs[i].Op;

						// DonR 01Mar2023: Note that casting the result of the floating-point
						// calulation of the value of partial packages sold as an integer will
						// truncate the result rather than rounding it. This is OK, but we
						// have to remember to be consistent - anything that performs this
						// calculation for Total Supplier Price needs to do it the same way!
						if (phDrgs[i].Units != 0)
						{
							sq_TotSuppPrice	+= (int)(  (float)phDrgs[i].SupplierDrugPrice
														* (float)phDrgs[i].Units
														/ (float)phDrgs[i].package_size);
						}
					}	// This drug line is relevant.
				}	// Loop through all drugs in this sale.

				// DonR 04Jun2015: Since we no longer have a single Prescription Source for the whole sale, we
				// calculate our totals unconditionally - but we do look at each drug's qualifications
				// individually. We want to update pharmacy_daily_sum if we found at least something in the
				// transaction that will impact the pharmacy's totals.
				// DonR 05Feb2023 User Story #232220: Update Pharmacy Daily Sum *only* if this transaction has
				// already been paid for. If the Credit Type Used value is 99, paid_for will be zero and the
				// transaction is still unpaid; in this case it's in a state of "suspended animation", valid
				// for things like interaction/overdose checking but not yet sent to AS/400 and not yet included
				// in the Pharmacy Daily Sum.
				// DonR 09May2024 User Story #309732: Note that if we're in "mark as paid" mode, v_NumOfDrugLinesRecs
				// has been forced to zero and thus the loop above will not have done anything. This will leave the
				// three variables sq_TotalMemberPrice, sq_TotalDrugPrice, and sq_TotSuppPrice set to zero, and that
				// in turn will prevent any updates to pharmacy_daily_sum without having to change any other logic.
				if (paid_for && ((sq_TotalMemberPrice != 0) || (sq_TotalDrugPrice != 0) || (sq_TotSuppPrice != 0)))
				{
					// Set up variables to insert/update Pharmacy Daily Sum data. There are three
					// possibilities:
					// 1) Drug sale.
					// 2) Conventional sale deletion.
					// 3) Deletion for prior month or different pharmacy; this gets recorded as a
					//    "negative sale" to the pharmacy performing the deletion.
					//
					// DonR 31Dec2017: Changed three simple assignments to "0 + x" assignments, just in case the
					// source variable has a funky value. This was done because I saw a sporadic "integrity
					// constraint violation (Informix error -391) on pharmacy_daily_sum.purchase_sum.
					if (v_ActionType == DRUG_SALE)
					{
						sq_TotalMemberPrice	-= (v_TotalTikraDisc + v_TotalCouponDisc);	// DonR 23Aug2010 / 11Jan2011.
						PDS_sum				=  0 + sq_TotalDrugPrice;
						PDS_prt_sum			=  0 + sq_TotalMemberPrice;
						PDS_purch_sum		=  0 + sq_TotSuppPrice;
						PDS_lines			=  v_NumOfDrugLinesRecs;
						PDS_count			=  1;
						PDS_del_sum			=  0;
						PDS_del_prt_sum		=  0;
						PDS_del_purch_sum	=  0;
						PDS_del_lines		=  0;
						PDS_del_count		=  0;
						PDS_date			=  SysDate;
					}
					else
					{	// The only "legal" alternative to DRUG_SALE for Trn. 6005 is SALE_DELETION.

						// DonR 11Jan2011: For deletions, discounts are sent by pharmacy as negative numbers.
						sq_TotalMemberPrice	+= (v_TotalTikraDisc + v_TotalCouponDisc);	// DonR 11Jan2011.

						if ((v_PharmNum == v_DeletedPrPharm) && (v_MonthLog == v_DeletedPrYYMM))
						{
							// Conventional sale deletion.
							PDS_sum				= 0;
							PDS_prt_sum			= 0;
							PDS_purch_sum		= 0;
							PDS_lines			= 0;
							PDS_count			= 0;
							PDS_del_sum			= sq_TotalDrugPrice;	// Should be positive.
							PDS_del_prt_sum		= sq_TotalMemberPrice;	// Should be positive.
							PDS_del_purch_sum	= sq_TotSuppPrice;		// Should be positive.
							PDS_del_lines		= v_NumOfDrugLinesRecs;
							PDS_del_count		= 1;

							// DonR 02Mar2011: For conventional sale deletions, read the original sale date,
							// since that's the date to be used for updating pharmacy_daily_sum.
							ExecSQL (	MAIN_DB, READ_deleted_sale_date,
										&PDS_date, &v_DeletedPrID, END_OF_ARG_LIST	);

							if (SQLCODE != 0)
								PDS_date = SysDate;
						}
						else
						{
							// Deletion for prior month and/or different pharmacy - treat as "negative sale".
							PDS_sum				= 0 - sq_TotalDrugPrice;	// Should be positive, so subtract.
							PDS_prt_sum			= 0 - sq_TotalMemberPrice;	// Should be positive, so subtract.
							PDS_purch_sum		= 0 - sq_TotSuppPrice;		// Should be positive, so subtract.
							PDS_lines			= v_NumOfDrugLinesRecs;
							PDS_count			= 1;
							PDS_del_sum			= 0;
							PDS_del_prt_sum		= 0;
							PDS_del_purch_sum	= 0;
							PDS_del_lines		= 0;
							PDS_del_count		= 0;
							PDS_date			= SysDate;
						}
					}	// This is a sale deletion.

					// DonR 21Mar2011: For better performance, try updating rather than inserting first.
					// The vast majority of the time, we'll be updating an existing row - so why waste
					// time trying to insert, failing, and only then updating?
					// DonR 03May2015: Add a retry loop, since I'm seeing cases where the UPDATE fails but
					// then the INSERT fails too, with SQL duplicate key error.
					// DonR 13Jul2016: Added one more retry, and increased the pause before retry from five
					// to fifty milliseconds; this should, I hope, reduce the number of transactions that
					// fail with a DB error.
					for (i = 0; i < 3; i++)
					{
						if (i > 0)
							usleep (50000);	// Sleep 50 milliseconds before retry - shouldn't really be necessary.

						ExecSQL (	MAIN_DB, UPD_pharmacy_daily_sum,
									&PDS_sum,			&PDS_prt_sum,			&PDS_purch_sum,
									&PDS_count,			&PDS_lines,				&PDS_del_sum,
									&PDS_del_prt_sum,	&PDS_del_lines,			&PDS_del_count,
									&PDS_del_purch_sum,
									&v_PharmNum,		&v_InstituteCode,		&v_MonthLog,
									&PDS_date,			&v_TerminalNum,			END_OF_ARG_LIST		);
//GerrLogMini(GerrId, "pharmacy_daily_sum UPDATE for %d/%d/%d/%d/%d returned %d/%d, %d rows.",
//			v_PharmNum, v_InstituteCode, v_MonthLog, PDS_date, v_TerminalNum, SQLCODE, sqlca.sqlcode, sqlca.sqlerrd[2]);

						// DonR 31Dec2015: If the UPDATE succeeded, we need to break out of the retry loop so we don't 
						// perform the update twice! (In fact, the *only* situation in which we want to stay in the loop
						// is if both the UPDATE and the INSERT failed with "no rows affected" and "duplicate key",
						// respectively.)
						// DonR 05Jan2016 HOT FIX: If the update found nothing to update, SQLCODE will still be equal
						// to zero - so we have to look at "no rows affected" separately.
						if (DB_UPDATE_WORKED)
							break;	// We succeeded in the UPDATE, so abort the retry loop.

						// If there was nothing to update, try inserting a new row.
						if (SQLERR_code_cmp (SQLERR_no_rows_affected) == MAC_TRUE)
						{
							ExecSQL (	MAIN_DB, INS_pharmacy_daily_sum_19_columns,
										&v_PharmNum,		&v_InstituteCode,	&v_MonthLog,
										&PDS_date,			&v_TerminalNum,		&PDS_sum,
										&PDS_count,			&PDS_lines,			&PDS_prt_sum,
										&PDS_purch_sum,		&PDS_del_sum,		&PDS_del_prt_sum,

										&PDS_del_lines,		&PDS_del_count,		&PDS_del_purch_sum,
										&IntZero,			&IntZero,			&IntZero,
										&IntZero,			END_OF_ARG_LIST								);

//GerrLogMini(GerrId, "pharmacy_daily_sum INSERT for %d/%d/%d/%d/%d returned %d/%d.",
//			v_PharmNum, v_InstituteCode, v_MonthLog, PDS_date, v_TerminalNum, SQLCODE, sqlca.sqlcode);
							if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_FALSE)
								break;	// Retry only on duplicate-key error.

						}	// No rows affected on UPDATE, so try INSERT.

						// DonR 31Dec2015: If we get here, either the UPDATE failed with something *other* than "no rows affected",
						// or else the UPDATE got "no rows affected" *AND* the INSERT failed with a duplicate-key error. This
						// situation, and *only* this situation, is when we want to re-attempt the UPDATE.

					}	// Retry loop.

					Conflict_Test (reStart);

					if (SQLERR_error_test ())
					{
						GerrLogMini (GerrId, "6005: DB error %d writing to pharmacy_daily_sum for %d/%d/%d/%d after %d attempts.",
									 SQLCODE, v_PharmNum, v_MonthLog, PDS_date, v_TerminalNum, i);
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}	// DonR 04Jun2015: Insert/update to pharmacy_daily_sum is still conditional - but the condition has changed!


				// Update prescriptions-written table, and add to prescription_drugs-to-doctor_presc linkage table
				// and "pass-through" table for updating prescriptions in CDS.
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					// DonR 01Jun2022: Keep track of how many times this loop iterates, in an attempt
					// to diagnose sporadic cases where sale deletions don't take effect.
					AuditNumDrugsLooped++;

					phDrgPtr = &phDrgs [i];
					v_DrugCode			= phDrgs[i].DrugCode;

					// Loop through individual doctor prescriptions to update their statuses.
					if (phDrgPtr->PrescSource == RECIP_SRC_MACABI_DOCTOR)
					{
						// DonR 27Mar2018: Previously, we were allocating amounts sold to doctor prescriptions
						// based on what the pharmacy sends in terms of OP/units for each prescription - but
						// these values are not actually very meaningful. Instead, update_doctor_presc() is
						// now performing the allocation, based on what was actually prescribed and whether
						// monthly rounding is called for. To enable this, we set up two "balance" variables
						// to keep track of how much of the current drug line has yet to be allocated to a
						// doctor prescription.
						for (Rx = CarryForwardUnits = 0; Rx < phDrgPtr->NumDocRxes; Rx++)
						{
							DocRxPtr = &DocRx [Rx + phDrgPtr->FirstRx];
//GerrLogMini(GerrId, "6005 calling update_doctor_presc...");

							// DonR 24Aug2021 WORKINGPOINT: If the pharmacy has sent a "prescription" with Doctor Prescription ID = 0,
							// maybe we should just do a "continue" rather than go to update_doctor_presc(). It seems like situations
							// like this may be causing spooled 6005's not to update prescription_drugs rows as "sold", for reasons
							// that (for the moment) I don't understand. (OTOH we don't seem to have the problem in ordinary 6005's,
							// so maybe we should leave things alone here and change only the spooled version.)
							// DonR 25Aug2021: I've gone through update_doctor_presc() and tidied up a couple of things (including
							// a possible fix to the FORCE_NOT_FOUND macro), and I now think that calling the routine even with
							// a zero value for Doctor Prescription ID *should* be harmless. A "bogus" row will be written to
							// pd_rx_link, but that has some diagnostic value.

							err = update_doctor_presc	(	0,		// Normal mode - NOT processing late-arriving doctor prescriptions.
															v_ActionType,
															v_MemberID,							v_IDCode,
															v_RecipeIdentifier,					phDrgPtr->LineNo,
															phDrgPtr->DocID,					phDrgPtr->DocIDType,			DocRxPtr->PrID,
															phDrgPtr->Orig_Largo_Code,			phDrgPtr->DrugCode,				NULL,	// No TDrugListRow structure.
															DocRxPtr->FromDate,					SysDate,						SysTime,
															DocRxPtr->OP,						DocRxPtr->Units,	// Straight from the pharmacy.
															DocRxPtr->OP_Unsold,				DocRxPtr->UnitsUnsold,
															phDrgPtr->use_instr_template,							// DonR 01Aug2024 Bug #334612: Get "ratzif" from pharmacy instead of from doctor Rx.
															v_DeletedPrID,
															(Rx >= (phDrgPtr->NumDocRxes - 1)),						// Non-zero if this is the last prescription.
															&CarryForwardUnits,
															NULL,								NULL,				// We already know the Original Largo Code and Prescription Date.
															&phDrgPtr->NumRxLinks,
															NULL,	NULL,	NULL,	NULL		// Doctor visit & Rx arrival timestamps - relevant only for spool processing.
														);

							if (err)
								GerrLogMini (GerrId, "6005: update_doctor_presc() returned %d for %d Largo %d.",
											 err, v_RecipeIdentifier, phDrgPtr->DrugCode);
//GerrLogMini(GerrId, "6005 back from update_doctor_presc.");

							// If CarryForwardUnits has a value > 0, the pharmacy over-allocated units to the current prescripton.
							// In this case, add the CarryForwardUnits value to the *next* prescription in the list. Note that
							// CarryForwardUnits should automatically get a zero value for the last prescription in the list, but
							// we'll test that condition anyway just to be paranoid.
							if ((CarryForwardUnits > 0) && (Rx < (phDrgPtr->NumDocRxes - 1)))
							{
								// Increment units for the next prescription. Don't worry about adjusting
								// the OP number, at least for now.
								DocRx [Rx + phDrgPtr->FirstRx + 1].Units += CarryForwardUnits;
							}

						}	// Loop through doctor prescriptions for this drug line.
					}	// This drug line is for Maccabi Doctor prescriptions.


					// DonR 14Jun2004: If "drug" being purchased is a device in the "gadgets"
					// table, retrieve the appropriate information and notify the AS400 of
					// the sale.
					if ((phDrgs[i].ParticipMethod % 10) == FROM_GADGET_APP)
					{

						v_gadget_code	= phDrgs[i].LinkToAddition;
						v_DoctorPrDate	= phDrgs[i].SaleDate;		// inserted by pharmacy in Trn. 6003.

						// DonR 06Dec2018: If this is an OTC sale and pharmacy provided their own default
						// unit price, send that to Meishar rather than the standard price from the database.
						if ((phDrgs[i].PrescSource == RECIP_SRC_NO_PRESC) && (phDrgs[i].ph_otc_unit_price > 0))
						{
							Unit_Price		= phDrgs[i].ph_otc_unit_price;	// Use the pharmacy's default OTC unit price.
						}
						else
						{
							Unit_Price		= phDrgs[i].OpDrugPrice;	// Unless Maccabi Price is relevant (which it isn't,
																		// since the relevant code below is remarked out!
						}

						// DonR 15Sep2019 CR #28451: If this is a deletion, send Meishar the *original*
						// Pharmacy Code rather than the Pharmacy Code of the deleting pharmacy.
						if (v_ActionType == SALE_DELETION)
						{
							// DonR 23Jun2010: Gadget Action Code is now dependent on whether this is a
							// conventional drug sale or a deletion.
							AS400_Gadget_Action	= enActSterNo;

							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion itself.
							GadgetRecipeID = v_DeletedPrID;

							GadgetPharm = v_DeletedPrPharm;
						}
						else
						{
							// DonR 23Jun2010: Gadget Action Code is now dependent on whether this is a
							// conventional drug sale or a deletion.
							AS400_Gadget_Action	= enActWrite;

							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion itself.
							GadgetRecipeID = v_RecipeIdentifier;

							GadgetPharm = v_PharmNum;
						}

						ExecSQL (	MAIN_DB, READ_Gadgets_for_sale_completion,
									&v_service_code,	&v_service_number,	&v_service_type,
									&v_DrugCode,		&v_gadget_code,		&v_gadget_code,
									END_OF_ARG_LIST												);

						Conflict_Test (reStart);

						// DonR 12Sep2021: Add separate error-handling for row-not-found. This should never really
						// happen, but I just saw an error in the log that looked like the pharmacy had sent an
						// incorrect value for one of the "gadget" key fields.
						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							GerrLogMini (GerrId, "Trn. 6005: No gadgets row found for Largo %d Gadget Code %d.", v_DrugCode, v_gadget_code);
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}

						// If we get here, the gadget entry really does exist.
						// DonR 19Aug2025 User Story #442308: If Nihul Tikrot calls are disabled, disable Meishar calls as well.
//GerrLogMini(GerrId, "6005 calling as400SaveSaleRecord...");
						if (TikrotRPC_Enabled)
						{
							GadgetError = as400SaveSaleRecord ((int)GadgetPharm,				// DonR 15Sep2019 CR #28451.
															   (int)GadgetRecipeID,			// DonR 09Dec2010.
															   (int)v_MemberID,
															   (int)v_IDCode,
															   (int)v_service_code,
															   (int)v_service_number,
															   (int)v_service_type,
															   (int)v_DrugCode,
															   (int)phDrgs[i].Op,
															   (int)Unit_Price,
															   (int)phDrgs[i].TotalPtn,
															   (int)SysDate,					// Event Date
															   (int)v_DoctorID,
															   (int)v_DoctorPrDate,			// Request Date
															   (int)v_DoctorPrID,		// Request Num.
															   (int)AS400_Gadget_Action,
															   (int)2					// Retries
															  );
//GerrLogMini(GerrId, "6005: as400SaveSaleRecord returned %d.", GadgetError);
							GerrLogFnameMini ("gadgets_log",
											   GerrId,
											   "6005 SaveSaleRecord: AS400 err = %d.",
											   (int)GadgetError);
						}
						else	// If Nihul Tikrot calls are disabled, disable Meishar calls too.
						{
							GadgetError = -1;
						}

						if (GadgetError != 0)
						{
							v_action = AS400_Gadget_Action;

							// Write to "holding" table!
							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion, in second parameter.
//GerrLogMini(GerrId, "6005 executing INS_gadget_spool...");
							ExecSQL (	MAIN_DB, INS_gadget_spool,
										&v_PharmNum,			&GadgetRecipeID,
										&v_MemberID,			&v_IDCode,
										&v_DrugCode,			&v_service_code,
										&v_service_number,		&v_service_type,
										&phDrgPtr->Op,			&Unit_Price,

										&phDrgPtr->TotalPtn,	&SysDate,
										&v_DoctorID,			&v_DoctorPrDate,
										&v_DoctorPrID,			&v_action,
										&GadgetError,			&SysDate,
										&SysTime,				&IntZero,
										END_OF_ARG_LIST									);
//GerrLogMini(GerrId, "6005:  INS_gadget_spool returned SQLCODE %d.", SQLCODE);

							if (SQLERR_error_test ())
							{
								GerrLogToFileName ("gadgets_log",
												   GerrId,
												   "6005: DB Error %d writing to gadget_spool.",
												   (int)SQLCODE);

								v_ErrorCode = ERR_DATABASE_ERROR;
								break;
							}
						}	// Error notifying AS400 of sale.
					}	// Item sold got its participation from AS400 "Gadget" application.

					else
					{
						// If the "drug" purchased is a "gadget" but we didn't get participation
						// from the AS400, zero out the Link-to-Addition variable so the AS400
						// won't get the wrong idea about where participation came from.
						if (phDrgs[i].in_gadget_table != 0)
							phDrgs[i].LinkToAddition = 0;
					}


					// DonR 31Jul2023 User Story #469361: Add new drug-in-blood date logic. If certain
					// conditions are met, calculate start date, duration, and end date for a given
					// drug based on previous sales of the same drug (or a generic equivalent) from
					// prescriptions issued at the same doctor visit; if these conditions are not met,
					// just copy the appropriate values from the pharmacy-reported information and flag
					// the data as *not* calculated.
					//
					// First, copy in the default values from the pharmacy - this will save the complication
					// of having to set the defaults under more than one set of circumstances. Note that
					// StopUseDate = SysDate + Duration; it's the first day *after* the drug is finished,
					// assuming the member starts taking the drug on the day of purchase. At least for now,
					// we will calculate blood_last_date in the same way. (In reality, of course, this is
					// all pretty approximate!)
					phDrgPtr->blood_start_date		= SysDate;
					phDrgPtr->blood_duration		= phDrgPtr->Duration;
					phDrgPtr->blood_last_date		= phDrgPtr->StopBloodDate;
					phDrgPtr->blood_data_calculated	= 0;

					// If the drug is a "treatment" that allows computed duration, see if all the doctor
					// prescriptions being sold against are present and "ratzif" (= continuous treatment).
					// DonR 19Dec2023: Calculate duration-in-blood only for drug sales. Also, initialize
					// RXL_FirstDate to the current system date rather than zero.
					// DonR 17Jul2024 Bug #334612: Disable computed-duration calculation if we don't get
					// positive values for both NumPerDose and DosesPerDay from the pharmacy.
					// DonR 01Aug2024 Bug #334612: Also enable computed-duration calculation only if the
					// pharmacy specified that this is an ongoing treatment ("tipul ratzif") - i.e. if
					// use_instr_template is zero. Since we no longer need to verify continuous treatment
					// against the doctor_presc table, there's really no point in reading that table at
					// all - we can trust the list of prescriptions that the pharmacy sent.
					// DonR 07Aug2024 BUG FIX: The previous (01Aug2024) fix had the comparison wrong - it
					// had "!= 0" where it should have been "== 0".
					if ((v_ActionType					== DRUG_SALE	)	&&	// This is a drug sale (DonR 19Dec2023).
						(phDrgPtr->DL.largo_type		== 'T'			)	&&	// This is a "treatment" (i.e. a normal drug).
						(phDrgPtr->DL.compute_duration					)	&&	// Duration computation is enabled for this drug (according to drug_shape).
						(phDrgPtr->NumPerDose			>  0			)	&&	// DonR 17Jul2024.
						(phDrgPtr->DosesPerDay			>  0			)	&&	// DonR 17Jul2024.
						(phDrgPtr->use_instr_template	== 0			)	&&	// DonR 01Aug2024 - fixed 07Aug (from != to ==).
						(phDrgPtr->NumDocRxes			>  0			))		// Drug line has at least one "attached" doctor prescription.
					{
						short			FoundRxProblem		= 0;
						long			RxVisitNumber		= 0;
						int				EP_GroupToSearch	= 0;
						int				RXL_SoldUnits		= 0;
						int				TotalUnitsBought_i	= 0;
						int				TotalUsageDays_i	= 0;
						int				RXL_FirstDate		= SysDate;	// DonR 19Dec2023 fix initialization.
						int				OtherDrug;
						int				RxSubscript;
						float			TotalUnitsBought_f	= 0.0;
						float			TotalUsageDays_f	= 0.0;
						TDrugListRow	DP;		// Drug originally prescribed.

						// Scan through the pharmacy-supplied list of doctor prescriptions, checking that:
						// 1) There is at least one prescription on the list (actually, that's part of the "if" above).
						// 2) All prescriptions are from the same doctor visit.
//						// 3) All prescriptions are found in doctor_presc.
//						// 4) All prescriptions have prescription_type == 0, meaning that they're for continuing treatment.
						for (Rx = 0; Rx < phDrgPtr->NumDocRxes; Rx++)
						{
							RxSubscript = Rx + phDrgPtr->FirstRx;	// Just for convenience.

							if (Rx == 0)
							{
								RxVisitNumber = DocRx [RxSubscript].VisitNumber;

								if (RxVisitNumber < 1)
								{
// GerrLogMini (GerrId, "6005: Pharmacy sent Visit Number %ld - NOT calculating duration!", RxVisitNumber);
									FoundRxProblem = 1;
									break;
								}
// GerrLogMini (GerrId, "6005: Set RxVisitNumber = %ld, PrID = %d.", RxVisitNumber, DocRx [RxSubscript].PrID);
							}
							else
							{
								if (DocRx [RxSubscript].VisitNumber != RxVisitNumber)
								{
									FoundRxProblem = 1;
									break;
								}
							}

//							// If we get here, we're looking at either the first prescription on the list, or else
//							// another prescription with the same Visit Number. Now check if it's found in the
//							// doctor_presc table *with* prescription_type = 0 (= continuous treatment).
//							ExecSQL (	MAIN_DB, VerifyContinuousTreatmentRx,
//										&RowsFound,
//										&RxVisitNumber,					&DocRx [RxSubscript].PrID,
//										&phDrgPtr->Orig_Largo_Code,		&v_MemberID,
//										END_OF_ARG_LIST												);
//
//							Conflict_Test (reStart);
//
//							if (SQLERR_error_test ())
//							{
//								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
//								break;
//							}
//
//							// If we failed to find anything, either the prescription isn't there, or it's
//							// there but has non-zero Prescription Type - which amounts to the same thing
//							// for this purpose.
//							if (RowsFound < 1)
//							{
//								FoundRxProblem = 1;
//
// TEMPORARY!
//if (!TikrotProductionMode)
//	GerrLogMini (GerrId, "Did not find continuous-treatment Rx for Member %d Visit %ld PrID %d Largo %d.",
//				 v_MemberID, RxVisitNumber, DocRx [RxSubscript].PrID, phDrgPtr->Orig_Largo_Code);
//
//								break;
//							}	// Did *not* find a matching continuous-treatment prescription.
						}	// Loop through pharmacy-reported doctor prescriptions for this drug-line.

						// If we get here *without* setting FoundRxProblem TRUE, we've met the conditions for
						// computing the starting date, duration, and ending date for this drug prescribed
						// at this visit. If the sold drug has Economypri Group = 0, disable finding rows by
						// matching that value.
// GerrLogMini (GerrId, "6005: After first loop, FoundRxProblem = %d.", FoundRxProblem);
						if (!FoundRxProblem)
						{
							EP_GroupToSearch = (phDrgPtr->DL.economypri_group > 0) ? phDrgPtr->DL.economypri_group : -9999;

							// DonR 19Dec2023: Add RowsFound to output so we know if we actually found any
							// previous sales; and added the current PrescriptionID value to the input so
							// we don't read the current sale (which was already INSERTed to pd_rx_link) as
							// a prior sale.
							// DonR 01Aug2023 Bug #334612: This query doesn't change - but as part of this
							// bug fix, pd_rx_link/prescription_type (which the query SELECTs by) is populated
							// based on what the pharmacy sent in use_instr_template and *not* on how the
							// doctor wrote the prescription.
							// DonR 10Sep2024 Bug #334612 RE-OPENED: In order to avoid errors when the member
							// has bought drugs with different package sizes OR the doctor has prescribed
							// equivalent drugs with different package sizes, we need to compute the number of
							// pills/capsules/whatever *separately* for each past purchase. In order to do this,
							// I added a JOIN with drug_list to the database query, and the query now handles
							// the multiplication itself and returns a single total-units number instead of
							// separate OP and units numbers.
							ExecSQL (	MAIN_DB, GetPreviousDrugSaleTotalsByVisitNumber,
										&RXL_FirstDate,		&RXL_SoldUnits,			&RowsFound,

										&RxVisitNumber,		&v_RecipeIdentifier,	&phDrgPtr->DrugCode,
										&EP_GroupToSearch,	&v_MemberID,			END_OF_ARG_LIST			);

							Conflict_Test (reStart);
//GerrLogMini (GerrId, "GetPreviousDrugSaleTotalsByVisitNumber SQLCODE %d, RXL_SoldUnits %d, First Date %d, RowsFound %d.",
//	SQLCODE, RXL_SoldUnits, RXL_FirstDate, RowsFound);

							if ((SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE) || ((SQLCODE == 0) && (RowsFound == 0)))
							{
								// No previous purchases found - reset OP/Units values to zero, out of pure
								// paranoia, and set first purchase date to today.
								RXL_SoldUnits	= 0;
								RXL_FirstDate	= SysDate;
							}
							else
							{
								if (SQLERR_error_test ())
									{
										SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
										break;
									}
							}
// GerrLogMini (GerrId, "6005: After DB lookup, SQLCODE = %d, RXL_FirstDate = %d.", SQLCODE, RXL_FirstDate);

							// If we get here, we either read previous-purchase values or else got a
							// legitimate not-found "error". In either case, compute the duration and
							// stop-use date based on everything we know, including the *current*
							// usage instructions.

							// DonR 07Aug2023: We also need to look at other drug-lines in the *current*
							// sale request, since it's possible that both the prescribed drug and a
							// generic equivalent are being sold at the same time, based on the same
							// set of prescriptions issued at the same doctor visit. Note that if the
							// sold drug does not have an Economypri group associated with it, there's
							// nothing to do here.
							// DonR 01Aug2024 Bug #334612: Since we no longer need to verify continuous
							// treatment against the doctor_presc table, there's really no point in
							// reading that table at all - we can trust the list of prescriptions that
							// the pharmacy sent. Instead, just look at what the pharmacy sent for
							// use_instr_template to make sure the drug was sold for "tipul ratzif".
							if (EP_GroupToSearch > 0)
							{
								// Loop through all the drugs in the sale request, skipping past the current
								// one and any drug that is not a generic match for the current one OR is
								// being sold for non-continuous treatment.
								for (OtherDrug = 0; OtherDrug < v_NumOfDrugLinesRecs; OtherDrug++)
								{
									if (	(OtherDrug								== i)					||
											(phDrgs[OtherDrug].DL.economypri_group	!= EP_GroupToSearch)	||
											(phDrgs[OtherDrug].use_instr_template	!= 0)						)
									{
										continue;
									}
// GerrLogMini (GerrId, "Found another drug at position %d in current sale! Current drug is at position %d.", OtherDrug, i);

									// If we get here, we've found a different drug in the current sale request that
									// is a generic match for the current drug and was sold for continuous treatment
									// ("tipul ratzif"). Now loop through and see if any of its prescriptions match
									// the current drug's Visit Number. (Note that for this purpose, not all the
									// prescriptions for the drug need to be from the same doctor visit - the logic
									// is more like the logic used to select historical purchases above.)
									for (Rx = 0; Rx < phDrgs[OtherDrug].NumDocRxes; Rx++)
									{
										RxSubscript = Rx + phDrgs[OtherDrug].FirstRx;	// Just for convenience.

										if (DocRx [RxSubscript].VisitNumber == RxVisitNumber)
										{
//											ExecSQL (	MAIN_DB, VerifyContinuousTreatmentRx,
//														&RowsFound,
//														&RxVisitNumber,
//														&DocRx [RxSubscript].PrID,
//														&phDrgs[OtherDrug].Orig_Largo_Code,
//														&v_MemberID,
//														END_OF_ARG_LIST							);
//
//											Conflict_Test (reStart);
//
//											if (SQLERR_error_test ())
//											{
//												SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
//												break;
//											}
//
//											// If we failed to find anything, either the prescription isn't there,
//											// or it's there but has non-zero Prescription Type - which amounts to
//											// the same thing for this purpose.
//											if (RowsFound > 0)
//											{
											// Found a matching continuous-treatment prescription; add
											// its quantities to the total for computing duration. We
											// use the Effective Package Size for the drug being sold
											// rather than the prescribed drug *or* the drug being sold
											// in the current Prescription Line of the sale request.
											RXL_SoldUnits +=		(DocRx [RxSubscript].OP * phDrgs[OtherDrug].DL.effective_package_size)
																+	DocRx [RxSubscript].Units;
//											}	// Found a continuous-treatment other-drug prescription in the current sale request.
										}	// Found an other-drug prescription from the same doctor visit as the current drug.
									}	// Loop through prescriptions for a generic-equivalent drug in the same sale request.
								}	// Loop through the current sale request looking for generic equivalents of the current drug.
							}	// The current drug has a non-zero EconomyPri Group Code, so look for generic equivalents in this sale request.

							// If the Largo Prescribed is different from what's being sold now, we need to read
							// its effective package size in order to compute total quantity bought up to now.
							if ((phDrgPtr->DrugCode != phDrgPtr->Orig_Largo_Code) && (phDrgPtr->Orig_Largo_Code > 0))
							{
								// Just in case we couldn't read the prescribed drug, default to using the same drug info.
								if (!read_drug (phDrgPtr->Orig_Largo_Code, 999999999, NULL, true, &DP, NULL))
								{
									DP = phDrgPtr->DL;

									// DonR 01Nov2020: Add logging of any unexpected DB error reading drug_list.
									if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
									{
										SQLERR_error_test ();
									}
								}	// Read_drug failed to read the prescribed drug.
							}	// The prescribed drug is different from the drug being sold.
							else
							{
								DP.effective_package_size = phDrgPtr->DL.effective_package_size;
							}	// The drug being sold is the same as what was prescribed, so just copy Effective Package Size.

							// DonR 01Jul2024 HOT FIX: We were using the "naked" DL structure to get the package size
							// for the currently-purchased drug - but DL has not been initialized, so the package size
							// was essentially random. Instead, we need to reference the *actual* DL structure attached
							// to phDrgPtr (= &phDrgs[i]).
							// DonR 10Sep2024 Bug #334612 RE-OPENED: GetPreviousDrugSaleTotalsByVisitNumber now returns
							// a single number of total units bought in past purchases, instead of OP plus units.
							TotalUnitsBought_i =		RXL_SoldUnits											// Past sales in units, computed by the DB query.
													+	(phDrgPtr->Op	* phDrgPtr->DL.effective_package_size)	// Current purchase in terms of sold drug OP size.
													+	phDrgPtr->Units;

							// Convert the number of units to a float, and multiply by our "fudge factor",
							// defined as a percentage to increase the supply of the drug.
							TotalUnitsBought_f = (float)TotalUnitsBought_i * (1.0 + ((float)AdjustCalculateDurationPercent / 100.0));

							// Daily usage is based on what the pharmacy sends us for the *current* sale.
							// Add 0.995 because the requirement is to round up a day even if there's a
							// tiny remainder.
							// DonR 19Dec2023 BUG FIX: I forgot that the pharmacy reports "units per dose" multiplied by 100,
							// since otherwise we couldn't account for things like half-pill dosages. So to get the right
							// Total Units Bought, we need to divide by 100!
							TotalUsageDays_f = (TotalUnitsBought_f / (float)((float)phDrgPtr->NumPerDose * (float)phDrgPtr->DosesPerDay / 100.0)) + 0.995;
							TotalUsageDays_i = (int)TotalUsageDays_f;
//GerrLogMini (GerrId, "Other purchases: %d units. Buying %d OP + %d units = %d total units; adjusted total units = %f, days = %d (%f), FirstDate %d.",
//	RXL_SoldUnits, phDrgPtr->Op, phDrgPtr->Units, TotalUnitsBought_i, TotalUnitsBought_f, TotalUsageDays_i, TotalUsageDays_f, RXL_FirstDate);

							// Assign the values we've computed to the variables we'll store in prescription_drugs.
							phDrgPtr->blood_start_date		= RXL_FirstDate;
							phDrgPtr->blood_duration		= TotalUsageDays_i;
							phDrgPtr->blood_last_date		= AddDays (RXL_FirstDate, TotalUsageDays_i);
							phDrgPtr->blood_data_calculated	= 1;
						}	// FoundRxProblem is false, so lookup history and calculate duration.
// GerrLogMini (GerrId, "6005: After calculation, duration = %d.", phDrgPtr->blood_duration);
					}	// The drug is a "treatment" that allows computed duration, and pharmacy reported at least one prescription for it.


					// If this is a deletion, mark the original sold-drug row as deleted.
					// DonR 04Jul2016: Instead of repeating essentially the same code in eight places (i.e. two
					// tables, Transactions 5005 and 6005, online and spooled versions), created a single function
					// MarkDeleted() that handles the deletion-flag update. It returns zero if all went OK, and
					// anything else indicates a database error.
					// DonR 14Jun2022: We were seeing some situations where deletions weren't processed fully after
					// a database conflict, and it looks like the problem came about because of timing issues between
					// Transaction 6005 and the update-queue processing routine in As400UnixClient. In order to make
					// a fix and keep the code simple, I'm getting rid of the call to MarkDeleted() and putting all
					// the logic back in the mainline. If *any* of the updates of the original sale fail with a
					// DB-contention error, we will write *all* the deleted drugs and the "header" to drugsale_del_queue.
					if (v_ActionType == SALE_DELETION)
					{
						ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_UPD_prescription_drugs,
									&v_DeletedPrID,	&v_DrugCode,	END_OF_ARG_LIST			);

						// DonR 01Aug2023 User Story #469361: Added del_flg to pd_rx_link, so we can tell if a row in
						// that table is no longer "alive" without needing a join to prescription_drugs.
						if (SQLCODE == 0)
						{
							ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_UPD_pd_rx_link,
										&v_DeletedPrID,	&v_DrugCode,	END_OF_ARG_LIST		);
						}

						// DonR 19Mar2024 User Story #540234: Also update pd_cannabis_products/del_flg.
						if (SQLCODE == 0)
						{
							ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_UPD_pd_cannabis_products,
										&v_DeletedPrID,	&v_DrugCode,	END_OF_ARG_LIST		);
						}

						// If we hit an access-conflict error on the update, set the flag so we'll write *all*
						// the relevant stuff to drugsale_del_queue and then clear the DB error.
						// DonR 18Jul2023: Disabled the log message, since the fix has been running OK for over a year.
						if (SQLERR_code_cmp (SQLERR_access_conflict) == MAC_TRUE)
						{
//GerrLogMini (GerrId, "6005 deletion %d: MarkDrugSaleDeleted_UPD_prescription_drugs for %d Largo %d failed, SQLCODE = %d.", v_RecipeIdentifier, v_DeletedPrID, v_DrugCode, SQLCODE);
							NeedToQueueSaleStatusUpdates = MAC_TRUE;
							FORCE_SQL_OK;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								v_ErrorCode = ERR_DATABASE_ERROR;
								break;
							}
						}
					}	// Need to set deleted flag on original sale being deleted.


					// Prepare sold-ingredients variables.
					for (j = 0; j < 3; j++)
					{
						if ((phDrgs[i].ingr_code	[j]		<  1)	||
							(phDrgs[i].ingr_quant	[j]		<= 0.0)	||
							(phDrgs[i].per_quant	[j]		<= 0.0)	||
							(phDrgs[i].package_size <  1))
						{
							// Invalid values - set this slot to zero.
							phDrgs[i].ingr_code				[j] = 0;
							phDrgs[i].ingr_quant_bot		[j] = 0.0;
							phDrgs[i].ingr_quant_bot_std	[j] = 0.0;
						}

						else
						{
							if (phDrgs[i].package_size == 1)
							{
								// Syrups and similar drugs.
								phDrgs[i].ingr_quant_bot[j] =	  (double)phDrgs[i].Op
														* phDrgs[i].package_volume
														* phDrgs[i].ingr_quant	[j]
														/ phDrgs[i].per_quant	[j];

								phDrgs[i].ingr_quant_bot_std[j] =	  (double)phDrgs[i].Op
															* phDrgs[i].package_volume
															* phDrgs[i].ingr_quant_std	[j]
															/ phDrgs[i].per_quant		[j];
							}

							else	// Package size > 1.
							{
								// Tablets, ampules, and similar drugs.
								// For these medications, ingredient is always given per unit.
								UnitsSold	=	  (phDrgs[i].Op		* phDrgs[i].package_size)
												+  phDrgs[i].Units;

								phDrgs[i].ingr_quant_bot		[j] = (double)UnitsSold * phDrgs[i].ingr_quant		[j];
								phDrgs[i].ingr_quant_bot_std	[j] = (double)UnitsSold * phDrgs[i].ingr_quant_std	[j];
							}
						}	// Valid quantity values available.
					}	// Loop through ingredients for this drug.

					// Load DB variables with computed values. Note that the Ingredient Code
					// may have been zeroed out, so it needs to be reloaded!
					v_ingr_1_code		= phDrgs[i].ingr_code			[0];
					v_ingr_2_code		= phDrgs[i].ingr_code			[1];
					v_ingr_3_code		= phDrgs[i].ingr_code			[2];
					v_ingr_1_quant		= phDrgs[i].ingr_quant_bot		[0];
					v_ingr_2_quant		= phDrgs[i].ingr_quant_bot		[1];
					v_ingr_3_quant		= phDrgs[i].ingr_quant_bot		[2];
					v_ingr_1_quant_std	= phDrgs[i].ingr_quant_bot_std	[0];
					v_ingr_2_quant_std	= phDrgs[i].ingr_quant_bot_std	[1];
					v_ingr_3_quant_std	= phDrgs[i].ingr_quant_bot_std	[2];

					// DonR 05Jul2010: Per Iris Shaya, pharmacies send positive numbers for OP/Units,
					// Total Member Participation, and Total (Supplier) Drug Price in sale-deletion
					// requests. We "flip" these numbers to negative when writing to the database.
					// DonR 03Jul2013: Instead of "flipping" the numbers stored in phDrgPtr, use a set
					// of simple variables. This way, when we hit a database lock and execute this block
					// of code more than once, the underlying "real" variables will remain positive and
					// the numbers we write to the database for deletions will be reliably negative.
					// DonR 24May2022 BUG FIX: Instead of flipping the "source" value phDrgPtr->VoucherAmtUsed
					// for deletions, set an "sq" variable the same as we do for the other variables here.
					// This way, if we have to retry a deletion transaction after a DB-contention error,
					// the original value reported by the pharmacy will be unchanged and we won't perform
					// a "double flip" and write a positive number to the database when it should be negative.
					if (v_ActionType == SALE_DELETION)
					{
						sq_TotalMemberPrice	= phDrgPtr->TotalPtn					*  -1;
						sq_TotalDrugPrice	= phDrgPtr->TotalDrugPrice				*  -1;
						sq_Op				= phDrgPtr->Op							*  -1;
						sq_Units			= phDrgPtr->Units						*  -1;
						sq_VoucherAmtUsed	= phDrgPtr->VoucherAmtUsed				*  -1;	// DonR 27Jun2021 User Story #163882 / 24May2022 BUG FIX
					}
					else
					{
						// Ordinary drug sale - just copy the array/structure variables into the simple variables.
						sq_TotalMemberPrice	= phDrgPtr->TotalPtn;
						sq_TotalDrugPrice	= phDrgPtr->TotalDrugPrice;
						sq_Op				= phDrgPtr->Op;
						sq_Units			= phDrgPtr->Units;
						sq_VoucherAmtUsed	= phDrgPtr->VoucherAmtUsed;	// DonR 24May2022 BUG FIX
					}

					// Finally, update prescription_drugs. Note that this update has to happen
					// after the "gadget" logic, since the latter can change macabi_price_flg.
					// Note also that delivered_flg gets the same value as Action Type; this allows
					// routines like get_drugs_in_blood() to select only drug sales without having
					// to add an additional element to the WHERE clause.
					// DonR 23May2019 CR #29169: The value sent by pharmacy in phDrgPtr->MemberDiscPC is the
					// drug discount (set by the program in Trn. 6003), *not* the discount percent from the 
					// members table. Thus it should *not* be stored in member_discount_pt; if anywhere,
					// it should be in price_extension. However, even this is not necessary in the online
					// version of Trn. 6005, since price_extension is set by Trn. 6003 and the pharmacy
					// is not allowed to change it.
					// DonR 24May2022 BUG FIX: Use sq_VoucherAmtUsed instead of the value in phDrgPtr->VoucherAmtUsed; this gives
					// us a correctly-signed number even if we're performing a sale deletion and we have to do a retry because of
					// a DB-contention problem.
					// DonR 01Jun2022: Keep track of how many times we tried to update prescription_drugs,
					// in an attempt to diagnose sporadic cases where sale deletions don't take effect.
					// DonR Feb2023 User Story #232220: Add paid_for to columns UPDATEd.
					// DonR 27Mar2023 User Story #432608: Added 10 new columns to update.
					// DonR 02Aug2023 User Story #469361: Added 4 new columns to update.
					// DonR 04Feb2024 User Story #540234: Add NumCannabisProducts to update.
					AuditNumDrugsAttempted++;

					ExecSQL (	MAIN_DB, TR6005_UPD_prescription_drugs,
								&sq_Op,							&sq_Units,						&v_ActionType,
								&NOT_REPORTED_TO_AS400,			&phDrgPtr->StockOP,				&phDrgPtr->StockUnits,
								&sq_TotalDrugPrice,				&sq_TotalMemberPrice,			&phDrgPtr->MemberDiscPC,
								&phDrgPtr->MemberDiscPC,		&phDrgPtr->SupplierDrugPrice,	&phDrgPtr->DrugDiscountAmt,
								&phDrgPtr->DrugDiscountCode,	&v_ingr_1_code,					&v_ingr_2_code,
						
								&v_ingr_3_code,					&v_ingr_1_quant,				&v_ingr_2_quant,
								&v_ingr_3_quant,				&v_ingr_1_quant_std,			&v_ingr_2_quant_std,
								&v_ingr_3_quant_std,			&phDrgPtr->use_instr_template,	&phDrgPtr->how_to_take_code,
								&phDrgPtr->unit_code,			&phDrgPtr->DosesPerDay,			&phDrgPtr->NumPerDose,
								&phDrgPtr->Duration,			&phDrgPtr->course_treat_days,	&phDrgPtr->course_len_days,
						
								&phDrgPtr->course_len,			&phDrgPtr->course_len_units,	&phDrgPtr->days_of_week,
								&phDrgPtr->times_of_day,		&phDrgPtr->side_of_body,		&phDrgPtr->ElectPrStatus,
								&phDrgPtr->use_instr_changed,	&SysDate,						&SysTime,
								&phDrgPtr->MacabiPriceFlag,		&phDrgPtr->LinkToAddition,		&phDrgPtr->NumRxLinks,
								&sq_VoucherAmtUsed,				&paid_for,						&phDrgPtr->UsageInstrGiven,			// DonR 27Mar2023 begin.

								&phDrgPtr->MaccabiOtcPrice,		&phDrgPtr->SalePkgPrice,		&phDrgPtr->SaleNum4Price,
								&phDrgPtr->SaleNumBuy1Get1,		&phDrgPtr->Buy1Get1Savings,		&phDrgPtr->ByHandReduction,
								&phDrgPtr->IsConsignment,		&phDrgPtr->NumCourses,			&phDrgPtr->blood_start_date,		// DonR 27Mar2023 end, 02Aug2023 begin.
								&phDrgPtr->blood_duration,		&phDrgPtr->blood_last_date,		&phDrgPtr->blood_data_calculated,	// DonR 02Aug2023 end.
								&phDrgPtr->NumCannabisProducts,
						
								&v_RecipeIdentifier,			&phDrgPtr->LineNo,				END_OF_ARG_LIST					);

					Conflict_Test (reStart);

					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
					else
					// DonR 31May2022: Even if we didn't get an error from the database server,
					// we should confirm that a row was actually updated; if not, something is
					// seriously wrong!
					{
						if (!DB_UPDATE_WORKED)
						{
							GerrLogMini (GerrId, "Update for %d Line %d (Largo %d) failed - %d rows affected.",
										 v_RecipeIdentifier, phDrgPtr->LineNo, v_DrugCode, sqlca.sqlerrd[2]);
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							// DonR 01Jun2022: Keep track of how many times we updated prescription_drugs,
							// in an attempt to diagnose sporadic cases where sale deletions don't take effect.
							AuditNumDrugsUpdated++;
						}
					}
				}	// Loop through drugs.

				// If any SQL errors were detected inside drug loop, break out of dummy loop.
				// DonR 21Jul2011: If we've already logged an error, there's no need to log it again.
				if (v_ErrorCode == ERR_DATABASE_ERROR)
				{
					GerrLogMini (GerrId, "6005: Trapped DB error in drug-update loop.");
					break;	// If we have already trapped a DB error, break out of loop.
				}
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}


				// Update max_drug_date in members table.
				// DonR 05Sep2006: Don't do this for non-Maccabi OTC purchases.
				// DonR 09May2024: Disable this update for "mark as paid" mode.
				if ((max_drug_date	>  sq_maxdrugdate)	&&
					(v_MemberID		>  0)				&&
					(v_ActionType	!= SALE_DELETION)	&&
					(v_ActionType	!= MARK_AS_PAID))
				{
					ExecSQL (	MAIN_DB, UPD_members_max_drug_date,
								&max_drug_date,		&v_MemberID,
								&v_IDCode,			END_OF_ARG_LIST		);

					Conflict_Test (reStart);

					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}

				// If this is a deletion of all drugs in a sale, mark the original prescriptions row as deleted.
				// DonR 04Jul2016: Instead of repeating essentially the same code in eight places (i.e. two
				// tables, Transactions 5005 and 6005, online and spooled versions), created a single function
				// MarkDeleted() that handles the deletion-flag update. It returns zero if all went OK, and
				// anything else indicates a database error.
				// DonR 14Jun2022: We were seeing some situations where deletions weren't processed fully after
				// a database conflict, and it looks like the problem came about because of timing issues between
				// Transaction 6005 and the update-queue processing routine in As400UnixClient. In order to make
				// a fix and keep the code simple, I'm getting rid of the call to MarkDeleted() and putting all
				// the logic back in the mainline. If *any* of the updates of the original sale fail with a
				// DB-contention error, we will write *all* the deleted drugs and the "header" to drugsale_del_queue.
				// DonR 18Jul2023: Disabled the log message, since the fix has been running OK for over a year.
				if (v_ActionType == SALE_DELETION)
				{
					ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_UPD_prescriptions,
								&v_DeletedPrID,	&v_DeletedPrID,	END_OF_ARG_LIST		);
//if (SQLCODE) GerrLogMini (GerrId, "6005 deletion %d: MarkDrugSaleDeleted_UPD_prescriptions for %d: SQLCODE = %d, %d rows affected.", v_RecipeIdentifier, v_DeletedPrID, SQLCODE, sqlca.sqlerrd[2]);

					// DonR 19Jun2022: Until now, we did *not* perform the standard Conflict_Test(reStart) test
					// on this update, on the assumption that it was going to be such a common event that we
					// wanted to just write the relevant data to drugsale_del_queue and move on, rather than
					// force a retry. However, for reasons that remain mysterious to me, the previous updates
					// to prescription_drugs get backed out when this happens; and having run out of anything
					// obvious to fix, I'm going to try dealing with this as an ordinary database-conflict
					// situation, so that we force a retry that will - we hope! - make everything work OK.
					Conflict_Test (reStart);

					// If we hit an access-conflict error on the update, set the flag so we'll write *all*
					// the relevant stuff to drugsale_del_queue and then clear the DB error.
					// DonR 19Jun2022: SEE ABOVE - WE SHOULD NOT GET HERE IF THERE WAS AN ACCESS CONFLICT!
					if (SQLERR_code_cmp (SQLERR_access_conflict) == MAC_TRUE)	// SHOULD *ALWAYS* BE FALSE.
					{
GerrLogMini (GerrId, "6005 deletion %d: UPDATE prescriptions for %d failed, SQLCODE = %d.", v_RecipeIdentifier, v_DeletedPrID, SQLCODE);
						NeedToQueueSaleStatusUpdates = MAC_TRUE;
						FORCE_SQL_OK;
					}
					else
					{
						if (SQLERR_error_test ())
						{
							v_ErrorCode = ERR_DATABASE_ERROR;
							break;
						}
					}
				}	// Need to set deleted flag on original sale being deleted.

				// DonR 24Jul2013: Unless we hit a new error (like a database failure), we don't want to overwrite
				// a previously-stored error code in the prescriptions table; so use the previous value as our default.
				if (v_ErrorCode != 0)
					prev_pr_errorcode = v_ErrorCode;

				// Update PRESCRIPTIONS table.
				// DonR 20Aug2018: Added update of card_owner_id (which is actually the TZ of the second authorizing
				// pharmacist after we've sent "need 2 cards to sell" errors) and card_owner_id_code (which is currently
				// "reserved for future use"). These two fields are written to RK9021P/EAZHZR and EAPUUA.
				// DonR Feb2023 User Story #232220: Add paid_for to columns UPDATEd.
				// DonR 20Apr2023 User Story #432608: Add MagentoOrderNum and online_order_num to UPDATE. Note that in
				// 6005-online, online_order_num will not be different from what was already there.
				// DonR 09May2024 User Story #309732: In "mark as paid" mode, suppress the "ordinary" table updates.
				if (v_ActionType == MARK_AS_PAID)
				{
					FORCE_SQL_OK;	// So we'll think all these updates succeeded without error.
				}
				else
				{
					ExecSQL (	MAIN_DB, TR6005_UPD_prescriptions,
								&v_InvoiceNum,			&v_UserIdentification,		&v_PharmRecipeNum,
								&v_ElectPrStatus,		&v_ClientLocationCode,		&v_MonthLog,
								&v_ActionType,			&NOT_REPORTED_TO_AS400,		&v_CreditYesNo,
								&SysDate,				&SysTime,					&prev_pr_errorcode,
					
								&ShortZero,				&v_RetnReasonCode,			&v_CreditLinePmts,
								&v_PaymentType,			&v_TotalTikraDisc,			&v_TotalCouponDisc,
								&v_ElectPrStatus,		&v_ReasonToDispense,		&v_PharmPtnCode,
								&v_6003CommError,		&v_CardOwnerID,				&v_CardOwnerIDCode,
								&paid_for,				&MagentoOrderNum,			&online_order_num,
					
								&v_RecipeIdentifier,	END_OF_ARG_LIST										);

					Conflict_Test (reStart);


					// DonR 22May2013: Also mark prescription_msgs and prescription_usage rows as delivered. Since the
					// delivery isn't complete unless we write to the database without any problems, we can piggy-back
					// on the same error handling. (Note that "no rows affected" doesn't throw an error in
					// SQLCODE/SQLERR_error_test.)
					if (SQLCODE == 0)
					{
						ExecSQL (	MAIN_DB, UPD_prescription_msgs_mark_delivered,
									&SysDate,				&SysTime,				&v_ActionType,
									&NOT_REPORTED_TO_AS400,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);

						Conflict_Test (reStart);
					}

					if (SQLCODE == 0)
					{
						ExecSQL (	MAIN_DB, UPD_prescription_usage_mark_delivered,
									&SysDate,				&SysTime,				&v_ActionType,
									&NOT_REPORTED_TO_AS400,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);

						Conflict_Test (reStart);
					}

					// 21Jun2018 Online Orders (SuperPharm) - update online order to reflect sale completion.
					if ((SQLCODE == 0) && (v_ActionType == DRUG_SALE) && (online_order_num > 0))
					{
						ExecSQL (	MAIN_DB, UPD_online_orders_RecordSaleAgainstOrder,
									&v_RecipeIdentifier,	&v_PharmNum,
									&SysDate,				&SysTime,
									&online_order_num,		&Phrm_info.web_pharmacy_code,
									&Phrm_info.owner,		END_OF_ARG_LIST					);

						Conflict_Test (reStart);
					}

					// DonR 02Jun2021 User Story #163882: Write any voucher-used info to prescription_vouchers.
					if (SQLCODE == 0)	// No previous DB error.
					{
						for (VoucherNum = 0; (VoucherNum < NumVouchers) && (SQLCODE == 0); VoucherNum++)
						{
							ExecSQL	(	MAIN_DB, TR6005_INS_prescription_vouchers,
										&v_RecipeIdentifier,								&Voucher [VoucherNum].voucher_num,
										&v_MemberID,										&v_IDCode,
										&Voucher [VoucherNum].voucher_type,					&Voucher [VoucherNum].voucher_discount_given,
										&Voucher [VoucherNum].voucher_amount_remaining,		&Voucher [VoucherNum].original_voucher_amount,
										&SysDate, /* ==> sold_date */						&SysDate, /* ==> date */
										&SysTime,											&NOT_REPORTED_TO_AS400,
										END_OF_ARG_LIST																						);

							Conflict_Test (reStart);
						}
					}	// No previous DB error, so try adding vouchers to prescription_vouchers.

					// DonR 04Feb2024 User Story #540234: Write any cannabis product details to pd_cannabis_products.
					if (SQLCODE == 0)	// No previous DB error.
					{
						short	LineNumber;
						int		GroupLargoCode;

						for (Product = 0; (Product < TotalNumCannabisProducts) && (SQLCODE == 0); Product++)
						{
							LineNumber		= phDrgs [CannabisProduct [Product].DrugLineSubscript].LineNo;
							GroupLargoCode	= phDrgs [CannabisProduct [Product].DrugLineSubscript].DrugCode;

							// DonR 18Mar2024: If this is a deletion, "flip" some numbers negative.
							if (v_ActionType == SALE_DELETION)
							{
								if (CannabisProduct [Product].op		> 0)
									CannabisProduct [Product].op		*= -1;

								if (CannabisProduct [Product].units		> 0)
									CannabisProduct [Product].units		*= -1;

								if (CannabisProduct [Product].product_sale_amount	> 0)
									CannabisProduct [Product].product_sale_amount	*= -1;

								if (CannabisProduct [Product].product_ptn_amount	> 0)
									CannabisProduct [Product].product_ptn_amount	*= -1;
							}

							ExecSQL	(	MAIN_DB, TR6005_INS_pd_cannabis_products,
										&v_RecipeIdentifier,
										&LineNumber,
										&CannabisProduct [Product].cannabis_product_code,
										&CannabisProduct [Product].cannabis_product_barcode,
										&GroupLargoCode,
										&CannabisProduct [Product].op,
										&CannabisProduct [Product].units,
										&CannabisProduct [Product].price_per_op,
										&CannabisProduct [Product].product_sale_amount,
										&CannabisProduct [Product].product_ptn_amount,
										&ROW_NOT_DELETED,
										&NOT_REPORTED_TO_AS400,
										&SysDate,
										&SysTime,
										END_OF_ARG_LIST										);

							Conflict_Test (reStart);

							// DonR 29May2025: If a pharmacy sent duplicate cannabis-product information,
							// log a message and try to fail gracefully.
							if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_TRUE)
							{
								GerrLogMini (GerrId,	"Duplicate cannabis-product information from Pharmacy %d: Prescription ID %d, Line #%d, "
														"Product line number %d, Group Largo %d, Cannabis Product Code %d, "
														"Barcode %ld. Rejecting!",
														v_PharmNum, v_RecipeIdentifier, LineNumber,
														Product, GroupLargoCode, CannabisProduct [Product].cannabis_product_code,
														CannabisProduct [Product].cannabis_product_barcode);

								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;	// So we don't log the database error again and create a panic.
							}	// INSERT failed on duplicate cannabis product.

						}
					}	// No previous DB error, so try adding product details to pd_cannabis_products.

				}	// DonR 09May2024 User Story #309732: Execute these updates only if we're *not*
					// in "mark as paid" mode.


				// DonR 05Mar2023 User Story #232220: If there is a list of previous sales to mark
				// as "paid", update prescriptions, prescription_drugs, and pharmacy_daily_sum. Note
				// that the pharmacy_daily_sum update has to be done first, since the relevant SQL
				// selects only *unpaid* sales to add to the Daily Sum table. This avoids adding the
				// same sale to the totals twice.
				// Note that (at least for now) we are *not* making these updates conditional on the
				// paid-for status of the current sale - even though it would be kind of crazy for
				// a not-yet-paid sale to include a list of previous sales that *are* now being paid.
				// We are also assuming that we will get a list of previous sales *only* when we are
				// selling stuff - deletions are still handled one at a time.
				if (SQLCODE == 0)	// No previous DB error.
				{
					for (OtherSaleNum = 0; (OtherSaleNum < NumOtherSales) && (SQLCODE == 0); OtherSaleNum++)
					{
						// DonR 04Mar2024 User Story #232220: Pharmacies may, apparently, send the
						// last 6005 in the series with Credit Type 99 (= unpaid) and then include
						// the last Prescription ID in this list of transactions to mark "paid". In
						// order to avoid duplicate updates and other potential problems, we changed
						// the Credit Type up above if one of the "other sales" is in fact the current
						// sale. In this case, we also set the "other sale ID" to zero so we won't
						// update it again here.
						// DonR 02May2024 User Story #232220 YARPA BUG WORKAROUND: For some reason,
						// Yarpa is sending an "other sale" line along with deletion transactions
						// even if the deletion transaction is still "unpaid". This was causing the
						// deletion to be marked as "paid", and then a later update with the actual
						// Credit Type Used value wouldn't work because the SQL updates only rows
						// with paid_for = 0. The workaround is to skip the updates to prescriptions,
						// prescription_drugs, and pharmacy_daily_sum if the Credit Type Used value
						// is 99, since in fact this value means that the transaction should *not*
						// (yet) be marked as paid.
						if ((OtherSaleID [OtherSaleNum] == 0) || (OtherSaleCredLine [OtherSaleNum] == 99))
						{
							continue;
						}

						ExecSQL	(	MAIN_DB, UPD_pharmacy_daily_sum_from_prior_sale,
									&OtherSaleID [OtherSaleNum],	&Phrm_info.maccabi_pharmacy,
									&v_PharmNum,					&v_InstituteCode,
									&v_MonthLog,					&SysDate,
									&v_TerminalNum,					END_OF_ARG_LIST					);

						Conflict_Test (reStart);

						if (SQLCODE == 0)
						{
							// DonR 05Mar2024 User Story #232220: Use the Credit Type Used value from
							// the "extra sales" list, *not* the one reported for the current sale, to
							// update previous sales. There may be a mix of different Credit-Type values
							// in the list, since it's entirely possible that the member may be paying
							// for different purchases for different members. Also, we now update the
							// Payment Type value - although since we get this only for the current
							// transaction, we may be putting incorrect values there in some cases. I've
							// asked Iris if we should add Payment Method to the "extra sales" data sent
							// by the pharmacy instead of just copying it from the "header" Payment Type,
							// since we have 15 bytes there "reserved for future use" and this would use
							// up only 2 of them.
							ExecSQL	(	MAIN_DB, UPD_prescriptions_mark_paid,
										&OtherSaleCredLine	[OtherSaleNum],
										&OtherSalePmtType	[OtherSaleNum],
										&OtherSaleID		[OtherSaleNum],
										END_OF_ARG_LIST							);

							Conflict_Test (reStart);
						}

						if (SQLCODE == 0)
						{
							ExecSQL	(	MAIN_DB, UPD_prescription_drugs_mark_paid,
										&OtherSaleCredLine	[OtherSaleNum],
										&OtherSaleID		[OtherSaleNum],
										END_OF_ARG_LIST										);

							Conflict_Test (reStart);
						}
					}	// Loop through list of prior sales to update.
				}	// No previous SQL error, so update prior sales/pharmacy_daily_sum with payment data.

				// DonR 14Jun2022: If this is a sale deletion and *any* of the updates to the original drug sale
				// failed with an access-conflict error, we need to write *all* the relevant data to the
				// drugsale_del_queue table.
				if ((SQLCODE == 0) && (v_ActionType == SALE_DELETION) && (NeedToQueueSaleStatusUpdates))
				{
					// First write the "header" to drugsale_del_queue.
					ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_INS_drugsale_del_queue,
								&v_DeletedPrID,	&IntZero,	END_OF_ARG_LIST				);

					// If the header INSERT worked, write the drug lines.
					for (i = 0; (i < v_NumOfDrugLinesRecs) && (SQLCODE == 0); i++)
					{
						v_DrugCode = phDrgs[i].DrugCode;
						ExecSQL (	MAIN_DB, MarkDrugSaleDeleted_INS_drugsale_del_queue,
									&v_DeletedPrID,	&v_DrugCode,	END_OF_ARG_LIST			);
					}

					Conflict_Test (reStart);
				}

				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}

			}
			while (0);	// Dummy loop Should run only once.
			// End of dummy loop to prevent goto.
		}
		else	// DonR 04Aug2010: Some error occurred in previous processing - tag prescriptions row
				// with error code.
		{
			// DonR 09May2024 User Story #309732: In "mark as paid" mode, we do *not* want to write
			// any errors to the prescriptions row.
			if ((v_RecipeIdentifier > 0) && (v_ActionType != MARK_AS_PAID))
			{
				// Update PRESCRIPTIONS table. No error handling, as this is going to be a non-delivered
				// prescription and this update is informational only.
				ExecSQL (	MAIN_DB, UPD_prescriptions_set_error_code,
							&v_ErrorCode,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);
			}
		}	// Serious error occurred - only DB update is to flag prescriptions row with error code.


		// Commit the transaction.
		if (reStart == MAC_FALS)	// No retry needed.
		{
			if (!SetErrorVar (&v_ErrorCode, v_ErrorCode)) // Transaction OK
			{
				CommitAllWork ();
			}
			else
			{
				// Error, so do rollback.
				RollbackAllWork ();
			}

			if (SQLERR_error_test ())	// Commit (or rollback) failed.
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
			}
		}
		else
		{
			// Need to retry.
			if (TransactionRestart () != MAC_OK)
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			}

			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogMini (GerrId, "Table is locked for the <%d> time", (tries + 1));

			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}


	}	// End of retries loop.


	if (reStart)
	{
		GerrLogReturn (GerrId, "Locked for <%d> times",SQL_UPDATE_RETRIES);

		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}


	// Don't send warnings - only fatal errors.
	if (v_ErrorCode != NO_ERROR)
	{
		Sever = GET_ERROR_SEVERITY (v_ErrorCode);

		if (Sever <= FATAL_ERROR_LIMIT)
		{
			v_ErrorCode = NO_ERROR;
		}
	}

	// Create Response Message
	nOut =  sprintf (OBuffer,		 "%0*d",	MSG_ID_LEN,					6006				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	MSG_ERROR_CODE_LEN,			MAC_OK				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TPharmNum_len,				v_PharmNum			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TInstituteCode_len,			v_InstituteCode		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TTerminalNum_len,			v_TerminalNum		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TErrorCode_len,				v_ErrorCode			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TMemberIdentification_len,	v_MemberID			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TIdentificationCode_len,	v_IDCode			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TRecipeIdentifier_len,		v_RecipeIdentifier	);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TDate_len,					SysDate				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	THour_len,					SysTime				);


	// Return the size in Bytes of respond message
	*p_outputWritten			= nOut;
	*output_type_flg			= ANSWER_IN_BUFFER;
	ssmd_data_ptr->error_code	= v_ErrorCode;
	ssmd_data_ptr->terminal_num	= v_TerminalNum;

	// DonR 23Nov2017: Store number of drug lines in audit-trail variable.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = v_NumOfDrugLinesRecs;

	RESTORE_ISOLATION;

	return RC_SUCCESS;
}
// End of real-time 6005 handler.



/*=======================================================================
||																		||
||			 HandlerToSpool_6005										||
||	Message handler for message 6005:									||
||        Drugs Delivery "Digital Prescription" version - spooled mode.	||
||																		||
 =======================================================================*/

int HandlerToSpool_6005 (	char		*IBuffer,
							int			TotalInputLen,
							char		*OBuffer,
							int			*p_outputWritten,
							int			*output_type_flg,
							SSMD_DATA	*ssmd_data_ptr,
							short int	commfail_flag,
							int			*NumProcessed_out)

{
	// Local declarations
	ISOLATION_VAR;
	int				nOut;
	int				i;
	int				j;
	int				is;
	int				reStart;
	int				ElyCount;
	int				flg;
	int				UnitsSellable;
	int				UnitsSold;
	int				ComparePharmPtn;
	int				PDS_saved_sqlcode;
	int				PDS_saved_rows;
	int				CarryForwardUnits		= 0;
	int				RowsFound;
	short			MaxRx					= 1;	// Element zero is left blank, and we start storing real data with Element 1.
	short			AddNewRows				= 0;	// Default is that we already got Transaction 6003 and this is a sale-completion update.
	short			dummy;
	short			AmountMismatch			= 0;
	TErrorCode		err;
	TErrorSevirity	Sever;
	TMonthLog		MonthLogCalc_next;
	TMonthLog		MonthLogCalc;
	short			NextMonthMinDay;
	ACTION_TYPE		AS400_Gadget_Action;
	int				GadgetPharm;
	char			filler		[256];
	char			ErrorBuf	[501];

	// Message fields variables

	// Prescription Lines structure
	Msg6005Drugs	phDrgs				[MAX_REC_ELECTRONIC];
	Msg6005Drugs	*phDrgPtr;
	Msg6005Drugs	dbDrgs;
	TDocRx			DocRx				[1001];
	TDocRx			*DocRxPtr;
//	short			NumRxUnfilled		= 0;	// DonR 02Jun2021 User Story #163882: Unfilled Prescriptions are replaced by Vouchers Used.
//	TUnfilledRx		UnfilledRx			[1000];	// DonR 02Jun2021 User Story #163882: Unfilled Prescriptions are replaced by Vouchers Used.
	short			NumVouchers			= 0;	// DonR 02Jun2021 User Story #163882.
	short			VoucherNum;					// DonR 02Jun2021 User Story #163882.
	TVoucherUsed	Voucher				[1000];	// DonR 02Jun2021 User Story #163882.
	short			NumOtherSales;
	short			OtherSaleNum;
	int				OtherSaleID			[MAX_REC_ELECTRONIC];
	short			OtherSaleCredLine	[MAX_REC_ELECTRONIC];
	short			OtherSalePmtType	[MAX_REC_ELECTRONIC];

	// New stuff for "Nihul Tikrot"
	short						v_ActionType;
	short						v_RetnReasonCode;
	short						v_6003CommError;
	short						PreviousErrorCode	= 0;
	int							v_CardOwnerID;				// Actually Second Pharmacist TZ - written to RK9021P/EAZHZR.
	short						v_CardOwnerIDCode;			// Actually reserved for future use - written to RK9021P/EAPUUA.
	short						v_CreditLinePmts	= 0;	// DonR 17May2016: For now at least, we are *not* getting this from pharmacy!
	short						v_PaymentType;
	int							v_TotalTikraDisc;
	int							v_TotalCouponDisc;
	short						v_PharmPtnCode;	// DonR 31Jan2011

	// Variables for deletion/refund of previous sales.
	int							v_DeletedPrID;
	int							sq_DeletedPrID;		// DonR 15Mar2011 - in case original sale came via spool.
	int							v_DeletedPrDate;
	int							v_DeletedPrPharm;
	short						v_DeletedPrYYMM;
	int							v_DeletedPrPhID;
	short						v_DeletedPrSrc;
	int							v_DeletedGadget;
	short						v_DeletedPrBasket;
	int							v_DeletedPrSubAmt;
	int							v_DeletedPrTikAmt;
	int							v_DeletedPrMemPrc;
	int							v_DeletedPrSupPrc;
	int							v_DeletedPrFixPrc;
	int							v_DeletedPrTotPrc;
	int							v_DeletedPrDiscnt;
	int							v_DeletedClLocCode;
	short						v_DeletedPrDsCode;
	short						v_DeletedPrTkMazon;
	int							v_DeletedPrIshNum;
	short						v_DeletedPrIshSrc;
	short						v_DeletedPrIshTik;
	short						v_DeletedPrIshTkTp;
	short						v_DeletedPrDelFlg;
	short						v_DeletedPrPrcCode;
	short						v_DeletedPrPrtMeth;
	int							v_DeletedPrRuleNum;
	int							v_DeletedPrOP;
	int							v_DeletedPrUnits;
	int							v_DeletedPrPtn;
	int							v_DeletedPrDocId;

	// Pharmacy Daily Sum.
	int							PDS_sum				= 0;
	int							PDS_prt_sum			= 0;
	int							PDS_lines			= 0;
	int							PDS_count			= 0;
	int							PDS_purch_sum		= 0;
	int							PDS_del_sum			= 0;
	int							PDS_del_prt_sum		= 0;
	int							PDS_del_lines		= 0;
	int							PDS_del_count		= 0;
	int							PDS_del_purch_sum	= 0;
	int							PDS_date			= 0;

	short						Rx_OpUpdate;
	short						Rx_UnitsUpdate;
	short						Rx_status;

	int							v_ClientLocationCode;
	short						v_ReasonToDispense;
	short						v_in_gadget_table;

	// DonR 12Feb2006: Ingredients-sold fields.
	double						v_package_volume;
	short						v_ingr_1_code;
	short						v_ingr_2_code;
	short						v_ingr_3_code;
	double						v_ingr_1_quant;
	double						v_ingr_2_quant;
	double						v_ingr_3_quant;
	double						v_ingr_1_quant_std;
	double						v_ingr_2_quant_std;
	double						v_ingr_3_quant_std;
	double						v_per_1_quant;
	double						v_per_2_quant;
	double						v_per_3_quant;

	// DonR 01Feb2024 User Story #540234: Add reporting of cannabis product details.
	short						TotalNumCannabisProducts	= 0;
	short						v_NumCannabisProducts;
	short						Product;
	TCannabisProducts			CannabisProduct [MAX_CANNABIS_PRODUCTS];

	TDrugListRow				DL;
	PHARMACY_INFO				Phrm_info;
	int							v_PharmNum;
	short						v_InstituteCode;
	short						v_TerminalNum;
	short						v_MemberBelongCode;
	int							v_MemberID;
	short						v_IDCode;
	TMoveCard					v_MoveCard;
	int							v_DoctorID;
	int							v_InvoiceNum;
	int							v_UserIdentification;
	int							v_PharmRecipeNum;
	int							v_RecipeIdentifier;
	int							v_RecipeIdentifier1;
	int							SaleDate;
	int							SaleTime;
	short						v_MonthLog;
	TNumOfDrugLinesRecs			v_NumOfDrugLinesRecs;
	TCreditYesNo				v_CreditYesNo;
	short						paid_for;				// DonR 05Feb2023 User Story #232220
	short						LineNum;

	int							v_SpecialConfNum;
	short						v_SpecialConfSource;


	// Gadgets/Gadget_spool tables.
	short						v_action;
	int							v_service_code;
	int							v_gadget_code;
	short						v_service_number;
	short						v_service_type;
	int							v_DrugCode;
	int							Unit_Price;
	int							v_DoctorPrID;
	int							v_DoctorPrDate;
	short						PRW_OriginCode;
	TErrorCode					GadgetError;
	int							GadgetRecipeID;
	int							GadgetCodeFound;

	// Remote order variables.
	long						online_order_num	= 0L;
	long						OnlineOrderNum_6005	= 0L;	// DonR 20Apr2023 User Story #432608 - do we want to do anything with this value?
	long						MagentoOrderNum		= 0L;	// DonR 20Apr2023 User Story #432608.
	int							OO_made_pr_id;

	// Return-message variables
	int							SysDate;
	int							SysTime;
	TErrorCode					v_ErrorCode;


	// Miscellaneous DB variables
	short						HeaderPrescSource		= 0;	// DonR 10Jun2015
	int							same_pr_count;					// DonR 20Aug2020 BUG FIX: Read from COUNT(*), so it needs to be an int rather than a short.
	int						  	v_TempMembIdentification;
	short						v_TempIdentifCode;
	int							v_TempMemValidUntil;
	short						v_MemberCreditFlag;
	short						sq_ActionType;
	int							sq_pharmnum;
	TInstituteCode				sq_institutecode;
	TTerminalNum				sq_terminalnum;
	TPriceListNum				sq_pricelistnum;
	int							sq_doctorprescid;
	TMemberBelongCode			sq_memberbelongcode;
	int							sq_MemberID;
	TIdentificationCode			sq_identificationcode;
	TRecipeSource				sq_recipesource;
	TNumOfDrugLinesRecs			sq_numofdruglinesrecs;
	TErrorCode					sq_errorcode;
	int							sq_TotalMemberPrice;
	int							sq_TotalDrugPrice;
	int							sq_TotSuppPrice;
	TMemberDiscountPercent		sq_member_discount;
	int							sq_tikra_discount;
	int							sq_subsidy_amount;
	int							sq_VoucherAmtUsed;
	int							sq_member_ptn_amt;
	int							StopUseDate;
	int							StopBloodDate;

	int							sq_maxdrugdate;
	int							max_drug_date;
	short						sq_thalf;
	int							sq_DateDB;
	TMonthLog					sq_MonthLogDB;
	int							v_count_double_rec;
	short						v_MemberSpecPresc;
	short						report_as400_flag;
	short						v_PriceListCode;
	short						delete_flag;
	int							sq_Op;
	int							sq_Units;
	short						PW_SubstPermitted;
	short						v_Comm_Error = commfail_flag;
	short						Rx;

	int							RXL_PrID;
	int							RXL_FromDate;
	int							RXL_OP;
	int							RXL_Units;
	int							v_DeletedRxLargo;
	long						RXL_VisitNumber;

	// Member fields that aren't used in this transaction - added so we can
	// use a common read-member ODBC operation.
	int						MemberZipCode;
	char					MemberDefaultPhone		[10 + 1];
	char					MemberStreet			[12 + 1];
	char					MemberHouseNum			[ 4 + 1];
	char					MemberCity				[20 + 1];
	TMemberFamilyName		v_MemberFamilyName;
	TMemberFirstName		v_MemberFirstName;
	short					v_MemberGender;
	int						illness_bitmap;
	short					v_MemberDiscPercent;
	short					v_insurance_status;
	int						v_FamilyHeadTZ;
	short					v_FamilyHeadTZCode;
	short					v_in_hospital;
	short					TransactionID	= 6005;

	// DonR 28Jul2021: Add a couple of variables to try to detect problems adding/updating
	// prescription_drugs rows. I think I may have fixed the problems that were allowing
	// the transaction to think it succeeded even though not all prescription_drugs rows
	// were inserted/updated, but I want to make sure.
	short					NumPrescriptionDrugsRowsTriedToAdd		= 0;
	short					NumPrescriptionDrugsRowsAdded			= 0;
	short					NumPrescriptionDrugsRowsTriedToUpdate	= 0;
	short					NumPrescriptionDrugsRowsUpdated			= 0;



	// Body of function.

	// Initialize variables.
	REMEMBER_ISOLATION;
	PosInBuff		= IBuffer;
	v_ErrorCode		= NO_ERROR;
	SysDate			= GetDate ();
	SysTime			= GetTime ();
	AmountMismatch	= 0;
	memset ((char *)phDrgs,				0, sizeof (phDrgs));
	memset ((char *)&dbDrgs,			0, sizeof (dbDrgs));			// (This one is not an array.)
	memset ((char *)DocRx,				0, sizeof (DocRx));
	memset ((char *)CannabisProduct,	0, sizeof (CannabisProduct));	// DonR 01Feb2024 User Story #540234.




	// Read message fields data into variables.
	// NOTE: Field offsets are calculated based on the most recent version of the transaction. To
	// "deconstruct" an incoming message with an earlier transaction version number, adjust accordingly.
	v_PharmNum					= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//   1:  10,  7
	v_InstituteCode				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   2:  17,  2
	v_TerminalNum				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   3:  19,  2
	v_ActionType				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   4:  21,  2
	v_RetnReasonCode			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//   5:  23,  2
	v_6003CommError				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//   6:  25,  4
	v_DeletedPrID				= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//   7:  29,  9
	v_DeletedPrPharm			= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//   8:  38,  7
	v_DeletedPrYYMM				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//   9:  45,  4
	v_DeletedPrPhID				= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  10:  49,  6
	v_DeletedPrDate				= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  11:  55,  8
	v_MemberID					= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  12:  63,  9
	v_IDCode					= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  13:  72,  1
	v_MemberBelongCode			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  14:  73,  2

	// DonR 20Aug2018: "Card Owner ID" is in fact the TZ of the second pharmacist, for those cases where
	// two pharmacists have to pass their cards to permit a drug sale to happen. It's written to
	// RKFILPRD/RK9021P/EAZHZR. "Card Owner ID Code" is written to EAPUUA, but in fact it's a "reserved
	// for future use" field at present.
	v_CardOwnerID				= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  15:  75,  9
	v_CardOwnerIDCode			= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  16:  84,  1

	v_MoveCard					= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  17:  85,  4
	v_UserIdentification		= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  18:  89,  9
	v_SpecialConfSource			= GetShort	(&PosInBuff,  1				); CHECK_ERROR();	//  19:  98,  1
	v_SpecialConfNum			= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  20:  99,  8
	v_PharmRecipeNum			= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  21: 107,  6
	v_RecipeIdentifier			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  22: 113,  9
	SaleDate					= GetInt	(&PosInBuff,  8				); CHECK_ERROR();	//  23: 122,  8
	SaleTime					= GetInt	(&PosInBuff,  6				); CHECK_ERROR();	//  24: 130,  6

	// Note: This will be the Credit Type Used. In some circumstances, it may be
	// different from the Credit Type that was sent to the pharmacy - for example,
	// the member may elect to pay in cash even though s/he has an automated
	// payment ("horat keva") set up. This value will be stored in the new database
	// field credit_type_used.
	v_CreditYesNo				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  25: 136,  2

	// 19Mar2023: Current versions running in Production are 1 and 3
	// (plus a very small number of 2's). Next Version Number will be 4.
	VersionNumber				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  26: 138,  2

	v_PaymentType				= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  27: 140,  2
	v_InvoiceNum			 	= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//  28: 142,  7
	v_ClientLocationCode		= GetInt	(&PosInBuff,  7				); CHECK_ERROR();	//  29: 149,  7
	v_MonthLog					= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  30: 156,  4
	v_ReasonToDispense			= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  31: 160,  2
	v_TotalTikraDisc			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  32: 162,  9
	v_TotalCouponDisc			= GetInt	(&PosInBuff,  9				); CHECK_ERROR();	//  33: 171,  9
	v_PharmPtnCode				= GetShort	(&PosInBuff,  4				); CHECK_ERROR();	//  34: 180,  4

	// DonR 20Mar2023 User Story #432608: For Transaction Version 4, add two order-number fields, plus a
	// new "reserved" field for future use. Magento Order Number is the internal order number created by
	// Magento for the Virtual Pharmacy system; Online Order Number links to our own Online Orders table.
	if (VersionNumber > 3)
	{
		MagentoOrderNum			= GetLong	(&PosInBuff, 10				); CHECK_ERROR();	//  35: 184, 10
		OnlineOrderNum_6005		= GetLong	(&PosInBuff, 10				); CHECK_ERROR();	//  36: 194, 10
		GetNothing							(&PosInBuff, 20				); 					//  37: 204, 20
	}

	v_NumOfDrugLinesRecs		= GetShort	(&PosInBuff,  2				); CHECK_ERROR();	//  38: 224,  2

	// Get drug lines. (429 characters/line, not including doctor-prescriptions of 45 characters each.)
	// DonR 28Feb2011: If this is a sale deletion with 99 as the number of drug lines, we don't want
	// to read drug-line data from the incoming message; it's a request for full cancellation of the
	// sale without specifying what drugs were sold (perhaps because the pharmacy doesn't know).
	if ((v_ActionType != SALE_DELETION) || (v_NumOfDrugLinesRecs != 99))
	{
		for (i = 0; i < v_NumOfDrugLinesRecs; i++)
		{
			phDrgs[i].LineNumber		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  39: 226,  2

			// DonR 02Mar2016: For now, Largo Codes are only five digits even though the message space for them
			// has expanded. Since six-digit Largo Codes blow up transmission of tables to AS/400 (and we've seen
			// this happen only for Doctor Largo Code), catch this problem right at the outset and reject the
			// transaction.
			// DonR 15Jul2024 User Story #349368: Largo Codes are being expanded to 6 digits on AS/400.
			// Accordingly, adjust the "sanity check" to allow one more digit.
			phDrgs[i].Orig_Largo_Code	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  40: 228,  9
			if (phDrgs[i].Orig_Largo_Code > 999999)
				SET_ERROR (ERR_WRONG_FORMAT_FILE);

			phDrgs[i].DrugCode			= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  41: 237,  9
			phDrgs[i].SubstPermitted	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  42: 246,  2
			phDrgs[i].Units				= GetInt	(&PosInBuff,  5			); CHECK_ERROR();	//  43: 248,  5
			phDrgs[i].Op				= GetInt	(&PosInBuff,  5			); CHECK_ERROR();	//  44: 253,  5
			phDrgs[i].use_instr_template= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  45: 258,  1
			phDrgs[i].how_to_take_code	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  46: 259,  3

			// NumPerDose is now in hundredths - so 1 is sent as 000100, and 2 1/2 is sent as 000250.
			phDrgs[i].NumPerDose		= GetInt	(&PosInBuff,  6			); CHECK_ERROR();	//  47: 262,  6

			GetString	(&PosInBuff, phDrgs[i].unit_code,		  3			); CHECK_ERROR();	//  48: 268,  3

			phDrgs[i].DosesPerDay		= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  49: 271,  1
			phDrgs[i].Duration			= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  50: 272,  3
			phDrgs[i].course_treat_days	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  51: 275,  3

			if (VersionNumber > 0)
			{
				phDrgs[i].course_len_days	= GetShort	(&PosInBuff,  3		); CHECK_ERROR();	//  52: 278,  3
			}

			phDrgs[i].course_len		= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  53: 281,  3
			GetString	(&PosInBuff, phDrgs[i].course_len_units, 10			); CHECK_ERROR();	//  54: 284, 10
			GetString	(&PosInBuff, phDrgs[i].days_of_week,	 20			); CHECK_ERROR();	//  55: 294, 20
			GetString	(&PosInBuff, phDrgs[i].times_of_day,	 (VersionNumber > 0) ? 200 : 40	); CHECK_ERROR();	// 56: 294, CHANGE FROM 40 TO 200.
			GetString	(&PosInBuff, phDrgs[i].side_of_body,	 10			); CHECK_ERROR();	//  57: 514, 10
			phDrgs[i].LinkToAddition	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  58: 524,  9
			phDrgs[i].OpDrugPrice		= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  59: 533,  9
			phDrgs[i].SupplierDrugPrice	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  60: 542,  9
			phDrgs[i].MemberPtnCode		= GetShort	(&PosInBuff,  4			); CHECK_ERROR();	//  61: 551,  4
			phDrgs[i].FixedPrice		= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  62: 555,  9
			phDrgs[i].MemberDiscPC		= GetShort	(&PosInBuff,  5			); CHECK_ERROR();	//  63: 564,  5
			phDrgs[i].TotalDrugPrice	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  64: 569,  9
			phDrgs[i].TotalPtn			= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  65: 578,  9
			phDrgs[i].DrugDiscountAmt	= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  66: 587,  9

			// Normally, this can be ignored - since it's written to the DB by Trn. 6003.
			phDrgs[i].ParticipMethod	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  67: 596,  2

			phDrgs[i].StockOP			= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  68: 598,  7
			phDrgs[i].StockUnits		= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  69: 605,  7
			phDrgs[i].DrugDiscountCode	= GetShort	(&PosInBuff,  3			); CHECK_ERROR();	//  70: 612,  3
			phDrgs[i].InsuranceUsed		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  71: 615,  2
			phDrgs[i].DrugTikraType		= GetChar	(&PosInBuff				); CHECK_ERROR();	//  72: 617,  1
			phDrgs[i].DrugSubsidized	= GetChar	(&PosInBuff				); CHECK_ERROR();	//  73: 618,  1
			phDrgs[i].InHealthBasket	= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  74: 619,  1

			// If Version > 0, Electronic Pr. Status gets sent with length = 2.
			phDrgs[i].ElectPrStatus		= GetShort	(&PosInBuff,  (VersionNumber > 0) ? 2 : 1	); CHECK_ERROR();	// 75: 620,  2

			phDrgs[i].DocIDType			= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  76: 622,  1
			phDrgs[i].DocID				= GetInt	(&PosInBuff,  9			); CHECK_ERROR();	//  77: 623,  9
			phDrgs[i].PrescSource		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  78: 632,  2
			phDrgs[i].DocFacility		= GetInt	(&PosInBuff,  7			); CHECK_ERROR();	//  79: 634,  7

			// DonR 29Oct2018: Fixed version number - Version 2 already got rid of Visit Number.
			if (VersionNumber > 1)
			{
				phDrgs[i].NumCourses		= GetShort	(&PosInBuff,  3		); CHECK_ERROR();	//  80: 641,  3	(Treatment Length in Course units)
				phDrgs[i].IsDigital			= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  81: 644,  1
				phDrgs[i].VoucherAmtUsed	= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  82: 645,  6 (DonR 07Jun2021 User Story #163882 - flip negative for deletions!)
				phDrgs[i].BarcodeScanned	= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  83: 651,  1

				phDrgs[i].VisitNumber		= 0L;
			}
			else
			{
				phDrgs[i].VisitNumber		= GetLong	(&PosInBuff, 11		); CHECK_ERROR();	// (78: 621, 11) ==> Change to 3 (num_courses) + 8 (reserved) for Version > 0

				phDrgs[i].IsDigital			= 0;
				phDrgs[i].BarcodeScanned	= 0;
			}

			phDrgs[i].use_instr_changed	= GetShort	(&PosInBuff,  1			); CHECK_ERROR();	//  84: 652,  1

			// DonR 21Mar2023 User Story #432608: For Transaction Version Number 4, add eight new
			// fields plus a 20-byte reserve (169 bytes total).
			if (VersionNumber > 3)
			{
				GetString	(&PosInBuff, phDrgs[i].UsageInstrGiven,	100		); CHECK_ERROR();	//  85: 653, 100

				// An explanation of new OTC price/sale/discount numbers, courtesy of Iris Shaya:
				// 1) MaccabiOtcPrice is a discount price, normally set in the price_list table.
				// 2) SalePkgPrice, when present, is normally lower than the Maccabi price; it's
				//    set by the sale tables and typically has a time limit.
				// 3) "Buy1Get1" is a *further* reduction; it can be in the form of "Buy 1, get
				//    the second at a lower price," or it can be "Buy Item X, get Y at a special
				//    price." Basically, it's some form of "basket" discount *on top of* any
				//    Maccabi Price and Sale Price discounts.
				// 4) "By Hand" reductions are *additional* reductions given on a case-by-case
				//    basis by the pharmacy; for example, if the price tag on an item shows a
				//    lower price than any of the discount prices in the database, the pharmacy
				//    is normally obligated to sell the item at that price.
				// 5) The two Sale Number values refer to the Sale tables that give SalePkgPrice
				//    and/or Buy1Get1 discounts.
				// 6) IsConsignment indicates that this is an item normally available only at
				//    Maccabi pharmacies, but sold by specific private pharmacies (all SuperPharm,
				//    I believe) "on consignment". Since the private pharmacy is acting basically
				//    as an agent for MaccabiPharm, I believe the "consignment" (a.k.a. "consignatzia")
				//    item will be sold with terms as if it were being sold at a Maccabi pharmacy.
				phDrgs[i].MaccabiOtcPrice	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  86: 753,   9
				phDrgs[i].SalePkgPrice		= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  87: 762,   9
				phDrgs[i].SaleNum4Price		= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  88: 771,   6
				phDrgs[i].SaleNumBuy1Get1	= GetInt	(&PosInBuff,  6		); CHECK_ERROR();	//  89: 777,   6
				phDrgs[i].Buy1Get1Savings	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  90: 783,   9
				phDrgs[i].ByHandReduction	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	//  91: 792,   9
				phDrgs[i].IsConsignment		= GetShort	(&PosInBuff,  1		); CHECK_ERROR();	//  92: 801,   1
				GetNothing								(&PosInBuff, 20		); 					//  93: 802,  20	(Reserved for expansion)
			}	// DonR 21Mar2023 User Story #432608 end.

			phDrgs[i].NumDocRxes		= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  94: 822,  2

			// Set starting point for this drug-line in the Doctor Prescription array.
			if (phDrgs[i].NumDocRxes > 0)
				phDrgs[i].FirstRx = MaxRx;
			else
				phDrgs[i].FirstRx = 0;	// Should already be zero (pointing to a blank array element), but let's be sure!

			// Read in the specific prescriptions that are combined in this drug-line. (45 characters/Rx)
			// DonR 09Jul2015: Per Iris Shaya, for deletions we don't want to read doctor-prescription stuff
			// from the incoming transaction even if the pharmacy has supplied them.
			if (v_ActionType == SALE_DELETION)
			{
				for (Rx = 0; Rx < phDrgs[i].NumDocRxes; Rx++)
				{
					if (VersionNumber > 0)
					{
						GetNothing	(&PosInBuff,  21);	// Visit Number and OP/Units Unsold: 11 + 5 + 5.
					}

					GetNothing	(&PosInBuff,  24);	// PrID, FromDate, Units, OP: 6 + 8 + 5 + 5.
				}

				phDrgs[i].NumDocRxes = phDrgs[i].FirstRx = 0;
			}	// Ignore incoming doctor-prescription information for deletions.

			else
			{	// We're not deleting, so go ahead and read the doctor-prescription data.
				for (Rx = 0; Rx < phDrgs[i].NumDocRxes; Rx++, MaxRx++)
				{
					if (VersionNumber > 0)
					{
						DocRx [MaxRx].VisitNumber	= GetLong	(&PosInBuff, 11	); CHECK_ERROR ();	//  95: 824, 11
					}
					else
					{
						DocRx [MaxRx].VisitNumber	= phDrgs[i].VisitNumber;
					}

					DocRx [MaxRx].PrID		= GetInt	(&PosInBuff,  6			); CHECK_ERROR ();	//  96: 835,  6
					DocRx [MaxRx].FromDate	= GetInt	(&PosInBuff,  8			); CHECK_ERROR ();	//  97: 841,  8
					DocRx [MaxRx].Units		= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	//  98: 849,  5
					DocRx [MaxRx].OP		= GetInt	(&PosInBuff,  5			); CHECK_ERROR ();	//  99: 854,  5

					if (VersionNumber > 0)
					{
						// These are the numbers that were sent in Transaction 6001; comparing them with
						// OP/Units Sold will tell us if this is a full or a partial sale.
						DocRx [MaxRx].UnitsUnsold	= GetInt	(&PosInBuff,  5	); CHECK_ERROR ();	// 100: 859,  5
						DocRx [MaxRx].OP_Unsold		= GetInt	(&PosInBuff,  5	); CHECK_ERROR ();	// 101: 864,  5
					}

				}	// Loop through doctor prescriptions combined in this drug line.

			}	// We're not deleting, so go ahead and read the doctor-prescription data.

			// DonR 01Feb2024 User Story #540234: Read in cannabis product details. Note that at least
			// for now, we will read this infomation for deletions the same as we do for sales.
			// NOTE: Offsets assume NO doctor prescriptions. For each doctor prescription, add 45 bytes.
			// Also note: Each Cannabis line is 79 bytes.
			if (VersionNumber > 4)
			{
				phDrgs[i].NumCannabisProducts	= GetShort	(&PosInBuff,  2			); CHECK_ERROR();	//  102: 824,  2

				for (Product = 0; Product < phDrgs[i].NumCannabisProducts; Product++, TotalNumCannabisProducts++)
				{
					CannabisProduct [TotalNumCannabisProducts].DrugLineSubscript		= i;
					CannabisProduct [TotalNumCannabisProducts].cannabis_product_code	= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 103: 826,  9
					CannabisProduct [TotalNumCannabisProducts].cannabis_product_barcode	= GetLong	(&PosInBuff, 13	); CHECK_ERROR ();	// 104: 835, 13
					CannabisProduct [TotalNumCannabisProducts].op						= GetShort	(&PosInBuff,  5	); CHECK_ERROR ();	// 105: 848,  5
					CannabisProduct [TotalNumCannabisProducts].units					= GetShort	(&PosInBuff,  5	); CHECK_ERROR ();	// 106: 853,  5
					CannabisProduct [TotalNumCannabisProducts].price_per_op				= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 107: 858,  9
					CannabisProduct [TotalNumCannabisProducts].product_sale_amount		= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 108: 867,  9
					CannabisProduct [TotalNumCannabisProducts].product_ptn_amount		= GetInt	(&PosInBuff,  9	); CHECK_ERROR ();	// 109: 876,  9
					GetNothing	(&PosInBuff,  20);																						// 110: 885, 20 Reserved for future use.
				}
			}

			// DonR 11Jan2021: Times_of_day is only 40 characters in the database, at least for now; to
			// avoid database errors (which I see in MS-SQL testing, although not in Informix), truncate
			// the field so the database server doesn't kvetch.
			// DonR 17Nov2021 BUG FIX: The change below was in "normal" Trn. 6005, but was *not* made
			// in the spool version - and I believe it was causing some rows not to be added/updated.
			// DonR 18Apr2023 User Story #432608: Times of Day is now 200 characters in the database,
			// so there's no need to truncate it anymore.
//			phDrgs[i].times_of_day [40] = (char)0;

			// DonR 20Feb2022: Just to make things neat and tidy in the database, strip
			// leading and trailing spaces from Course Length Units.
			StripAllSpaces (phDrgs[i].course_len_units);

		}	// Drug-line reading loop.
	}	// NOT a deletion with 99 as number-of-drugs.

	// DonR 02Jun2021 User Story #163882: Instead of unfilled prescriptions (which was never put into
	// real-world use), get a list of vouchers applied by the pharmacy to each relevant drug line.
	NumVouchers											= GetShort	(&PosInBuff,  2		); CHECK_ERROR ();	// 111: 950,  2 (assuming 45 bytes for 1 Rx)

//	if (!TikrotProductionMode) GerrLogMini (GerrId, "\nNum_vouchers = %d.", NumVouchers);

//	// Read in unfilled (or partially-filled?) prescriptions. For now at least, we
//	// aren't actually going to do anything with them.
//	// WORKINGPOINT: WHAT DO WE DO WITH UNFILLED-PRESCRIPTION INFORMATION?
	// Each voucher uses 73 bytes.
	for (VoucherNum = 0; VoucherNum < NumVouchers; VoucherNum++)
	{
		Voucher [VoucherNum].voucher_num				= GetLong	(&PosInBuff, 11		); CHECK_ERROR ();	// 112: 952, 11
		GetString		(&PosInBuff, Voucher [VoucherNum].voucher_type,			 15		); CHECK_ERROR ();	// 113: 963, 15
		Voucher [VoucherNum].voucher_discount_given		= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 114: 978,  9
		Voucher [VoucherNum].voucher_amount_remaining	= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 115: 987,  9
		Voucher [VoucherNum].original_voucher_amount	= GetInt	(&PosInBuff,  9		); CHECK_ERROR ();	// 116: 996,  9

		GetNothing	(&PosInBuff,  20);	// Reserved for future use											   117: 1005, 20
//
//		if (!TikrotProductionMode)
//			GerrLogMini (GerrId, "Voucher #%d/%d: Discount %d, remaining %d, orig. %d.", (VoucherNum + 1), NumVouchers, Voucher [VoucherNum].voucher_discount_given,
//						 Voucher [VoucherNum].voucher_amount_remaining, Voucher [VoucherNum].original_voucher_amount);

// Previously, there was an idea of including unfilled prescriptions here. As of Mar2023, this has never been
// implemented, and it doesn't appear to be a "live" idea at present.
//		UnfilledRx [Rx].PrID			= GetInt	(&PosInBuff,  6			); CHECK_ERROR ();	//  92: 673,  6
//		UnfilledRx [Rx].FromDate		= GetInt	(&PosInBuff,  8			); CHECK_ERROR ();	//  93: 679,  8
//		UnfilledRx [Rx].Doctor_Largo	= GetInt	(&PosInBuff,  9			); CHECK_ERROR ();	//  94: 687,  9
//		UnfilledRx [Rx].Filled_Status	= GetShort	(&PosInBuff,  1			); CHECK_ERROR ();	//  95: 696,  1
//		UnfilledRx [Rx].Reason_Code		= GetShort	(&PosInBuff,  3			); CHECK_ERROR ();	//  96: 697,  3
	}


	// Read in additional drug sales being charged to the same Credit Line.
	// NIU (i.e. the number of lines should always be zero) as of 24May2010.
	// DonR 27Mar2023 User Story #232220: This code is now going into use.
	NumOtherSales = GetShort (&PosInBuff,  2); CHECK_ERROR();									// 118: 1025,  2

	for (OtherSaleNum = 0; OtherSaleNum < NumOtherSales; OtherSaleNum++)
	{
		OtherSaleID			[OtherSaleNum]	= GetInt	(&PosInBuff,  9		); CHECK_ERROR();	// 119: 1027,  9
		OtherSaleCredLine	[OtherSaleNum]	= GetShort	(&PosInBuff,  2		); CHECK_ERROR();	// 120: 1036,  2
		GetNothing	(&PosInBuff,  15);	// Reserved for future use								   121: 1038, 15
//		OtherSalePmtType	[OtherSaleNum]	= GetShort	(&PosInBuff,  2		); CHECK_ERROR();	// 121: 1038,  2 NOT IN USE, AT LEAST FOR NOW.
		OtherSalePmtType	[OtherSaleNum]	= v_PaymentType;	// At least until we get this added to the list.
		// Iris may want to add a new Number of Payments value here.

		// DonR 04Mar2024 User Story #232220: SuperPharm will, apparently, send the last 6005 in
		// the series with Credit Type 99 (= unpaid) and then include the last Prescription ID
		// in this list of transactions to mark "paid". In order to avoid duplicate updates and
		// other potential problems, change Credit Type here if the "other sale" is in fact the
		// current sale. In this case, we'll set the "other sale ID" to zero so we won't update
		// it again at the end.
		if ((v_CreditYesNo						== 99)					&&
			(OtherSaleID		[OtherSaleNum]	== v_RecipeIdentifier)	&&
			(OtherSaleCredLine	[OtherSaleNum]	!= 99))
		{
			v_CreditYesNo				= OtherSaleCredLine	[OtherSaleNum];
			v_PaymentType				= OtherSalePmtType	[OtherSaleNum];
			OtherSaleID [OtherSaleNum]	= 0;
		}
	}	// Loop through "other sales" reported by pharmacy.


	// Get amount of input not eaten.
	// DonR 27Jul2021: Use new ChckInputLenAllowTrailingSpaces() function, which will return a
	// FILE_TOO_LONG error only if the left-over buffer has something other than spaces. This
	// should allow previous transactions to be "replayed" easily for testing and problem
	// diagnoses.
//	ChckInputLen (TotalInputLen - (PosInBuff - IBuffer));
	ChckInputLenAllowTrailingSpaces (PosInBuff, (TotalInputLen - (PosInBuff - IBuffer)));
	CHECK_ERROR ();

	// Copy values to ssmd_data structure.
	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
	ssmd_data_ptr->member_id		= v_MemberID;
	ssmd_data_ptr->member_id_ext	= v_IDCode;

	// Validate Date and Time.
	ChckDate (SaleDate); CHECK_ERROR_T ("6005-Spool: Check Delivery Date");	 
	ChckTime (SaleTime); CHECK_ERROR_T ("6005-Spool: Check Delivery Time");

	// DonR 05Feb2023 User Story #232220: Set paid-for flag based on Credit Used.
	// By default, any Credit Used value means that the transaction *has* been
	// paid for; the exception is 99, which means that the payment method for this
	// transaction has not yet been decided.
	paid_for = (v_CreditYesNo == 99) ? 0 : 1;

	// DonR 09May2024 User Story #309732: If this transaction is just marking already-delivered
	// stuff as "paid for", force Number of Drug Lines to zero.
	if (v_ActionType == MARK_AS_PAID)
	{
		v_NumOfDrugLinesRecs = 0;	// No matter what the pharmacy sent!
	}

	// DonR 24Aug2020: In 6005-spool, pharmacies sometimes send zero for the Sale Time. This
	// doesn't cause problems on Linux, but apparently some AS/400 queries don't work if
	// Sale Time is zero. So if we got a zero, add one second.
	if (SaleTime == 0)
		SaleTime = 1;	// = 00:00:01

	// Fix the Doctor Facility Code the way we do in Trn. 6003.
	// DonR 10Jun2015: While we're at it, set up the Prescription Source value that
	// will be written to the prescriptions table.
	for (i = 0; i < v_NumOfDrugLinesRecs; i++)
	{
		if (phDrgs[i].DocFacility != 0)
		{
			phDrgs[i].DocFacility -= 990000;	// The initial "99" gets thrown away.

			if ((phDrgs[i].DocFacility < 1) || (phDrgs[i].DocFacility > 9999))
			{
				phDrgs[i].DocFacility = 0;	// So we don't blow anything up sending bogus values to the DB or AS/400.
			}
		}

		// DonR 10Jun2015: Set up header-level Prescription Source variable. If the drug lines all
		// have the same Prescription Source, we'll just replicate that in the header (prescriptions/
		// RK9021P); otherwise, we'll write a generic "mixed prescription sources" value of 99.
		// The ternary operator below works as follows: the first time we see a non-zero Prescription
		// Source, we set HeaderPrescSource equal to that value. After that, if we see any *other*
		// non-zero Prescription Source, we'll assign the value 99.
		if ((phDrgs[i].PrescSource != HeaderPrescSource) && (phDrgs[i].PrescSource > 0))
			HeaderPrescSource = (HeaderPrescSource) ? RECIP_SRC_MIXED_SOURCES : phDrgs[i].PrescSource;
	}


	// SQL Retry Loop.
	for (tries = 0, reStart = MAC_TRUE; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		// Initialize response variables.
		v_ErrorCode					= NO_ERROR;
		reStart						= MAC_FALS;
		max_drug_date				= 0;

		memset ((char *)&dbDrgs, 0, sizeof (dbDrgs));

		// Get a new prescription id in case we have to add a new row.
		state = GET_PRESCRIPTION_ID (&v_RecipeIdentifier1);

		if (state != NO_ERROR)
		{
			SetErrorVar (&v_ErrorCode, state);

			GerrLogReturn (GerrId,
						   "Can't get PRESCRIPTION_ID for 6005 spool - error %d.",
						   state);
		}


		// DonR 24May2022 BUG FIX: If this is a sale deletion and we're retrying the transaction,
		// re-initialize various variables and arrays. Otherwise the transaction may think it
		// finished successfully, but in fact no sold drugs were deleted at all.
		// DonR 18Jul2023: Disabled the log message, since the fix has been running OK for over a year.
		if ((tries > 0) && (v_ActionType == SALE_DELETION))
		{
//			GerrLogMini (GerrId, "6005-spool re-initializing deletion PrID %d for %d drugs; MaxRx was %d, tries = %d, DeletedPrID = %d.",
//						 (v_RecipeIdentifier > 0) ? v_RecipeIdentifier : v_RecipeIdentifier1, v_NumOfDrugLinesRecs, MaxRx, tries, v_DeletedPrID);

			// Remember that for online deletions, even if the pharmacy sent doctor-prescription
			// data (which they don't), we ignore it and read doctor prescriptions from the
			// database. So if we're retrying, set everything back to zero.
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				phDrgs[i].NumDocRxes = phDrgs[i].FirstRx = 0;
			}

			MaxRx = 1;	// Reminder: Element 0 is blank; real data is loaded starting at 1.
			memset ((char *)DocRx, 0, sizeof (DocRx));
		}


		// Dummy loop to avoid GOTO.
		do		// Exiting from LOOP will send the reply to pharmacy.
		{
			// Load pharmacy data - note that we don't check for open-status in spooled mode.
			v_ErrorCode		= IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);
			v_PriceListCode	= (v_ErrorCode == MAC_OK) ? Phrm_info.price_list_num : 0;


			// Test temporary members.
		    if (v_IDCode == 7)
		    {
				ExecSQL (	MAIN_DB, READ_tempmemb,
							&v_TempIdentifCode,			&v_TempMembIdentification,	&v_TempMemValidUntil,
							&v_MemberID,				END_OF_ARG_LIST										);

				Conflict_Test (reStart);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					// Since this is the spool processor, don't do anything - just
					// continue working.
				}

				else
				if (SQLERR_error_test ())
				{
					v_ErrorCode = ERR_DATABASE_ERROR;
				}

				else	// Use the values from tempmemb only if row was
						// actually read from the database.
						// DonR 20Oct2013: If the current action is a sale deletion, an expired
						// temporary card is still usable.
				if ((v_TempMemValidUntil >= SysDate) || (v_ActionType == SALE_DELETION))
				{
				    v_IDCode	= v_TempIdentifCode;
				    v_MemberID	= v_TempMembIdentification;
				}
			}	// Temporary Member test.

			
			// Test Maccabi members.
			if (v_MemberBelongCode == MACABI_INSTITUTE)
			{
				if (v_MemberID == 0)
				{
					v_ErrorCode				= ERR_MEMBER_ID_CODE_WRONG;

					v_MemberCreditFlag		= 0;
					Member.maccabi_code		= 0;
					Member.maccabi_until	= 0;
					v_MemberSpecPresc		= 0;
				}
				else
				{
					// DonR 13May2020 CR #31591: Add new Member-on-Ventilator flag. This is
					// currently stored in the old column "asaf_code" (which was sent from
					// AS/400 but never used for anything); when we switch to MS-SQL, the
					// column should be renamed.
					ExecSQL (	MAIN_DB, READ_members_full,
								&v_MemberFamilyName,		&v_MemberFirstName,				&Member.date_of_bearth,
								&Member.maccabi_code,		&v_MemberSpecPresc,				&Member.maccabi_until,
								&Member.payer_tz,			&Member.payer_tz_code,			&v_MemberGender,
								&MemberDefaultPhone,		&MemberHouseNum,				&MemberStreet,
								&MemberCity,				&MemberZipCode,					&Member.insurance_type,

								&Member.keren_mac_code,		&Member.keren_mac_from,			&Member.keren_mac_until,
								&Member.mac_magen_code,		&Member.mac_magen_from,			&Member.mac_magen_until,
								&Member.yahalom_code,		&Member.yahalom_from,			&Member.yahalom_until,
								&Member.carry_over_vetek,	&Member.keren_wait_flag,		&illness_bitmap,
								&Member.card_date,			&Member.update_date,			&Member.update_time,

								&Member.authorizealways,	&Member.updated_by,				&Member.check_od_interact,
								&v_MemberCreditFlag,		&sq_maxdrugdate,				&v_MemberDiscPercent,
								&v_insurance_status,		&v_FamilyHeadTZ,				&v_FamilyHeadTZCode,
								&Member.has_tikra,			&Member.has_coupon,				&v_in_hospital,
								&Member.VentilatorDiscount,	&Member.darkonai_type,			&Member.force_100_percent_ptn,

								&Member.darkonai_no_card,	&Member.has_blocked_drugs,		&Member.died_in_hospital,
								&Member.mahoz,				&Member.dangerous_drug_status,

								&v_MemberID,				&v_IDCode,						END_OF_ARG_LIST					);

					Conflict_Test (reStart);

					// DonR 04Dec2022 User Story #408077: Use a new function to set some Member flags and values.
					SetMemberFlags (SQLCODE);

					// DonR 20Nov2007: If member is not found, continue - with spooled
					// sales, we can't just throw them away!
					if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
					{
						v_MemberCreditFlag		= 0;
						Member.maccabi_code		= 0;
						Member.maccabi_until	= 0;
						v_MemberSpecPresc		= 0;	// DonR 20Nov2007: Added another default.

						// DonR 12Dec2021 BUG FIX: If the member ID is zero, set defaults for new member parameters.
						Member.VentilatorDiscount		=
						Member.darkonai_type			=
						Member.force_100_percent_ptn	=
						Member.darkonai_no_card			=
						Member.has_blocked_drugs		=
						Member.died_in_hospital			= 0;
					}
					else
					{
						// See if there were problems other than deleted-row or not-found.
						if (SQLERR_error_test ())
						{
							v_ErrorCode = ERR_DATABASE_ERROR;
							break;
						}

						// DonR 20Nov2007: Check for member rights only if we actually read
						// a row from the Members table.
						else
						{
							// Check member eligibility.
							// DonR 30Nov2022 User Story #408077: Use new macro MEMBER_INELIGIBLE (defined in
							// MsgHndlr.h) to decide if this member is eligible.
							if (MEMBER_INELIGIBLE)
							{
								// DonR 29Jul2007: If we've failed to read the Member information,
								// don't overwrite the "bad member ID" error.
								if (v_ErrorCode != ERR_MEMBER_ID_CODE_WRONG)
								{
									v_ErrorCode = ERR_MEMBER_NOT_ELEGEBLE;
								}
							}	// Member is not eligible for service.
						}	// Good read of member.
					}	// We didn't get a member-not-found error.
				}	// Member Identification is non-zero.
			}	// Member belongs to Maccabi.


			// DonR 20Nov2007: For spooled sales to non-Maccabi members, provide
			// defaults for the values that would normally come from the Members
			// table.
			else
			{
				v_MemberCreditFlag		= 0;
				Member.maccabi_code		= 0;
				Member.maccabi_until	= 0;
				v_MemberSpecPresc		= 0;
			}

			// DonR 04Jul2016: Pharmacies sometimes send a bunch of identical spooled transactions as
			// a single batch; to make sure the redundancy check works properly, we want to make sure
			// that we process only one spooled sale at a time for any given pharmacy. the new function
			// GetSpoolLock() ensures that only one instance of sqlserver.exe can be processing a spooled
			// transaction at any given moment.
			// DonR 22May2025: We have recently been seeing some database deadlocks, particularly early
			// in the morning; and I see that although the same pharmacy sent multiple spooled 6005s
			// (from different terminals, at least in some cases) at the same time, there were no log
			// messages from GetSpoolLock(). So I beefed up GetSpoolLock() a bit, forcing its isolation
			// to "repeatable read", and I'm also moving the call up here, to before we do any lookups
			// to the prescriptions/prescription_drugs tables.
			// DonR 28Jul2025: Adding Transaction Number / Spool Flag to GetSpoolLock(), for diagnostics
			// only - since I'm adding a call to this function in Transaction 2086 (which is apparently
			// getting a lock on pharmacy_daily_sum and causing deadlocks).
			GetSpoolLock (v_PharmNum, 6005, 1);


			// Special processing for deletions.
			if (v_ActionType == SALE_DELETION)
			{
				// DonR 07Feb2011: If pharmacy didn't supply a Presciption ID to delete, try to identify
				// the original sale from the other parameters supplied.
				// DonR 30Jun2016: Added del_flg to WHERE clause, since there may be duplicate rows when
				// sales have arrived via spool.
				// DonR 16Jun2025: Execute these two queries in "dirty" mode to avoid deadlocks (one of
				// which happened on 13 June 2025).
				if (v_DeletedPrID == 0)
				{
					SET_ISOLATION_DIRTY;

					ExecSQL (	MAIN_DB, READ_Find_Prescription_ID_to_delete,
								&v_DeletedPrID,
								&v_MemberID,				&v_DeletedPrPharm,
								&v_DeletedPrYYMM,			&v_DeletedPrPhID,
								&DRUG_DELIVERED,			&v_IDCode,
								&v_MemberBelongCode,		END_OF_ARG_LIST				);

//GerrLogMini (GerrId, "Trn 6005-spool: Read v_DeletedPrID %d from DB, SQLCODE = %d.", v_DeletedPrID, SQLCODE);

					// DonR 31Mar2011: If the prescription wasn't found, the SQL above doesn't necessarily
					// return an error - so if the MIN(prescription_id) value is in fact bogus, force an
					// SQL error by actually trying to read the prescriptions row.
					if (SQLCODE == 0)
					{
						bool	DeletedPrFoundInDatabase = false;

						ExecSQL (	MAIN_DB, READ_prescriptions_validate_deleted_pr_ID,
									&DeletedPrFoundInDatabase, &v_DeletedPrID, END_OF_ARG_LIST			);

						SQLERR_error_test ();
if (!TikrotProductionMode)
	GerrLogMini (GerrId, "Trn 6005-spool: Checked v_DeletedPrID %d from DB, found = %d, SQLCODE = %d.",
						v_DeletedPrID, DeletedPrFoundInDatabase, SQLCODE);

						if (!DeletedPrFoundInDatabase)
						{
GerrLogMini (GerrId, "Trn 6005-spool: Checked v_DeletedPrID %d from DB, found = %d, SQLCODE = %d.",
	v_DeletedPrID, DeletedPrFoundInDatabase, SQLCODE);
							v_DeletedPrID = 0;
						}
					}

					if (SQLCODE != 0)
						v_DeletedPrID = 0;

					// Go back to normal "committed" datbase isolation level.
					SET_ISOLATION_COMMITTED;
				}	// Need to get ID of prescription being deleted.


				// Read in Subsidy Amount from the prescriptions row to be deleted. (Do we need more fields?)
				// DonR 31Mar2011: Yes we do - added (total) Tikra Discount.
				// DonR 06Sep2011: Read in del_flg from prescription to be deleted, so we know if it's
				// already been deleted.
				// DonR 01Mar2012: Added Prescription Source, Doc ID Type, and Doctor ID to fields copied
				// from original sale.
				// DonR 27Mar2012: Added macabi_centers_num (= Client Location Code) as well.
				// DonR 20Aug2020: Added presc_source to columns read.
				// DonR 15May2025: If v_DeletedPrID doesn't have a non-zero value, don't bother trying to
				// look up the transaction in the prescriptions table. Also, I've beefed up the isolation
				// level in GetSpoolLock(), and that will - I hope! - solve the problem of simultaneous
				// spooled transactions from the same pharmacy deadlocking. Accordingly, I've remarked out
				// my earlier "fix" that would degrade isolation on this particular SELECT to "dirty" - it
				// was never more than a workaround at best.
				if (v_DeletedPrID > 0)
				{
//					SET_ISOLATION_DIRTY;

					ExecSQL (	MAIN_DB, TR6005spool_READ_deleted_prescriptions_row_values,
								&v_DeletedPrSubAmt,		&v_DeletedPrTikAmt,
								&v_DeletedClLocCode,	&v_DeletedPrDelFlg,
								&v_DeletedPrSrc,
								&v_DeletedPrID,			END_OF_ARG_LIST							);
				}
				else FORCE_NOT_FOUND;

//GerrLogMini (GerrId, "Trn 6005-spool: Read deletion numbers %d / %d from DB, SQLCODE = %d.", v_DeletedPrSubAmt, v_DeletedPrTikAmt, SQLCODE);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					// Do (almost) nothing - we're in spool mode, so there's no point in throwing unnecessary errors.
					// On the other hand, make sure that Total Tikra Discount and Total Coupon Amount are set to zero.
					// DonR 06Sep2011: Zero out Deleted PR del_flg as well.
					v_DeletedPrDelFlg = v_DeletedPrSubAmt = v_DeletedPrTikAmt = v_DeletedClLocCode = 0;

					// DonR 27Nov2025: If we didn't find the row to delete, we don't want to log a DB error.
					FORCE_SQL_OK;
				}
				else
				{
					if (SQLERR_error_test ())
					{
						v_ErrorCode = ERR_DATABASE_ERROR;
						break;
					}
					else
					{
						// Successful read.

						// Override what pharmacy sent only if pharmacy sent zero.
						// DonR 01Mar2012: Added three additional fields to be copied if necessary.
						// DonR 27Mar2012: Added Client Location Code (= macabi_centers_num); also changed
						// condition for copying Total Coupon Discount and Total Tikra Discount, which should
						// be copied based on the pharmacy's having sent '99' for the number of drug lines
						// and *not* based on what amounts the pharmacy sent in the deletion request.
						// DonR 20Apr2015: Total Tikra Discount and Total Coupon Discount should be negative
						// (if non-zero) for deletions - so we need to "flip" these numbers when we take them
						// from the original sale row.
						if (v_NumOfDrugLinesRecs	== 99)	// DonR 27Mar2012.
						{
							v_TotalCouponDisc	= 0 - v_DeletedPrSubAmt;
							v_TotalTikraDisc	= 0 - v_DeletedPrTikAmt;
						}

						if (v_ClientLocationCode	== 0)
							v_ClientLocationCode = v_DeletedClLocCode;	// DonR 27Mar2012.

						// DonR 20Aug2020: If we read a non-zero Prescription Source from the prescriptions
						// row to be deleted AND the pharmacy didn't supply drug lines with non-zero
						// Prescription Source values, use the Prescription Source from the original sale.
						if ((v_DeletedPrSrc > 0) && (HeaderPrescSource == 0))
							HeaderPrescSource = v_DeletedPrSrc;
					}
				}	// Something other than not-found.

//				// DonR 18May2025: Go back to normal "committed" datbase isolation level.
//				SET_ISOLATION_COMMITTED;
//
				// If pharmacy did not supply a list of drugs to delete, read in all the drugs from
				// the original sale. Note that if pharmacy sends zero for the number of drugs to
				// delete, we do NOT automatically delete the whole prior sale - instead, we just
				// throw an error.
				if (v_NumOfDrugLinesRecs == 99)	// Pharmacy has requested full deletion of prior sale.
				{
					v_NumOfDrugLinesRecs = 0;	// List is actually empty - so far.


					// DonR 10Apr2011: Declare cursor only when it's needed.
					DeclareAndOpenCursorInto (	MAIN_DB, TR6005spool_deldrugs_cur,
												&v_DrugCode,			&v_DeletedPrOP,			&v_DeletedPrUnits,
												&v_DeletedPrPtn,		&v_DeletedPrPrcCode,	&v_DeletedPrPrtMeth,
												&v_DeletedPrMemPrc,		&v_DeletedPrSupPrc,		&v_DeletedPrFixPrc,
												&v_DeletedPrBasket,		&v_DeletedPrTotPrc,		&v_DeletedPrDiscnt,
						
												&v_DeletedPrDsCode,		&v_DeletedPrTkMazon,	&v_DeletedPrIshNum,
												&v_DeletedPrIshSrc,		&v_DeletedPrIshTik,		&v_DeletedPrIshTkTp,
												&v_DeletedPrRuleNum,	&v_DeletedPrDocId,		&v_DeletedPrSrc,
												&v_DeletedGadget,		
						
												&v_DeletedPrID,			&DRUG_DELIVERED,		&ROW_NOT_DELETED,
												END_OF_ARG_LIST															);

					if (SQLERR_error_test ())
					{
						v_ErrorCode = ERR_DATABASE_ERROR;
						break;
					}

					do
					{
						FetchCursor (	MAIN_DB, TR6005spool_deldrugs_cur	);

						Conflict_Test (reStart);

						if (SQLCODE == 0)	// Good read.
						{
							// Copy original-sale values into arrays.
							// Op, Units, Total Price, and Member Participation get "flipped" negative later on.
							phDrgs[v_NumOfDrugLinesRecs].DrugCode					= v_DrugCode;
							phDrgs[v_NumOfDrugLinesRecs].Op							= v_DeletedPrOP;
							phDrgs[v_NumOfDrugLinesRecs].Units						= v_DeletedPrUnits;
							phDrgs[v_NumOfDrugLinesRecs].TotalPtn					= v_DeletedPrPtn;
							phDrgs[v_NumOfDrugLinesRecs].OpDrugPrice				= v_DeletedPrMemPrc;
							phDrgs[v_NumOfDrugLinesRecs].SupplierDrugPrice			= v_DeletedPrSupPrc;
							phDrgs[v_NumOfDrugLinesRecs].TotalDrugPrice				= v_DeletedPrTotPrc;
							phDrgs[v_NumOfDrugLinesRecs].tikrat_mazon_flag			= v_DeletedPrTkMazon;
							phDrgs[v_NumOfDrugLinesRecs].SpecPrescNum				= v_DeletedPrIshNum;	// Relevant only if we're inserting new rows...
							phDrgs[v_NumOfDrugLinesRecs].SpecPrescNumSource			= v_DeletedPrIshSrc;	// ...otherwise we'll preserve the existing values.
							phDrgs[v_NumOfDrugLinesRecs].IshurWithTikra				= v_DeletedPrIshTik;
							phDrgs[v_NumOfDrugLinesRecs].IshurTikraType				= v_DeletedPrIshTkTp;
							phDrgs[v_NumOfDrugLinesRecs].rule_number				= v_DeletedPrRuleNum;
							phDrgs[v_NumOfDrugLinesRecs].ParticipMethod				= v_DeletedPrPrtMeth;
							phDrgs[v_NumOfDrugLinesRecs].MemberPtnCode				= v_DeletedPrPrcCode;
							phDrgs[v_NumOfDrugLinesRecs].PrescSource				= v_DeletedPrSrc;
							phDrgs[v_NumOfDrugLinesRecs].DrugDiscountAmt			= v_DeletedPrDiscnt;
							phDrgs[v_NumOfDrugLinesRecs].DrugDiscountCode			= v_DeletedPrDsCode;
							phDrgs[v_NumOfDrugLinesRecs].InHealthBasket				= v_DeletedPrBasket;
							phDrgs[v_NumOfDrugLinesRecs].FixedPrice					= v_DeletedPrFixPrc;
							phDrgs[v_NumOfDrugLinesRecs].DocID						= v_DeletedPrDocId;		// DonR 12Jun2018 bug fix!
							phDrgs[v_NumOfDrugLinesRecs].LinkToAddition				= v_DeletedGadget;		// DonR 04Feb2019
							strcpy (phDrgs[v_NumOfDrugLinesRecs].unit_code,			" "	);
							strcpy (phDrgs[v_NumOfDrugLinesRecs].course_len_units,	" "	);
							strcpy (phDrgs[v_NumOfDrugLinesRecs].days_of_week,		" "	);
							strcpy (phDrgs[v_NumOfDrugLinesRecs].times_of_day,		" "	);
							strcpy (phDrgs[v_NumOfDrugLinesRecs].side_of_body,		" "	);

							v_NumOfDrugLinesRecs++;
						}	// Good read of drug-lines cursor.
						else
						{
							if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
							{
								break;	// No problem - we're finished reading drugs from original sale.
							}
							else
							{
								if (SQLERR_error_test ())
								{
									v_ErrorCode		= ERR_DATABASE_ERROR;
									break;
								}
							}	// Something other than end-of-fetch.
						}	// Fetch failed.
					}
					while (1);	// End of cursor loop for reading prior-sale drugs.

					CloseCursor (	MAIN_DB, TR6005spool_deldrugs_cur	);
				}	// Pharmacy sent "99" to request full deletion of prior sale.

				else
				{
					// Pharmacy sent a list of drugs to delete - but we assume that the information
					// sent doesn't include all the values from the original sale, so we'll read
					// them and copy them in.
					for (i = 0; i < v_NumOfDrugLinesRecs; i++)
					{
						v_DrugCode = phDrgs[i].DrugCode;

						ExecSQL (	MAIN_DB, TR6005spool_READ_deleted_prescription_drugs_values,
									&v_DeletedPrOP,			&v_DeletedPrUnits,		&v_DeletedPrPtn,
									&v_DeletedPrPrcCode,	&v_DeletedPrPrtMeth,	&v_DeletedPrMemPrc,
									&v_DeletedPrSupPrc,		&v_DeletedPrFixPrc,		&v_DeletedPrBasket,

									&v_DeletedPrTotPrc,		&v_DeletedPrDiscnt,		&v_DeletedPrDsCode,
									&v_DeletedPrTkMazon,	&v_DeletedPrIshNum,		&v_DeletedPrIshSrc,
									&v_DeletedPrIshTik,		&v_DeletedPrIshTkTp,	&v_DeletedPrRuleNum,
									&v_DeletedGadget,							
							
									&v_DeletedPrID,			&DRUG_DELIVERED,		&v_DrugCode,
									END_OF_ARG_LIST															);

						Conflict_Test (reStart);

						if (SQLCODE == 0)	// Good read.
						{
							// Copy original-sale values into arrays.
							// Op, Units, Total Price, and Member Participation get "flipped" negative later on.
							phDrgs[i].Op						= v_DeletedPrOP;
							phDrgs[i].Units						= v_DeletedPrUnits;
							phDrgs[i].TotalPtn					= v_DeletedPrPtn;
							phDrgs[i].OpDrugPrice				= v_DeletedPrMemPrc;
							phDrgs[i].SupplierDrugPrice			= v_DeletedPrSupPrc;
							phDrgs[i].TotalDrugPrice			= v_DeletedPrTotPrc;
							phDrgs[i].tikrat_mazon_flag			= v_DeletedPrTkMazon;
							phDrgs[i].SpecPrescNum				= v_DeletedPrIshNum;	// Relevant only if we're inserting new rows...
							phDrgs[i].SpecPrescNumSource		= v_DeletedPrIshSrc;	// ...otherwise we'll preserve the existing values.
							phDrgs[i].IshurWithTikra			= v_DeletedPrIshTik;
							phDrgs[i].IshurTikraType			= v_DeletedPrIshTkTp;
							phDrgs[i].rule_number				= v_DeletedPrRuleNum;
							phDrgs[i].ParticipMethod			= v_DeletedPrPrtMeth;
							phDrgs[i].MemberPtnCode				= v_DeletedPrPrcCode;
							phDrgs[i].DrugDiscountAmt			= v_DeletedPrDiscnt;
							phDrgs[i].DrugDiscountCode			= v_DeletedPrDsCode;
							phDrgs[i].InHealthBasket			= v_DeletedPrBasket;
							phDrgs[i].FixedPrice				= v_DeletedPrFixPrc;
							phDrgs[i].LinkToAddition			= v_DeletedGadget;			// DonR 04Feb2019
						}	// Good read of drug-lines cursor.
						else
						{
							if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
							{
								GerrLogMini (GerrId, "6005-spool: Drug to delete %d/%d/DELIVERED not found.", v_DeletedPrID, v_DrugCode);
								v_ErrorCode = ERR_DATABASE_ERROR;
								break;
							}	// Row-not-found error.
							else
							{
								GerrLogMini (GerrId, "6005-spool: Error %d reading drug to delete %d/%d/DELIVERED.",
											 SQLCODE, v_DeletedPrID, v_DrugCode);

								if (SQLERR_error_test ())
								{
									v_ErrorCode = ERR_DATABASE_ERROR;
									break;
								}

								// We should never get here, since any non-zero SQLCODE should give a positive return
								// value for SQLERR_error_test().

							}	// Error other than row-not-found.
						}	// SQLCODE != 0 reading drug line to delete.
					}	// Loop through drug lines.
				}	// Pharmacy provided a list of drugs to be deleted from the original sale.
//GerrLogMini (GerrId, "Trn 6005-spool: End of first deletion processing section.");
			}	// Deletion processing.


			// Check that drugs are in the drug_list table, and load in their Largo Type and packaging details.
			for (i = 0; i < v_NumOfDrugLinesRecs; i++)
			{
				// DonR 14Apr2016: Switch to using the read_drug() routine, since that includes more sophisticated
				// data-massaging logic.
				// DonR 08Apr2018: Added new "see deleted drugs" parameter to read_drug(). Since spooled transactions
				// are often sent some time after the sale actually took place, we want to read deleted drugs even
				// if the current transaction is a drug sale - so set the parameter unconditionally TRUE.
				// DonR 02Aug2023 User Story #469361: To simplify some code, copy the whole DL structure to the
				// phDrgs array. Eventually values from phDrgs[x].DL should replace individual variables.
				if (read_drug (phDrgs[i].DrugCode, 99999999, &Phrm_info, true, &DL, NULL))
				{
					phDrgs[i].DL				= DL;			// DonR 02Aug2023.
					phDrgs[i].LargoType			= DL.largo_type;
					phDrgs[i].package_size		= DL.package_size;
					phDrgs[i].openable_package	= DL.openable_pkg;
					phDrgs[i].THalf				= DL.t_half;
					v_in_gadget_table			= DL.in_gadget_table;
					v_ingr_1_code				= DL.Ingredient[0].code;
					v_ingr_2_code				= DL.Ingredient[1].code;
					v_ingr_3_code				= DL.Ingredient[2].code;
					v_ingr_1_quant				= DL.Ingredient[0].quantity;
					v_ingr_2_quant				= DL.Ingredient[1].quantity;
					v_ingr_3_quant				= DL.Ingredient[2].quantity;
					v_ingr_1_quant_std			= DL.Ingredient[0].quantity_std;
					v_ingr_2_quant_std			= DL.Ingredient[1].quantity_std;
					v_ingr_3_quant_std			= DL.Ingredient[2].quantity_std;
					v_per_1_quant				= DL.Ingredient[0].per_quant;
					v_per_2_quant				= DL.Ingredient[1].per_quant;
					v_per_3_quant				= DL.Ingredient[2].per_quant;
					v_package_volume			= DL.package_volume;
				}
				else
				{
					Conflict_Test (reStart);

					if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
					{
						GerrLogMini (GerrId, "6005s couldn't find Largo Code %d.", phDrgs[i].DrugCode);
						SetErrorVar (&v_ErrorCode, ERR_DRUG_CODE_NOT_FOUND);
						break;
					}

					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}


				// Save generic-ingredient fields as well.
				phDrgs[i].in_gadget_table		= v_in_gadget_table;
				phDrgs[i].package_volume	    = v_package_volume;
				phDrgs[i].ingr_code			[0] = v_ingr_1_code;
				phDrgs[i].ingr_code			[1] = v_ingr_2_code;
				phDrgs[i].ingr_code			[2] = v_ingr_3_code;
				phDrgs[i].ingr_quant		[0] = v_ingr_1_quant;
				phDrgs[i].ingr_quant		[1] = v_ingr_2_quant;
				phDrgs[i].ingr_quant		[2] = v_ingr_3_quant;
				phDrgs[i].ingr_quant_std	[0] = v_ingr_1_quant_std;
				phDrgs[i].ingr_quant_std	[1] = v_ingr_2_quant_std;
				phDrgs[i].ingr_quant_std	[2] = v_ingr_3_quant_std;
				phDrgs[i].per_quant			[0] = v_per_1_quant;
				phDrgs[i].per_quant			[1] = v_per_2_quant;
				phDrgs[i].per_quant			[2] = v_per_3_quant;
			}	// Loop on drugs.


			// DonR 30Apr2015: It appears that Yarpa (at least) has a bug of some sort: they sometimes send a Maccabi
			// Prescription ID that is incorrect. Until now, the spool version of Trn. 2005/5005 has not verified what
			// the pharmacy sends us - but this now appears to be a problem. Accordingly, we'll perform one simple
			// check to see if the pharmacy's Maccabi Prescription ID is bogus or not; if it looks like a mistake, we'll
			// force it to zero, so the transaction will be treated as a new sale rather than updating something irrelevant
			// that was already in the database. (Of course, the redundancy check below will still operate!)
			AmountMismatch = PreviousErrorCode = 0;		// Third time I'm initializing this - pure paranoia!

			// DonR 09May2024 User Story #309732: If this is a "mark as paid"
			// request, skip all the usual validations here.
			if ((v_RecipeIdentifier != 0) && (v_ActionType != MARK_AS_PAID))
			{
				ExecSQL (	MAIN_DB, TR6005spool_READ_check_that_pharmacy_sent_correct_values,
							&sq_pharmnum,			&sq_MemberID,		&sq_DateDB,
							&sq_tikra_discount,		&sq_subsidy_amount,	&online_order_num,
							&PreviousErrorCode,
							&v_RecipeIdentifier,	END_OF_ARG_LIST									);

				Conflict_Test (reStart);

				if ((SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)	||
					((SQLCODE == 0) &&
					 ((sq_pharmnum	!= v_PharmNum)						||
					  (sq_MemberID	!= v_MemberID)						||
					  (sq_DateDB	!= SaleDate))))
				{
					// The Maccabi Prescription ID sent by the pharmacy was either not found in the database,
					// or else what was found for that ID didn't match the Pharmacy Code, Member ID, and
					// Sale Date in the database - so assume that the Prescription ID the pharmacy sent
					// is erroneous.
					// DonR 19Aug2020: Made parts of this diagnostic conditional, just to make the log
					// a little less verbose.
					sprintf (ErrorBuf, "6005-spool: data sent for PrID %d does not match DB.", v_RecipeIdentifier);
					if (sq_MemberID	!= v_MemberID)
					{
						sprintf (ErrorBuf + strlen(ErrorBuf), "\n     Member %d (%d in DB)", v_MemberID, sq_MemberID);
					}
					if (sq_pharmnum	!= v_PharmNum)
					{
						sprintf (ErrorBuf + strlen(ErrorBuf), "\n     Pharmacy %d (%d in DB)", v_PharmNum, sq_pharmnum);
					}
					if (sq_DateDB	!= SaleDate)
					{
						sprintf (ErrorBuf + strlen(ErrorBuf), "\n     Date %d (%d in DB)", SaleDate, sq_DateDB);
					}
					if (SQLCODE)
					{
						sprintf (ErrorBuf + strlen(ErrorBuf), "\n     SQLCODE = %d", SQLCODE);
					}
					sprintf (ErrorBuf + strlen(ErrorBuf), ".");
					GerrLogMini (GerrId, ErrorBuf);
//					GerrLogMini (GerrId,	"6005-spool: data for PrID %d does not match DB.\n     Member %d (%d in DB)\n"
//											"     Pharmacy %d (%d in DB)\n     Date %d (%d in DB)\n     SQLCODE = %d.",
//								 v_RecipeIdentifier, v_MemberID, sq_MemberID, v_PharmNum, sq_pharmnum, SaleDate, sq_DateDB, SQLCODE);

					// DonR 20Apr2023 User Story #432608: If we didn't find a matching row in the prescriptions table,
					// the correct value for Online Order Number is what the pharmacy sent in Trn. 6005 (assuming
					// that we're using the transaction version that includes this value), *not* zero.
					v_RecipeIdentifier	= 0;
					online_order_num	= OnlineOrderNum_6005;
				}
				else
				{	// Either a good read with matching values, or else a database error of some sort.
					if (SQLERR_error_test ())
					{
						v_ErrorCode = ERR_DATABASE_ERROR;
						break;
					}

					else
					{	// Good read with matching values.

						// DonR 20Apr2023 User Story #432608: Pharmacy now reports Online Order Number in
						// Transaction 6005. In the online version of the transaction, we won't actually
						// need to do anything with it - but as long as we have it, we might as well compare
						// it to what's already in the prescriptions table and print a diagnostic if it's
						// different. (I don't think it's worth reporting an error to the pharmacy.)
						// DonR 18May2023 User Story #432608 fix: Don't do this check if the pharmacy is
						// using a version of Transaction 6005 that doesn't send us OnlineOrderNum_6005.
						if ((VersionNumber > 3) && (OnlineOrderNum_6005 != online_order_num))
						{
							GerrLogMini (GerrId, "PrID %d: Trn. 6003 gave Online Order #%ld, but pharmacy reported Order #%ld in Trn. 6005-spool.",
										 v_RecipeIdentifier, online_order_num, OnlineOrderNum_6005);
						}

						// DonR 21Jun2018 Online Order Processing (SuperPharm): It is not permissible to send
						// Transaction 6005 to complete a "sale" that was in fact meant just to send us a new
						// Online Order Number; the pharmacy that actually fulfills the order is supposed to
						// send a new Transaction 6003. Since this is the spooled version of Transaction 6005
						// (and online order fulfillment is not supposed to use the spooled version), we don't
						// want to abort the transaction in this case; but at the very least we can write a
						// message to the log file to indicate that something forbidden was done.
						if (online_order_num > 0)
						{
							ExecSQL (	MAIN_DB, TR6005_READ_check_online_order_validity,
										&OO_made_pr_id,
										&online_order_num,	&Phrm_info.web_pharmacy_code,
										&Phrm_info.owner,	END_OF_ARG_LIST					);

							if ((SQLCODE == 0) && (OO_made_pr_id == v_RecipeIdentifier))
							{
								GerrLogMini (GerrId,
									"6005s: PrId %d is the original source of Online Order #%d, and should not be sold!",
									v_RecipeIdentifier, online_order_num);
							}
						}


						// Successful read of matching transaction. If "equality" test is enabled,
						// make sure that the pharmacy hasn't changed the Total Tikra Discount
						// or the Subsidy Amount from what was sent in the response to Trn. 6003.
						if (TestSaleEquality)
						{
							// Note that for diagnostic purposes, we want to test all the relevant "equality"
							// fields - so we don't quit once we've discovered a problem.
							if (v_TotalTikraDisc	!= sq_tikra_discount)
							{
								AmountMismatch = 1;

//								GerrLogMini (GerrId,
//											 "6005s: %d: Tikra %d, pharm %d sent %d%s.",
//											 v_RecipeIdentifier, sq_tikra_discount, v_PharmNum, v_TotalTikraDisc, (TestSaleEquality) ? "" : " (test disabled)");
							}

							if (v_TotalCouponDisc	!= sq_subsidy_amount)
							{
								AmountMismatch = 1;

//								GerrLogMini (GerrId,
//											 "6005s: %d: Subsidy %d, pharm %d sent %d%s.",
//											 v_RecipeIdentifier, sq_subsidy_amount, v_PharmNum, v_TotalCouponDisc, (TestSaleEquality) ? "" : " (test disabled)");
							}

							for (i = 0; i < v_NumOfDrugLinesRecs; i++)
							{
								// DonR 11Aug2016: Pharmacy must send the same Member Participation Amount as they got
								// from Transaction 6003 - if not, reject the transaction. Note that if this a deletion,
								// we have to compare a "flipped" version of the participation amount, since the pharmacy
								// sends it as a positive number and the database already has it as a negative number.
								if (phDrgs[i].PrescSource != RECIP_SRC_NO_PRESC)
								{

									if ((PRIVATE_PHARMACY) || (phDrgs[i].DrugDiscountCode == 0))
									{
										ComparePharmPtn = (v_ActionType == SALE_DELETION) ? (0 - phDrgs[i].TotalPtn) : phDrgs[i].TotalPtn;

										ExecSQL (	MAIN_DB, READ_prescription_drugs_member_ptn_amt,
													&sq_member_ptn_amt,
													&v_RecipeIdentifier,	&phDrgs[i].DrugCode,	END_OF_ARG_LIST		);

										// No real error-handling is needed here.
										if ((SQLCODE == 0) && (ComparePharmPtn != sq_member_ptn_amt))
										{
											GerrLogMini (GerrId,
														 "6005s: %d/%d: Ptn = %d, pharm %d sent %d.",
														 v_RecipeIdentifier, phDrgs[i].LineNo, sq_member_ptn_amt, v_PharmNum, ComparePharmPtn);

											AmountMismatch = 1;
										}	// Successful read of prescription-drugs row, but ptn. amounts don't match.
									}	// Sale is either at a private pharmacy, or does *not* have a Drug Discount Code for this drug.
								}	// Not an over-the-counter sale.
							}	// Loop through drugs to find participation-amount discrepancies.
						}	// "Equality" test is enabled.
					}	// Successful read of prescriptions row with matching Pharmacy Code, Member ID, and Sale Date.
				}	// Successful read of prescriptions row OR database error.
			}	// Pharmacy sent a non-zero Maccabi Prescription ID AND we're not in "mark as paid" mode.


			// Check if same prescription already exists (in delivered form) in the database.
			// If so, mark the new version as deleted.
			// Note that we want to check for duplations even if Member ID is zero. (I don't remember when this
			// change was made in 6005-spool.)
//			if (v_MemberID == 0)
//			{
//				same_pr_count = 0;
//			}
//			else
//			{
			// DonR 06Sep2011: If pharmacy has sent a deletion request for a sale that has already
			// been fully deleted, treat this request the same as a duplicate sale.
			if ((v_ActionType == SALE_DELETION)	&&
				((v_DeletedPrDelFlg	== 1)	||	(v_NumOfDrugLinesRecs == 0)))
			{
				same_pr_count = 1;	// Force "duplicate" status.
			}
			// DonR 03Dec2024 User Story #309732: If this is a "mark paid" request, don't test for
			// duplication and don't consider the transaction a duplicate even if it is - since all
			// we're doing is marking existing completed sales as paid-for, there's no problem if
			// it's done more than once.
			else
			if (v_ActionType == MARK_AS_PAID)
			{
				same_pr_count = 0;	// Force NON-duplicate status.
			}
			else
			{
				SET_ISOLATION_DIRTY;

				// DonR 29Jun2010: Changed order of WHERE conditions to conform to index structure.
				// DonR 07Feb2011: Added action_type to WHERE conditions.
				// DonR 08Feb2011: Change test on delivered_flg, since we're no longer using only 1 and 0 there.
				// DonR 28Mar2011: Per Iris, removed member ID/Code from SELECT criteria; also added a criterion
				// for del_flg, since we don't want to consider the new transaction a duplicate unless the
				// previous transaction(s) were "for real". (In other words, we want to ignore transactions
				// with del_flg set to ROW_SYS_DELETED = 2.)
				ExecSQL (	MAIN_DB, READ_prescriptions_check_for_duplicate_spooled_sale,
							&same_pr_count,
							&v_PharmNum,			&v_MonthLog,		&v_PharmRecipeNum,
							&v_MemberBelongCode,	&v_PharmPtnCode,	&DRUG_NOT_DELIVERED,
							END_OF_ARG_LIST														);

				Conflict_Test (reStart);

				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					SET_ISOLATION_COMMITTED;
					break;
				}

				SET_ISOLATION_COMMITTED;
			}	// Need to check database for duplicate sales/deletions.


			// If the delivered prescription is already in the database, add the new version
			// with del_flg set to 2 (pre-deleted) and reported_to_as400 set to 1 (already
			// reported). Otherwise, add with these two fields set to zero - that is,
			// non-deleted and not yet reported to AS400.
			// DonR 05Sep2016: If we detected an amount discrepancy in Tikra Discount, Subsidy
			// Amount, or at least one drug participation amount, flag the row as "deleted by system"
			// and apply a new reported-to-AS/400 code of 3; this will make the relevant rows easy
			// to find in the database.
			if (same_pr_count > 0)
			{
				delete_flag			= ROW_SYS_DELETED;
				report_as400_flag	= REPORTED_TO_AS400;
			}
			else
			{
				if (AmountMismatch)
				{
					delete_flag			= ROW_SYS_DELETED;
					report_as400_flag	= SET_ASIDE_AMT_DISCREPANCY;
				}
				else
				{
					// DonR 13Jul2020 CR #32984 Part 4 (new version): Instead of checking the doctor_presc
					// table for previously-sold prescriptions, in spool mode we only want to check whether
					// we *already* detected this problem in the online transactions.
					// DonR 03Dec2024 User Story #309732: No change here, but it's worth noting that in
					// mark-as-paid mode, PreviousErrorCode will always be zero.
					switch (PreviousErrorCode)
					{
						case TR6005_RX_ALREADY_FULLY_SOLD:		delete_flag			= ROW_SYS_DELETED;
																report_as400_flag	= TR6005_RX_ALREADY_FULLY_SOLD;
																break;

						// Not part of the CR - but if there was a previous fatal error code
						// that should block the sale, we don't want to let it go through in
						// spool mode either! Note, though, that I don't see any actual cases
						// where this has happened in real life; apparently the pharmacy-side
						// systems prevent this kind of thing from happening.
						case ERR_PRESCRIPTIONID_NOT_APPROVED:	// From previous Trn. 6005-online.
						case ERR_DRUG_S_WRONG_IN_PRESC:			// From previous Trn. 6003.
																delete_flag			= ROW_SYS_DELETED;
																report_as400_flag	= PreviousErrorCode;
																break;

						default:								// If we get here, this is (or should be) a valid sale completion.
																delete_flag			= ROW_NOT_DELETED;
																report_as400_flag	= NOT_REPORTED_TO_AS400;
																break;
					}	// CR #32984 Part 4 (new version) end.
				}	// NOT an amount mismatch.
			}	// Not a redundant transaction.


			// DonR 25Jun2020 CR #32984 Part 4: If this is a drug sale and any of the
			// prescriptions being sold now have already been fully sold, reject the
			// current sale completion. This should happen only when a pharmacy is doing
			// something fraudulent.
//		// DonR 13Jul2020: Disabled. According to Iris, in 6005-spool we do *not* want
//		// to perform this test against the doctor_presc table - just look at previous
//		// results from 6003 and 6005-online.
//			if ((v_ActionType == DRUG_SALE) && (delete_flag != ROW_SYS_DELETED))
//			{
//				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
//				{
//					// Loop through individual doctor prescriptions to check for
//					// fully-sold prescriptions.
//					if ((phDrgs[i].PrescSource == RECIP_SRC_MACABI_DOCTOR) && (phDrgs[i].NumDocRxes > 0))
//					{
//						for (Rx = phDrgs[i].FirstRx; Rx < (phDrgs[i].FirstRx + phDrgs[i].NumDocRxes); Rx++)
//						{
//							// Don't check unless this is a Maccabi doctor prescription with a non-zero prescription ID.
//							if ((phDrgs[i].DocID == 0) || (DocRx[Rx].PrID == 0))
//								continue;
//
//							ExecSQL	(	MAIN_DB, CheckForFullySoldDocRx,
//										&RowsFound,
//										&v_MemberID,					&DocRx[Rx].PrID,	&DocRx[Rx].FromDate,
//										&phDrgs[i].Orig_Largo_Code,		&phDrgs[i].DocID,	&v_IDCode,
//										END_OF_ARG_LIST																);
//
//							if ((SQLCODE == 0) && (RowsFound > 0))
//							{
//								delete_flag			= ROW_SYS_DELETED;
//								report_as400_flag	= TR6005_RX_ALREADY_FULLY_SOLD;
//								break;
//							}
//						}	// Loop through prescriptions for a drug line.
//					}	// This drug line involves Maccabi doctor prescriptions.
//
//					// No point in continuing to loop if we've already found a fully-sold prescription.
//					if (report_as400_flag == TR6005_RX_ALREADY_FULLY_SOLD)
//						break;
//
//				}	// Loop through drug lines looking for already-fully-sold prescriptions.
//			}	// This is a drug sale - CR #32984 Part 4 end.


			// Use the new Recipe ID (that is, insert new rows) if one of two conditions is true:
			// 1) Delivered prescription is already in the database, and the new version is being
			//    added for completeness (or whatever the reason is) only;
			// 2) The pharmacy sent the 6005 message with Recipe ID of zero - meaning that the
			//    6003/6004 transaction sequence was never completed, and so we need to add
			//    instead of updating.
			// The third possibility is that both conditions are false: that is, the pharmacy
			// reported a Recipe ID, but that recipe is currently marked as non-delivered. In this
			// case we'll do an update, just like a regular 6005 transaction.
			if ((delete_flag == ROW_SYS_DELETED) || (v_RecipeIdentifier == 0))
			{
				v_RecipeIdentifier	= v_RecipeIdentifier1;

				// DonR 20Apr2023 User Story #432608: If we're adding a new row instead of updating an existing
				// one, use the value for Online Order Number that the pharmacy sent in Trn. 6005 (assuming that
				// we in fact got a non-zero value), *not* zero.
				online_order_num	= OnlineOrderNum_6005;

				AddNewRows			= 1;	// DonR 03May2004 - so we remember that we've got to add new rows.
			}


			// DonR 01Apr2015: If this is a deletion and pharmacy didn't send information about the
			// affected doctor prescriptions, load the data from the sale being deleted. (Note that
			// for any given drug line being deleted, the entire amount sold will be deleted - so
			// we don't have to worry about partial deletions.) We will check for missing doctor-
			// prescription data on a line-by-line basis.
			if (v_ActionType == SALE_DELETION)
			{
//GerrLogMini (GerrId, "6005-spool Deletion: %d drugs, %d doc rx's for first drug, del pr id %d.", v_NumOfDrugLinesRecs, phDrgs[0].NumDocRxes, v_DeletedPrID);
				SET_ISOLATION_DIRTY;
				
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					phDrgPtr = &phDrgs[i];

					v_DrugCode	= phDrgPtr->DrugCode;
					v_DoctorID	= phDrgPtr->DocID;

					if (phDrgPtr->NumDocRxes == 0)
					{
						// DonR 24Mar2020: Moved the DECLARE here, since it seems we were getting errors on the OPEN.
						DeclareAndOpenCursorInto (	MAIN_DB, TR6005_doc_prescription_link_cur,
													&RXL_PrID,			&RXL_FromDate,		&RXL_VisitNumber,
													&RXL_OP,			&RXL_Units,			&v_DeletedRxLargo,
													&v_DeletedPrID,		&v_DrugCode,		&v_DoctorID,
													&v_DeletedPrID,		END_OF_ARG_LIST								);
// GerrLogMini(GerrId, "6005-spool: Declared TR6005_doc_prescription_link_cur, SQLCODE = %d.", SQLCODE);
//						SQLERR_error_test ();	// DECLARE should never throw an error; if it does,
//												// just log it and wait for the OPEN to fail before
//												// exiting with an error.
//
// GerrLogMini (GerrId, "6005-spool Deletion: Opening Rx_6005S_cur for drug #%d (Largo %d)...", (i + 1), phDrgPtr->DrugCode);
//						OpenCursor (	MAIN_DB, TR6005_doc_prescription_link_cur	);
// GerrLogMini(GerrId, "6005-spool: Opened TR6005_doc_prescription_link_cur, SQLCODE = %d.", SQLCODE);
// GerrLogMini (GerrId, "6005-spool Deletion: Looking up pd_rx_link data for %d Largo %d - SQLCODE on OPEN = %d.", v_DeletedPrID, phDrgPtr->DrugCode, SQLCODE);

						if (SQLERR_error_test ())
						{
							v_ErrorCode = ERR_DATABASE_ERROR;
							break;
						}

						do
						{
							FetchCursor (	MAIN_DB, TR6005_doc_prescription_link_cur	);

							Conflict_Test (reStart);

							if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
							{
								break;
							}

							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}

							// If we get here, we actually read a doctor prescription. If this is the first one
							// for this drug line, record it.
							if (phDrgPtr->NumDocRxes == 0)
							{
								phDrgPtr->FirstRx			= MaxRx;
								phDrgPtr->Orig_Largo_Code	= v_DeletedRxLargo;
							}

							// Copy simple variables into structure.
							DocRxPtr				= &DocRx [MaxRx];
							DocRxPtr->PrID			= RXL_PrID;
							DocRxPtr->FromDate		= RXL_FromDate;
							DocRxPtr->VisitNumber	= RXL_VisitNumber;
							DocRxPtr->OP			= RXL_OP;
							DocRxPtr->Units			= RXL_Units;

							// If we get here, we've succeeded in reading a relevant pd_rx_link row.
							phDrgPtr->NumDocRxes++;
							MaxRx++;
//GerrLogMini (GerrId, "6005-spool Deletion: Got pd_rx_link data: PrID %d, FromDate %d, OP %d, Units %d.", DocRxPtr->PrID, DocRxPtr->FromDate, DocRxPtr->OP, DocRxPtr->Units);
						}
						while (1);	// End of fetch doctor-prescription rows loop.

						CloseCursor (	MAIN_DB, TR6005_doc_prescription_link_cur	);
					}	// No doctor-prescription data found for this drug line.

					// Marianna 14Mar2024 User Story #540234: If this is a deletion of a cannabis sale
					// and the pharmacy has not supplied Cannabis Product Detail information, read
					// the required data from the pd_cannabis_products table based on the sale
					// being deleted. Although it would be slightly more efficient to do the whole
					// thing in one go, we'll open the cursor separately for each drug line; this
					// will make the logic very slightly simpler, and will be more flexible just in
					// case a pharmacy sends the information for some drug lines and not for others.
					// (This is why we use whatever value TotalNumCannabisProducts already has - we
					// expect it to be zero, but theoretically it could have a positive value from
					// what the pharmacy sent.)
					if ((v_ActionType					== SALE_DELETION) &&
						(phDrgs[i].DL.drug_type			== 'K') &&
						(phDrgs[i].NumCannabisProducts	<  1))
					{
						DeclareAndOpenCursor (	MAIN_DB, TR6005_READ_cannabis_product_details,
												&v_DeletedPrID,		&phDrgs[i].DrugCode,		END_OF_ARG_LIST	);

						if (SQLCODE == 0)
						{
							while (1)
							{
								FetchCursorInto (	MAIN_DB, TR6005_READ_cannabis_product_details,
													&CannabisProduct [TotalNumCannabisProducts].cannabis_product_code,
													&CannabisProduct [TotalNumCannabisProducts].cannabis_product_barcode,
													&CannabisProduct [TotalNumCannabisProducts].op,
													&CannabisProduct [TotalNumCannabisProducts].units,
													&CannabisProduct [TotalNumCannabisProducts].price_per_op,
													&CannabisProduct [TotalNumCannabisProducts].product_sale_amount,
													&CannabisProduct [TotalNumCannabisProducts].product_ptn_amount,
													END_OF_ARG_LIST															);

								if (SQLERR_code_cmp(SQLERR_end_of_fetch) == MAC_TRUE)
								{
									break;
								}
								else
								{
									Conflict_Test(reStart);

									if (SQLCODE == 0)
									{
										CannabisProduct[TotalNumCannabisProducts].DrugLineSubscript = i;
										phDrgs[i].NumCannabisProducts++;
										TotalNumCannabisProducts++;
									}
									else
									{
										SQLERR_error_test();
										break;
									}
								}
							}	// Read through Cannabis Product Details rows for this prescription_id/drug code.
						}	// Successful open of pd_cannabis_products cursor.
						else
						{
							Conflict_Test(reStart);
							SQLERR_error_test();
						}

						CloseCursor(MAIN_DB, TR6005_READ_cannabis_product_details);
					}	// Marianna 14Mar2024 User Story #540234 end (read Cannabis Product Details from the original sale).

				}	// Loop through drugs in deletion request.
			}	// This is a deletion, so we need to check whether we're "missing" doctor-prescription info.

			// End of dummy loop to prevent goto.
		}
		while (0);	// Loop should run only once.

		// DonR 01Dec2009: Just to be on the safe side, restore normal database isolation.
		// This should be necessary only if we hit a DB error while we were in "dirty read"
		// mode.
		SET_ISOLATION_COMMITTED;

		// Update tables.
		//
		// And now...
		// Yet another dummy loop to avoid goto!
		// Reply is sent to pharmacy when we exit from loop.
		if (reStart == MAC_FALS)	// No major database problem so far.
		{
			do
			{
				// Update PHARMACY_DAILY_SUM table.
				// DonR 05Aug2009: Don't add private-pharmacy non-prescription sales to pharmacy_daily_sum.
				// DonR 05Jul2010: Note that for sale deletions, the pharmacy will report positive numbers
				// for OP/Units and Total Member Participation; we carry these numbers internally (in
				// prescriptions/prescription_drugs) as negative numbers.
				// DonR 23Aug2010: Per Iris Shaya, Total Tikra Discount and Total Coupon Discount need to be
				// subtracted from the participation amount for this sale.
				// DonR 11Jan2011: For sale deletions, AS/400 will report Tikra and Coupon reductions in
				// participation as negative numbers. This means that in calculating the member participation
				// written to pharmacy_daily_sum, these numbers need to be added, not subtracted. Accordingly,
				// this bit of math will be split into two versions and moved to the "if" based on the current
				// Action Type.
				// Update Pharmacy Daily Sum ONLY IF we don't already have the delivered prescription
				// in the database.
				if (delete_flag != ROW_SYS_DELETED)
				{
					// Calculate prescription total
					sq_TotalMemberPrice	= 0;
					sq_TotalDrugPrice	= 0;
					sq_TotSuppPrice		= 0;

					for (i = 0; i < v_NumOfDrugLinesRecs; i++)
					{
						// Test the relevancy of information drug-by-drug.
						if ((MACCABI_PHARMACY) || (phDrgs[i].PrescSource != RECIP_SRC_NO_PRESC))
						{
							sq_TotalMemberPrice	+= phDrgs[i].TotalPtn;
							sq_TotalDrugPrice	+= phDrgs[i].TotalDrugPrice;

							sq_TotSuppPrice		+= phDrgs[i].SupplierDrugPrice * phDrgs[i].Op;

							if (phDrgs[i].Units != 0)
							{
								sq_TotSuppPrice	+= (int)(  (float)phDrgs[i].SupplierDrugPrice
														 * (float)phDrgs[i].Units
														 / (float)phDrgs[i].package_size);
							}
						}	// This drug line is relevant.
					}	// Loop through all drugs in this sale.


					// DonR 04Jun2015: Since we no longer have a single Prescription Source for the whole sale, we
					// calculate our totals unconditionally - but we do look at each drug's qualifications
					// individually. We want to update pharmacy_daily_sum if we found at least something in the
					// transaction that will impact the pharmacy's totals.
					// DonR 05Feb2023 User Story #232220: Update Pharmacy Daily Sum *only* if this transaction has
					// already been paid for. If the Credit Type Used value is 99, paid_for will be zero and the
					// transaction is still unpaid; in this case it's in a state of "suspended animation", valid
					// for things like interaction/overdose checking but not yet sent to AS/400 and not yet included
					// in the Pharmacy Daily Sum.
					// DonR 09May2024 User Story #309732: Note that if we're in "mark as paid" mode,
					// v_NumOfDrugLinesRecs has been forced to zero and thus the loop above will not
					// have done anything. This will leave the three variables sq_TotalMemberPrice,
					// sq_TotalDrugPrice, and sq_TotSuppPrice set to zero, and that in turn will prevent
					// any updates to pharmacy_daily_sum without having to change any other logic.
					if (paid_for && ((sq_TotalMemberPrice != 0) || (sq_TotalDrugPrice != 0) || (sq_TotSuppPrice != 0)))
					{
						// Set up variables to insert/update Pharmacy Daily Sum data. There are five
						// possibilities:
						// 1) Drug sale.
						// 2) Conventional sale deletion.
						// 3) Deletion for prior month or different pharmacy; this gets recorded as a
						//    "negative sale" to the pharmacy performing the deletion.
						// 4) Return for credit ("zicui") - treated like (3).
						// 5) Cancellation of return - treated like (1).
						// Note that for any strange values of Action Type, we will assume that a drug
						// sale was intended.
						//
						// DonR 31Dec2017: Changed three simple assignments to "0 + x" assignments, just in case the
						// source variable has a funky value. This was done because I saw a sporadic "integrity
						// constraint violation (Informix error -391) on pharmacy_daily_sum.purchase_sum.
						if ((v_ActionType != SALE_DELETION) && (v_ActionType != RETURN_FOR_CREDIT))
						{
							sq_TotalMemberPrice	-= (v_TotalTikraDisc + v_TotalCouponDisc);	// DonR 23Aug2010 / 11Jan2011.
							PDS_sum				=  0 + sq_TotalDrugPrice;
							PDS_prt_sum			=  0 + sq_TotalMemberPrice;
							PDS_purch_sum		=  0 + sq_TotSuppPrice;
							PDS_lines			=  v_NumOfDrugLinesRecs;
							PDS_count			=  1;
							PDS_del_sum			=  0;
							PDS_del_prt_sum		=  0;
							PDS_del_purch_sum	=  0;
							PDS_del_lines		=  0;
							PDS_del_count		=  0;
							PDS_date			=  SaleDate;
						}
						else
						{	// If we get here, we are dealing with either a deletion (which may be "conventional"
							// or not) or a return for credit, which is treated like an "unconventional" deletion.

							// DonR 11Jan2011: For deletions, discounts are sent by pharmacy as negative numbers.
							sq_TotalMemberPrice	+= (v_TotalTikraDisc + v_TotalCouponDisc);	// DonR 11Jan2011.

							if ((v_ActionType	== SALE_DELETION)		&&
								(v_PharmNum		== v_DeletedPrPharm)	&&
								(v_MonthLog		== v_DeletedPrYYMM))
							{
								// Conventional sale deletion.
								PDS_sum				= 0;
								PDS_prt_sum			= 0;
								PDS_purch_sum		= 0;
								PDS_lines			= 0;
								PDS_count			= 0;
								PDS_del_sum			= sq_TotalDrugPrice;	// Should be positive.
								PDS_del_prt_sum		= sq_TotalMemberPrice;	// Should be positive.
								PDS_del_purch_sum	= sq_TotSuppPrice;		// Should be positive.
								PDS_del_lines		= v_NumOfDrugLinesRecs;
								PDS_del_count		= 1;

								// DonR 02Mar2011: For conventional sale deletions, read the original sale date,
								// since that's the date to be used for updating pharmacy_daily_sum.
								ExecSQL (	MAIN_DB, READ_deleted_sale_date,
											&PDS_date, &v_DeletedPrID, END_OF_ARG_LIST	);

								if (SQLCODE != 0)
									PDS_date = SaleDate;
							}
							else
							{
								// Deletion for prior month and/or different pharmacy, OR return for credit -
								// treat as "negative sale".
								PDS_sum				= 0 - sq_TotalDrugPrice;	// Should be positive, so subtract.
								PDS_prt_sum			= 0 - sq_TotalMemberPrice;	// Should be positive, so subtract.
								PDS_purch_sum		= 0 - sq_TotSuppPrice;		// Should be positive, so subtract.
								PDS_lines			= v_NumOfDrugLinesRecs;
								PDS_count			= 1;
								PDS_del_sum			= 0;
								PDS_del_prt_sum		= 0;
								PDS_del_purch_sum	= 0;
								PDS_del_lines		= 0;
								PDS_del_count		= 0;
								PDS_date			= SaleDate;
							}
						}	// We are dealing with either a deletion or a return for credit.

						// DonR 21Mar2011: For better performance, try updating rather than inserting first.
						// The vast majority of the time, we'll be updating an existing row - so why waste
						// time trying to insert, failing, and only then updating?
						// DonR 03May2015: Add a retry loop, since I'm seeing cases where the UPDATE fails but
						// then the INSERT fails too, with SQL duplicate key error.
						// DonR 13Jul2016: Added one more retry, and increased the pause before retry from five
						// to fifty milliseconds; this should, I hope, reduce the number of transactions that
						// fail with a DB error.
						// DonR 09Aug2016: Doubled sleep interval and added a third retry.
						for (i = 0; i < 4; i++)
						{
//GerrLogMini(GerrId, "6005-spool: attempt #%d to write to pharmacy_daily_sum.", i + 1);
							if (i > 0)
								usleep (100000);	// Sleep 100 milliseconds before retry.

							ExecSQL (	MAIN_DB, UPD_pharmacy_daily_sum,
										&PDS_sum,			&PDS_prt_sum,			&PDS_purch_sum,
										&PDS_count,			&PDS_lines,				&PDS_del_sum,
										&PDS_del_prt_sum,	&PDS_del_lines,			&PDS_del_count,
										&PDS_del_purch_sum,
										&v_PharmNum,		&v_InstituteCode,		&v_MonthLog,
										&PDS_date,			&v_TerminalNum,			END_OF_ARG_LIST		);

							PDS_saved_sqlcode	= SQLCODE;			// Just to provide a better diagnostic if all retries fail.
							PDS_saved_rows		= sqlca.sqlerrd[2];	// Just to provide a better diagnostic if all retries fail.
//GerrLogMini(GerrId, "Update PDS for %d/%d/%d/%d/%d: SQLCODE = %d, %d rows updated.", v_PharmNum, v_InstituteCode, v_MonthLog, PDS_date, v_TerminalNum, SQLCODE, PDS_saved_rows);

							// DonR 31Dec2015: If the UPDATE succeeded, we need to break out of the retry loop so we don't 
							// perform the update twice! (In fact, the *only* situation in which we want to stay in the loop
							// is if both the UPDATE and the INSERT failed with "no rows affected" and "duplicate key",
							// respectively.)
							// DonR 05Jan2016 HOT FIX: If the update found nothing to update, SQLCODE will still be equal
							// to zero - so we have to look at "no rows affected" separately.
							if (DB_UPDATE_WORKED)
							{
								break;	// We succeeded in the UPDATE, so abort the retry loop.
							}

							// If there was nothing to update, try inserting a new row.
							if (SQLERR_code_cmp (SQLERR_no_rows_affected) == MAC_TRUE)
							{
								ExecSQL (	MAIN_DB, INS_pharmacy_daily_sum_19_columns,
											&v_PharmNum,		&v_InstituteCode,	&v_MonthLog,
											&PDS_date,			&v_TerminalNum,		&PDS_sum,
											&PDS_count,			&PDS_lines,			&PDS_prt_sum,
											&PDS_purch_sum,		&PDS_del_sum,		&PDS_del_prt_sum,

											&PDS_del_lines,		&PDS_del_count,		&PDS_del_purch_sum,
											&IntZero,			&IntZero,			&IntZero,
											&IntZero,			END_OF_ARG_LIST								);
//GerrLogMini(GerrId, "Insert PDS for %d/%d/%d/%d/%d: SQLCODE = %d.", v_PharmNum, v_InstituteCode, v_MonthLog, PDS_date, v_TerminalNum, SQLCODE);

								if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_FALSE)
									break;	// Retry only on duplicate-key error.

							}	// No rows affected on UPDATE, so try INSERT.

							// DonR 31Dec2015: If we get here, either the UPDATE failed with something *other* than "no rows affected",
							// or else the UPDATE got "no rows affected" *AND* the INSERT failed with a duplicate-key error. This
							// situation, and *only* this situation, is when we want to re-attempt the UPDATE.

						}	// Retry loop.

						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							GerrLogMini (GerrId, "6005-spool: DB error %d writing to pharmacy_daily_sum\nfor %d/%d/%d/%d after %d attempts.\nLast UPDATE returned %d (%d rows).",
										 SQLCODE, v_PharmNum, v_MonthLog, PDS_date, v_TerminalNum, i, PDS_saved_sqlcode, PDS_saved_rows);
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}	// DonR 04Jun2015: Insert/update to pharmacy_daily_sum is needed because at least one drug line was relevant.
				}	// The current transaction is not "sys deleted".

				// Update doctor_presc table, and add to prescription_drugs-to-doctor_presc linkage table
				// pd_rx_link and "pass-through" table for updating prescriptions in CDS. This loop also inserts
				// or updates prescription_drugs.
				for (i = 0; i < v_NumOfDrugLinesRecs; i++)
				{
					phDrgPtr = &phDrgs [i];
					v_DrugCode			= phDrgs[i].DrugCode;
					LineNum				= i + 1;

					// DonR 20Mar2024 User Story #540234: If we're in add-new-rows mode, phDrgs.LineNo does
					// not yet have a value. In that case, assign it one now, so that pd_cannabis_products
					// gets a proper line_no value.
					if (phDrgPtr->LineNo < 1)
						phDrgPtr->LineNo = LineNum;

					// DonR 14Jan2009: Change 99 ("kacha") to just 9, since the "tens" digit is now used
					// for additional information.
					PW_SubstPermitted	= phDrgs[i].SubstPermitted % 10;	// 10May2007: Per Iris, don't translate this.

					StopUseDate   = AddDays (SaleDate,		phDrgPtr->Duration);
					StopBloodDate = AddDays (StopUseDate,	phDrgPtr->THalf);

					if (StopBloodDate > max_drug_date)
					{
						max_drug_date = StopBloodDate;
					}

					// Loop through individual doctor prescriptions to update their statuses.
					// For spooled mode, we add some conditions: update doctor prescriptions only for sales and sale deletions
					// (not returns for credit or return cancellations); update only if this is a new sale/deletion (i.e.
					// not ROW_SYS_DELETED); and update only if Member ID is non-zero.
					if ((v_ActionType			!= RETURN_FOR_CREDIT)		&&
						(v_ActionType			!= RETURN_DELETION)			&&
						(delete_flag			!= ROW_SYS_DELETED)			&&
						(v_MemberID				>  0)						&&
						(phDrgPtr->PrescSource	== RECIP_SRC_MACABI_DOCTOR))
					{
						for (Rx = CarryForwardUnits = 0; Rx < phDrgPtr->NumDocRxes; Rx++)
						{
							DocRxPtr = &DocRx [Rx + phDrgPtr->FirstRx];

							// DonR 24Aug2021 WORKINGPOINT: If the pharmacy has sent a "prescription" with Doctor Prescription ID = 0,
							// maybe we should just do a "continue" rather than go to update_doctor_presc(). It seems like situations
							// like this may be causing spooled 6005's not to update prescription_drugs rows as "sold", for reasons
							// that (for the moment) I don't understand. (OTOH we don't seem to have the problem in ordinary 6005's,
							// so maybe we should leave things alone here and change only the spooled version.)
							// DonR 25Aug2021: I've gone through update_doctor_presc() and tidied up a couple of things (including
							// a possible fix to the FORCE_NOT_FOUND macro), and I now think that calling the routine even with
							// a zero value for Doctor Prescription ID *should* be harmless. A "bogus" row will be written to
							// pd_rx_link, but that has some diagnostic value.

							// DonR 27Mar2018: Previously, we were allocating amounts sold to doctor prescriptions
							// based on what the pharmacy sends in terms of OP/units for each prescription - but
							// these values are not actually very meaningful. Instead, update_doctor_presc() is
							// now performing the allocation, based on what was actually prescribed and whether
							// monthly rounding is called for. To enable this, we set up two "balance" variables
							// to keep track of how much of the current drug line has yet to be allocated to a
							// doctor prescription.
							// DonR 15Dec2015: Fixed Line Number parameter (the previous version always passed zero, so drugs never
							// got marked as sold). Also changed the Sale Date and Time parameters, so that the Last Sold date/time
							// recorded in doctor_presc will reflect what the pharmacy actually sent (and what's written in the
							// prescriptions/prescription_drugs tables) rather than the system time when the spooled data is received.
							// Note that we rely on the pharmacy to send us the same sequence of drugs sold in 6005-spool as was sent
							// in Transaction 6003 (assuming that there was a preceding 6003).
							update_doctor_presc	(	0,		// Normal mode - NOT processing late-arriving doctor prescriptions.
													v_ActionType,
													v_MemberID,							v_IDCode,
													v_RecipeIdentifier,					LineNum,
													phDrgPtr->DocID,					phDrgPtr->DocIDType,			DocRxPtr->PrID,
													phDrgPtr->Orig_Largo_Code,			phDrgPtr->DrugCode,				&phDrgPtr->DL,	// DonR 02Aug2023 User Story #469361: Now there *is* a DL structure to pass in!
													DocRxPtr->FromDate,					SaleDate,						SaleTime,
													DocRxPtr->OP,						DocRxPtr->Units,	// Straight from the pharmacy.
													DocRxPtr->OP_Unsold,				DocRxPtr->UnitsUnsold,
													phDrgPtr->use_instr_template,							// DonR 01Aug2024 Bug #334612: Get "ratzif" from pharmacy instead of from doctor Rx.
													v_DeletedPrID,
													(Rx >= (phDrgPtr->NumDocRxes - 1)),						// Non-zero if this is the last prescription.
													&CarryForwardUnits,
													NULL,								NULL,				// We already know the Original Largo Code and Prescription Date.
													&phDrgPtr->NumRxLinks,
													NULL,	NULL,	NULL,	NULL		// Doctor visit & Rx arrival timestamps - relevant only for spool processing.
												);

							// If CarryForwardUnits has a value > 0, the pharmacy over-allocated units to the current prescripton.
							// In this case, add the CarryForwardUnits value to the *next* prescription in the list. Note that
							// CarryForwardUnits should automatically get a zero value for the last prescription in the list, but
							// we'll test that condition anyway just to be paranoid.
							if ((CarryForwardUnits > 0) && (Rx < (phDrgPtr->NumDocRxes - 1)))
							{
								// Increment units for the next prescription. Don't worry about adjusting
								// the OP number, at least for now.
								DocRx [Rx + phDrgPtr->FirstRx + 1].Units += CarryForwardUnits;
							}

						}	// Loop through doctor prescriptions for this drug line.
					}	// This drug line is for Maccabi Doctor prescriptions, valid member, drug sale/sale deletion, non-redundant transaction.


					// Prepare sold-ingredients variables.
					for (j = 0; j < 3; j++)
					{
						if ((phDrgs[i].ingr_code	[j]		<  1)	||
							(phDrgs[i].ingr_quant	[j]		<= 0.0)	||
							(phDrgs[i].per_quant	[j]		<= 0.0)	||
							(phDrgs[i].package_size <  1))
						{
							// Invalid values - set this slot to zero.
							phDrgs[i].ingr_code				[j] = 0;
							phDrgs[i].ingr_quant_bot		[j] = 0.0;
							phDrgs[i].ingr_quant_bot_std	[j] = 0.0;
						}

						else
						{
							if (phDrgs[i].package_size == 1)
							{
								// Syrups and similar drugs.
								phDrgs[i].ingr_quant_bot[j] =	  (double)phDrgs[i].Op
														* phDrgs[i].package_volume
														* phDrgs[i].ingr_quant	[j]
														/ phDrgs[i].per_quant	[j];

								phDrgs[i].ingr_quant_bot_std[j] =	  (double)phDrgs[i].Op
															* phDrgs[i].package_volume
															* phDrgs[i].ingr_quant_std	[j]
															/ phDrgs[i].per_quant		[j];
							}

							else	// Package size > 1.
							{
								// Tablets, ampules, and similar drugs.
								// For these medications, ingredient is always given per unit.
								UnitsSold	=	  (phDrgs[i].Op		* phDrgs[i].package_size)
												+  phDrgs[i].Units;

								phDrgs[i].ingr_quant_bot		[j] = (double)UnitsSold * phDrgs[i].ingr_quant		[j];
								phDrgs[i].ingr_quant_bot_std	[j] = (double)UnitsSold * phDrgs[i].ingr_quant_std	[j];
							}
						}	// Valid quantity values available.
					}	// Loop through ingredients for this drug.

					// Load DB variables with computed values. Note that the Ingredient Code
					// may have been zeroed out, so it needs to be reloaded!
					v_ingr_1_code		= phDrgs[i].ingr_code			[0];
					v_ingr_2_code		= phDrgs[i].ingr_code			[1];
					v_ingr_3_code		= phDrgs[i].ingr_code			[2];
					v_ingr_1_quant		= phDrgs[i].ingr_quant_bot		[0];
					v_ingr_2_quant		= phDrgs[i].ingr_quant_bot		[1];
					v_ingr_3_quant		= phDrgs[i].ingr_quant_bot		[2];
					v_ingr_1_quant_std	= phDrgs[i].ingr_quant_bot_std	[0];
					v_ingr_2_quant_std	= phDrgs[i].ingr_quant_bot_std	[1];
					v_ingr_3_quant_std	= phDrgs[i].ingr_quant_bot_std	[2];


					// DonR 05Jul2010: Per Iris Shaya, pharmacies send positive numbers for OP/Units,
					// Total Member Participation, and Total (Supplier) Drug Price in sale-deletion
					// requests. We "flip" these numbers to negative when writing to the database.
					// DonR 03Jul2013: Instead of "flipping" the numbers stored in phDrgPtr, use a set
					// of simple variables. This way, when we hit a database lock and execute this block
					// of code more than once, the underlying "real" variables will remain positive and
					// the numbers we write to the database for deletions will be reliably negative.
					// DonR 24May2022 BUG FIX: Instead of flipping the "source" value phDrgPtr->VoucherAmtUsed
					// for deletions, set an "sq" variable the same as we do for the other variables here.
					// This way, if we have to retry a deletion transaction after a DB-contention error,
					// the original value reported by the pharmacy will be unchanged and we won't perform
					// a "double flip" and write a positive number to the database when it should be negative.
					if ((v_ActionType == SALE_DELETION) || (v_ActionType == RETURN_FOR_CREDIT))
					{
						sq_TotalMemberPrice	= phDrgPtr->TotalPtn					*  -1;
						sq_TotalDrugPrice	= phDrgPtr->TotalDrugPrice				*  -1;
						sq_Op				= phDrgPtr->Op							*  -1;
						sq_Units			= phDrgPtr->Units						*  -1;
						sq_VoucherAmtUsed	= phDrgPtr->VoucherAmtUsed				*  -1;	// DonR 27Jun2021 User Story #163882 / 24May2022 BUG FIX
					}
					else
					{
						// Ordinary drug sale - just copy the array/structure variables into the simple variables.
						sq_TotalMemberPrice	= phDrgPtr->TotalPtn;
						sq_TotalDrugPrice	= phDrgPtr->TotalDrugPrice;
						sq_Op				= phDrgPtr->Op;
						sq_Units			= phDrgPtr->Units;
						sq_VoucherAmtUsed	= phDrgPtr->VoucherAmtUsed;	// DonR 24May2022 BUG FIX
					}


					// If this is a deletion, mark the original sold-drug row as deleted.
					// DonR 31Jan2012: If this is a duplicate deletion (for whatever reason), DO NOT
					// update the original sale!
					// DonR 04Jul2016: Instead of repeating essentially the same code in eight places (i.e. two
					// tables, Transactions 5005 and 6005, online and spooled versions), created a single function
					// MarkDeleted() that handles the deletion-flag update. It returns zero if all went OK, and
					// anything else indicates a database error.
					if ((v_ActionType == SALE_DELETION) && (delete_flag	!= ROW_SYS_DELETED))
					{
						if (MarkDeleted ("6005sp", v_DeletedPrID, v_DrugCode, v_RecipeIdentifier) != 0)
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}	// Need to set deleted flag on original drug line being deleted.


					// DonR 04Feb2019 CR #28229: We need to update Meishar under two circumstances:
					// A) The current transaction is an update to a sale/deletion that was already recorded by
					//    Transaction 6003 and got participation through Meishar.
					// B) The current transaction is new to the system (i.e. AddNewRows is TRUE), but it's a
					//    deletion of a sale that received participation from Meishar. In this case, the previous
					//    version did not update Meishar with the deletion - and this was a bug.
					if (!AddNewRows)
					{
						// DonR 29Jun2016: If we're updating a prescription_drugs row that already exists, we need to
						// retrieve a couple of its columns. If we fail to read it, we will drop through to the error-
						// handling code after the UPDATE to prescription_drugs.
						// DonR 17Apr2018 BUG FIX: We also need to read the previous value of special_presc_num and
						// spec_pres_num_sors, since otherwise they'll be forcibly, brutally zeroed out.
						ExecSQL (	MAIN_DB, TR6005spool_READ_prescription_drugs_fields_before_update,
									&phDrgPtr->LineNo,			&phDrgPtr->ParticipMethod,		&GadgetCodeFound,
									&phDrgPtr->SpecPrescNum,	&phDrgPtr->SpecPrescNumSource,	&phDrgPtr->ph_otc_unit_price,

									&v_RecipeIdentifier,		&phDrgPtr->DrugCode,			END_OF_ARG_LIST					);

						// DonR 27Jul2021 BUG FIX: If this SELECT fails, we need to have proper error-trapping -
						// either a retry for any kind of DB contention issue, or a full error report for anything
						// else. Note that row-not-found is *not* an acceptable condition here - it means the pharmacy
						// has sent a Largo Code in 6005 that was *not* in the initial 6003 transaction, and that makes
						// the whole thing invalid.
						Conflict_Test (reStart);

						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							GerrLogMini (GerrId, "6005-spool: Row-not-found reading %d Largo %d.",
										 v_RecipeIdentifier, phDrgPtr->DrugCode);

							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}	// Anything other than not-found (or a DB conflict trapped by Conflict_Test).
					}	// Updating rather than adding new rows.
					else
					{
						// If we're in insert mode, we can assume that we already successfully read what we need -
						// particularly since in insert mode we update Meishar only for deletions.
						GadgetCodeFound = SQLCODE = 0;
					}	// If we're adding new rows, we don't need to re-read fields from prescription_drugs.


					if ((SQLCODE == 0)																			&&
						((phDrgPtr->ParticipMethod % 10) == FROM_GADGET_APP)									&&
						((!AddNewRows) || ((v_ActionType == SALE_DELETION) && (phDrgPtr->LinkToAddition > 0))))
					{
						v_gadget_code	= (phDrgPtr->LinkToAddition > 0) ? phDrgPtr->LinkToAddition : GadgetCodeFound;
						v_DoctorPrID	= DocRx [phDrgPtr->FirstRx].PrID; 
						v_DoctorPrDate	= DocRx [phDrgPtr->FirstRx].FromDate;
						Unit_Price		= ((phDrgPtr->PrescSource == 0) && (phDrgPtr->ph_otc_unit_price > 0)) ? phDrgPtr->ph_otc_unit_price : phDrgPtr->OpDrugPrice;

						// DonR 15Sep2019 CR #28451: If this is a deletion, send Meishar the *original*
						// Pharmacy Code rather than the Pharmacy Code of the deleting pharmacy.
						if (v_ActionType == SALE_DELETION)
						{
							// DonR 23Jun2010: Gadget Action Code is now dependent on whether this is a
							// conventional drug sale or a deletion.
							AS400_Gadget_Action	= enActSterNo;

							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion itself.
							GadgetRecipeID = v_DeletedPrID;

							GadgetPharm = v_DeletedPrPharm;
						}
						else
						{
							// DonR 23Jun2010: Gadget Action Code is now dependent on whether this is a
							// conventional drug sale or a deletion.
							AS400_Gadget_Action	= enActWrite;

							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion itself.
							GadgetRecipeID = v_RecipeIdentifier;

							GadgetPharm = v_PharmNum;
						}

						ExecSQL (	MAIN_DB, READ_Gadgets_for_sale_completion,
									&v_service_code,	&v_service_number,	&v_service_type,
									&v_DrugCode,		&v_gadget_code,		&v_gadget_code,
									END_OF_ARG_LIST												);

						Conflict_Test (reStart);

						// DonR 12Sep2021: Add separate error-handling for row-not-found. This should never really
						// happen, but I just saw an error in the log that looked like the pharmacy had sent an
						// incorrect value for one of the "gadget" key fields.
						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							GerrLogMini (GerrId, "Trn. 6005-spool: No gadgets row found for Largo %d Gadget Code %d.", v_DrugCode, v_gadget_code);
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}

						// If we get here, the gadget entry really does exist.
						// DonR 19Aug2025 User Story #442308: If Nihul Tikrot calls are disabled, disable Meishar calls as well.
						if (TikrotRPC_Enabled)
						{
							GadgetError = as400SaveSaleRecord (	(int)GadgetPharm,			// DonR 15Sep2019 CR #28451.
																(int)GadgetRecipeID,		// DonR 09Dec2010.
																(int)v_MemberID,
																(int)v_IDCode,
																(int)v_service_code,
																(int)v_service_number,
																(int)v_service_type,
																(int)v_DrugCode,
																(int)phDrgPtr->Op,
																(int)Unit_Price,
																(int)phDrgPtr->TotalPtn,
																(int)SysDate,				// Event Date
																(int)phDrgPtr->DocID,
																(int)v_DoctorPrDate,		// Request Date
																(int)v_DoctorPrID,			// Request Num.
																(int)AS400_Gadget_Action,
																(int)2						// Retries
															  );
							GerrLogFnameMini (	"gadgets_log", GerrId,
												"6005-spool SaveSaleRecord: AS400 err = %d.",
												(int)GadgetError);
						}
						else	// If Nihul Tikrot calls are disabled, disable Meishar calls too.
						{
							GadgetError = -1;
						}

						if (GadgetError != 0)
						{
							v_action = AS400_Gadget_Action;

							// Write to "holding" table!
							// DonR 09Dec2010: If the current action is a sale deletion, send AS/400 the
							// Prescription ID of the original sale, NOT the ID of the deletion, in second parameter.
							ExecSQL (	MAIN_DB, INS_gadget_spool,
										&v_PharmNum,			&GadgetRecipeID,
										&v_MemberID,			&v_IDCode,
										&v_DrugCode,			&v_service_code,
										&v_service_number,		&v_service_type,
										&phDrgPtr->Op,			&Unit_Price,

										&phDrgPtr->TotalPtn,	&SysDate,
										&phDrgPtr->DocID,		&v_DoctorPrDate,
										&v_DoctorPrID,			&v_action,
										&GadgetError,			&SysDate,
										&SysTime,				&IntZero,
										END_OF_ARG_LIST									);

							if (SQLERR_error_test ())
							{
								GerrLogToFileName ("gadgets_log",
													GerrId,
													"6005-spool: DB Error %d writing to gadget_spool.",
													(int)SQLCODE);

								v_ErrorCode = ERR_DATABASE_ERROR;
								break;
							}
						}	// Error notifying AS400 of sale.
					}	// Item sold got its participation from AS400 "Gadget" application.

					else
					{
						// If the "drug" purchased is a "gadget" but we didn't get participation
						// from the AS400, zero out the Link-to-Addition variable so the AS400
						// won't get the wrong idea about where participation came from.
						if (phDrgPtr->in_gadget_table != 0)
							phDrgPtr->LinkToAddition = 0;
					}
					// DonR 04Feb2019 end.


					// DonR 31Jul2023 User Story #469361: Add new drug-in-blood date logic. If certain
					// conditions are met, calculate start date, duration, and end date for a given
					// drug based on previous sales of the same drug (or a generic equivalent) from
					// prescriptions issued at the same doctor visit; if these conditions are not met,
					// just copy the appropriate values from the pharmacy-reported information and flag
					// the data as *not* calculated.
					//
					// First, copy in the default values from the pharmacy - this will save the complication
					// of having to set the defaults under more than one set of circumstances. Note that
					// StopUseDate = SysDate + Duration; it's the first day *after* the drug is finished,
					// assuming the member starts taking the drug on the day of purchase. At least for now,
					// we will calculate blood_last_date in the same way. (In reality, of course, this is
					// all pretty approximate!)
					phDrgPtr->blood_start_date		= SysDate;
					phDrgPtr->blood_duration		= phDrgPtr->Duration;
					phDrgPtr->blood_last_date		= StopUseDate;
					phDrgPtr->blood_data_calculated	= 0;

					// If the drug is a "treatment" that allows computed duration, see if all the doctor
					// prescriptions being sold against are present and "ratzif" (= continuous treatment).
					// DonR 19Dec2023: Calculate duration-in-blood only for drug sales. Also, initialize
					// RXL_FirstDate to the current system date rather than zero.
					// DonR 17Jul2024 Bug #334612: Disable computed-duration calculation if we don't get
					// positive values for both NumPerDose and DosesPerDay from the pharmacy.
					// DonR 01Aug2024 Bug #334612: Also enable computed-duration calculation only if the
					// pharmacy specified that this is an ongoing treatment ("tipul ratzif") - i.e. if
					// use_instr_template is zero. Since we no longer need to verify continuous treatment
					// against the doctor_presc table, there's really no point in reading that table at
					// all - we can trust the list of prescriptions that the pharmacy sent.
					// DonR 07Aug2024 BUG FIX: The previous (01Aug2024) fix had the comparison wrong - it
					// had "!= 0" where it should have been "== 0".
					if ((v_ActionType					== DRUG_SALE	)	&&	// This is a drug sale (DonR 19Dec2023).
						(phDrgPtr->DL.largo_type		== 'T'			)	&&	// This is a "treatment" (i.e. a normal drug).
						(phDrgPtr->DL.compute_duration					)	&&	// Duration computation is enabled for this drug (according to drug_shape).
						(phDrgPtr->NumPerDose			>  0			)	&&	// DonR 17Jul2024.
						(phDrgPtr->DosesPerDay			>  0			)	&&	// DonR 17Jul2024.
						(phDrgPtr->use_instr_template	== 0			)	&&	// DonR 01Aug2024 - fixed 07Aug (from != to ==).
						(phDrgPtr->NumDocRxes			>  0			))		// Drug line has at least one "attached" doctor prescription.
					{
						short			FoundRxProblem		= 0;
						long			RxVisitNumber		= 0;
						int				EP_GroupToSearch	= 0;
						int				RXL_SoldUnits		= 0;
						int				TotalUnitsBought_i	= 0;
						int				TotalUsageDays_i	= 0;
						int				RXL_FirstDate		= SysDate;	// DonR 19Dec2023 fix initialization.
						int				OtherDrug;
						int				RxSubscript;
						float			TotalUnitsBought_f	= 0;
						float			TotalUsageDays_f	= 0;
						TDrugListRow	DP;		// Drug originally prescribed.

						// Scan through the pharmacy-supplied list of doctor prescriptions, checking that:
						// 1) There is at least one prescription on the list (actually, that's part of the "if" above).
						// 2) All prescriptions are from the same doctor visit.
						for (Rx = 0; Rx < phDrgPtr->NumDocRxes; Rx++)
						{
							RxSubscript = Rx + phDrgPtr->FirstRx;	// Just for convenience.

							if (Rx == 0)
							{
								RxVisitNumber = DocRx [RxSubscript].VisitNumber;

								if (RxVisitNumber < 1)
								{
									FoundRxProblem = 1;
									break;
								}
							}
							else
							{
								if (DocRx [RxSubscript].VisitNumber != RxVisitNumber)
								{
									FoundRxProblem = 1;
									break;
								}
							}

						}	// Loop through pharmacy-reported doctor prescriptions for this drug-line.

						// If we get here *without* setting FoundRxProblem TRUE, we've met the conditions for
						// computing the starting date, duration, and ending date for this drug prescribed
						// at this visit. If the sold drug as Economypri Group  = 0, disable finding rows by
						// matching that value.
						if (!FoundRxProblem)
						{
							EP_GroupToSearch = (phDrgPtr->DL.economypri_group > 0) ? phDrgPtr->DL.economypri_group : -9999;

							// DonR 19Dec2023: Add RowsFound to output so we know if we actually found any
							// previous sales; and added the current PrescriptionID value to the input so
							// we don't read the current sale (which was already INSERTed to pd_rx_link) as
							// a prior sale.
							// DonR 01Aug2023 Bug #334612: This query doesn't change - but as part of this
							// bug fix, pd_rx_link/prescription_type (which the query SELECTs by) is populated
							// based on what the pharmacy sent in use_instr_template and *not* on how the
							// doctor wrote the prescription.
							// DonR 10Sep2024 Bug #334612 RE-OPENED: In order to avoid errors when the member
							// has bought drugs with different package sizes OR the doctor has prescribed
							// equivalent drugs with different package sizes, we need to compute the number of
							// pills/capsules/whatever *separately* for each past purchase. In order to do this,
							// I added a JOIN with drug_list to the database query, and the query now handles
							// the multiplication itself and returns a single total-units number instead of
							// separate OP and units numbers.
							ExecSQL (	MAIN_DB, GetPreviousDrugSaleTotalsByVisitNumber,
										&RXL_FirstDate,		&RXL_SoldUnits,			&RowsFound,

										&RxVisitNumber,		&v_RecipeIdentifier,	&phDrgPtr->DrugCode,
										&EP_GroupToSearch,	&v_MemberID,			END_OF_ARG_LIST			);

							Conflict_Test (reStart);

							if ((SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE) || ((SQLCODE == 0) && (RowsFound == 0)))
							{
								// No previous purchases found - reset OP/Units values to zero, out of pure
								// paranoia, and set first purchase date to today.
								RXL_SoldUnits	= 0;
								RXL_FirstDate	= SysDate;
							}
							else
							{
								if (SQLERR_error_test ())
									{
										SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
										break;
									}
							}

							// If we get here, we either read previous-purchase values or else got a
							// legitimate not-found "error". In either case, compute the duration and
							// stop-use date based on everything we know, including the *current*
							// usage instructions.

							// DonR 07Aug2023: We also need to look at other drug-lines in the *current*
							// sale request, since it's possible that both the prescribed drug and a
							// generic equivalent are being sold at the same time, based on the same
							// set of prescriptions issued at the same doctor visit. Note that if the
							// sold drug does not have an Economypri group associated with it, there's
							// nothing to do here.
							// DonR 01Aug2024 Bug #334612: Since we no longer need to verify continuous
							// treatment against the doctor_presc table, there's really no point in
							// reading that table at all - we can trust the list of prescriptions that
							// the pharmacy sent. Instead, just look at what the pharmacy sent for
							// use_instr_template to make sure the drug was sold for "tipul ratzif".
							if (EP_GroupToSearch > 0)
							{
								// Loop through all the drugs in the sale request, skipping past the current
								// one and any drug that is not a generic match for the current one OR is
								// being sold for non-continuous treatment.
								for (OtherDrug = 0; OtherDrug < v_NumOfDrugLinesRecs; OtherDrug++)
								{
									if (	(OtherDrug								== i)					||
											(phDrgs[OtherDrug].DL.economypri_group	!= EP_GroupToSearch)	||
											(phDrgs[OtherDrug].use_instr_template	!= 0)						)
									{
										continue;
									}

									// If we get here, we've found a different drug in the current sale request that
									// is a generic match for the current drug and was sold for continuous treatment
									// ("tipul ratzif"). Now loop through and see if any of its prescriptions match
									// the current drug's Visit Number. (Note that for this purpose, not all the
									// prescriptions for the drug need to be from the same doctor visit - the logic
									// is more like the logic used to select historical purchases above.)
									for (Rx = 0; Rx < phDrgs[OtherDrug].NumDocRxes; Rx++)
									{
										RxSubscript = Rx + phDrgs[OtherDrug].FirstRx;	// Just for convenience.

										if (DocRx [RxSubscript].VisitNumber == RxVisitNumber)
										{
											// Found a matching continuous-treatment prescription; add
											// its quantities to the total for computing duration. We
											// use the Effective Package Size for the drug being sold
											// rather than the prescribed drug *or* the drug being sold
											// in the current Prescription Line of the sale request.
											RXL_SoldUnits +=		(DocRx [RxSubscript].OP * phDrgs[OtherDrug].DL.effective_package_size)
																+	DocRx [RxSubscript].Units;
										}	// Found an other-drug prescription from the same doctor visit as the current drug.
									}	// Loop through prescriptions for a generic-equivalent drug in the same sale request.
								}	// Loop through the current sale request looking for generic equivalents of the current drug.
							}	// The current drug has a non-zero EconomyPri Group Code, so look for generic equivalents in this sale request.

							// If the Largo Prescribed is different from what's being sold now, we need to read
							// its effective package size in order to compute total quantity bought up to now.
							if ((phDrgPtr->DrugCode != phDrgPtr->Orig_Largo_Code) && (phDrgPtr->Orig_Largo_Code > 0))
							{
								// Just in case we couldn't read the prescribed drug, default to using the same drug info.
								if (!read_drug (phDrgPtr->Orig_Largo_Code, 999999999, NULL, true, &DP, NULL))
								{
									DP = phDrgPtr->DL;

									// DonR 01Nov2020: Add logging of any unexpected DB error reading drug_list.
									if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
									{
										SQLERR_error_test ();
									}
								}	// Read_drug failed to read the prescribed drug.
							}	// The prescribed drug is different from the drug being sold.
							else
							{
								DP.effective_package_size = phDrgPtr->DL.effective_package_size;
							}	// The drug being sold is the same as what was prescribed, so just copy Effective Package Size.

							// DonR 01Jul2024 HOT FIX: We were using the "naked" DL structure to get the package size
							// for the currently-purchased drug - but DL has not been initialized, so the package size
							// was essentially random. Instead, we need to reference the *actual* DL structure attached
							// to phDrgPtr (= &phDrgs[i]).
							// DonR 10Sep2024 Bug #334612 RE-OPENED: GetPreviousDrugSaleTotalsByVisitNumber now returns
							// a single number of total units bought in past purchases, instead of OP plus units.
							TotalUnitsBought_i =		RXL_SoldUnits
													+	(phDrgPtr->Op		* phDrgPtr->DL.effective_package_size)	// Current purchase in terms of sold drug OP size.
													+	phDrgPtr->Units;

							// Convert the number of units to a float, and multiply by our "fudge factor",
							// defined as a percentage to increase the supply of the drug.
							TotalUnitsBought_f = (float)TotalUnitsBought_i * (1.0 + ((float)AdjustCalculateDurationPercent / 100.0));

							// Daily usage is based on what the pharmacy sends us for the *current* sale.
							// Add 0.995 because the requirement is to round up a day even if there's a
							// tiny remainder.
							// DonR 19Dec2023 BUG FIX: I forgot that the pharmacy reports "units per dose" multiplied by 100,
							// since otherwise we couldn't account for things like half-pill dosages. So to get the right
							// Total Units Bought, we need to divide by 100!
							TotalUsageDays_f = (TotalUnitsBought_f / (float)((float)phDrgPtr->NumPerDose * (float)phDrgPtr->DosesPerDay / 100.0)) + 0.995;
							TotalUsageDays_i = (int)TotalUsageDays_f;

							phDrgPtr->blood_start_date		= RXL_FirstDate;
							phDrgPtr->blood_duration		= TotalUsageDays_i;
							phDrgPtr->blood_last_date		= AddDays (RXL_FirstDate, TotalUsageDays_i);
							phDrgPtr->blood_data_calculated	= 1;
						}	// FoundRxProblem is false, so lookup history and calculate duration.
					}	// The drug is a "treatment" that allows computed duration, and pharmacy reported at least one prescription for it.


					// Insert or update prescription_drugs row.
					if (AddNewRows)
					{
						NumPrescriptionDrugsRowsTriedToAdd++;	// DonR 28Jul2021 diagnostics.

						// DonR 22Nov2005: If the "drug" purchased is a "gadget" but we didn't
						// get participation from the AS400, zero out the Link-to-Addition
						// variable so the AS400 won't get the wrong idea about where
						// participation came from. (04Feb2019: This may be redundant now,
						// but it's harmless.)
						if (((phDrgPtr->ParticipMethod % 10)	!= FROM_GADGET_APP)	&&
							( phDrgPtr->in_gadget_table			!= 0))
						{
							phDrgPtr->LinkToAddition = 0;
						}

						// Insert new prescription_drugs row.
						// DonR 23May2019 CR #29169: Fixed assignment of discount percentages. Member_discount_pt is not reported by the pharmacy,
						// and so it's now set to zero on INSERT here. (It could also get a value from the members table the way it does in Trn. 6003,
						// if Iris wants.) And price_extension was being set from phDrgPtr->Discount, a variable that was never assigned anything
						// other than zero! Instead, price_extension is now set from phDrgPtr->MemberDiscPC (which is the drug discount, *not*
						// the member's "global" discount), and I've deleted Discount from the Msg6005Drugs structure.
						// DonR 02Aug2020 BUG FIX: I was inserting the Doctor ID Type from the obsolete variable v_DocIDType, which is never assigned
						// any value in this transaction. Instead, the value should come from the drug-line variable phDrgPtr->DocIDType.
						// DonR 24May2022 BUG FIX: Use sq_VoucherAmtUsed instead of the value in phDrgPtr->VoucherAmtUsed; this gives
						// us a correctly-signed number even if we're performing a sale deletion and we have to do a retry because of
						// a DB-contention problem.
						// DonR Feb2023 User Story #232220: Add paid_for to columns INSERTed.
						// DonR 27Mar2023 User Story #432608: Added 10 new columns to insert.
						// DonR 31Jul2023 User Story #469361: Add 4 columns for new blood-duration logic.
						// DonR 04Feb2024 User Story #540234: Add NumCannabisProducts to insert.
						ExecSQL (	MAIN_DB, TR6005spool_INS_prescription_drugs,
									&v_RecipeIdentifier,					&LineNum,							&v_MemberID,
									&v_IDCode,								&phDrgPtr->DrugCode,				&report_as400_flag,
									&sq_Op,									&sq_Units,							&phDrgPtr->Duration,
									&StopUseDate,							&SaleDate,							&SaleTime,
									&delete_flag,			 				&v_ActionType,						&phDrgPtr->FixedPrice,
															
									&phDrgPtr->MemberDiscPC,				&phDrgPtr->LinkToAddition,			&phDrgPtr->OpDrugPrice,
									&v_ActionType,							&v_ErrorCode,						&phDrgPtr->MemberPtnCode,
									&phDrgPtr->MemberPtnCode,				&phDrgPtr->PrescSource,				&phDrgPtr->MacabiPriceFlag,
									&v_PharmNum,							&v_InstituteCode,					&phDrgPtr->SupplierDrugPrice,
									&StopBloodDate,							&sq_TotalDrugPrice,					&phDrgPtr->StockOP,

									&phDrgPtr->StockUnits,					&sq_TotalMemberPrice,				&sq_TotalMemberPrice,
									&v_Comm_Error,							&phDrgPtr->THalf,					&phDrgPtr->DocID,
									&phDrgPtr->DocIDType,					&phDrgPtr->InHealthBasket,			&phDrgPtr->SpecPrescNum, /* DocIDType fix 02Aug2020 */
									&phDrgPtr->SpecPrescNumSource,			&DocRx [phDrgPtr->FirstRx].PrID,	&DocRx [phDrgPtr->FirstRx].FromDate,
									&phDrgPtr->Orig_Largo_Code,				&PW_SubstPermitted,					&phDrgPtr->NumPerDose,
															
//	Fixed version - migrate with new SR.EC					&phDrgPtr->DosesPerDay,					&ShortZero /* 23May2019 CR #29169 /,	&phDrgPtr->ParticipMethod,
									&phDrgPtr->DosesPerDay,					&phDrgPtr->MemberDiscPC,			&phDrgPtr->ParticipMethod,
									&IntZero /* No PW ID */,				&v_ingr_1_code,						&v_ingr_2_code,
									&v_ingr_3_code,							&v_ingr_1_quant,					&v_ingr_2_quant,
									&v_ingr_3_quant,						&v_ingr_1_quant_std,				&v_ingr_2_quant_std,
									&v_ingr_3_quant_std,					&phDrgPtr->DrugDiscountAmt,			&phDrgPtr->DrugDiscountCode,

									&phDrgPtr->tikrat_mazon_flag,			&phDrgPtr->IshurWithTikra,			&phDrgPtr->IshurTikraType,
									&phDrgPtr->rule_number,					&v_CreditYesNo,						&phDrgPtr->use_instr_template,
									&phDrgPtr->how_to_take_code,			&phDrgPtr->unit_code,				&phDrgPtr->course_treat_days,
									&phDrgPtr->course_len_days,				&phDrgPtr->course_len,				&phDrgPtr->course_len_units,
									&phDrgPtr->days_of_week,				&phDrgPtr->times_of_day,			&phDrgPtr->side_of_body,

									// DonR 25Jun2013: New "Bakarat Kamutit" fields are blank for sales added through spool.
									// Doctor Visit Date is no longer on the prescription_drugs level, so it's zeroed here.
									&phDrgPtr->ElectPrStatus,				&phDrgPtr->use_instr_changed,		&ShortZero /* why_future_sale_ok */,
									&ShortZero /* qty_limit_chk_type */,	&IntZero /* qty_lim_ishur_num */,	&IntZero /* vacation_ishur_num */,
									&IntZero /* Visit Date */,				&phDrgPtr->DocFacility,				&phDrgPtr->NumRxLinks,
									&phDrgPtr->BarcodeScanned,				&phDrgPtr->IsDigital,				&sq_VoucherAmtUsed,
									&ShortZero /* qty_limit_class_code */,	&paid_for,							&phDrgPtr->UsageInstrGiven,			// DonR 27Mar2023 begin.

									&phDrgPtr->MaccabiOtcPrice,				&phDrgPtr->SalePkgPrice,			&phDrgPtr->SaleNum4Price,
									&phDrgPtr->SaleNumBuy1Get1,				&phDrgPtr->Buy1Get1Savings,			&phDrgPtr->ByHandReduction,
									&phDrgPtr->IsConsignment,				&phDrgPtr->NumCourses,				&phDrgPtr->blood_start_date,		// DonR 27Mar2023 end, 31Jul2023 begin.
									&phDrgPtr->blood_duration,				&phDrgPtr->blood_last_date,			&phDrgPtr->blood_data_calculated,	// DonR 31Jul2023 end.
									&phDrgPtr->NumCannabisProducts,			END_OF_ARG_LIST																				);

// GerrLogMini (GerrId, "%s6005s: INSERT %d/%d (Largo %d) - SQLCODE %d, %d rows affected.", ((LineNum == 1) ? "\n" : ""), v_RecipeIdentifier, LineNum, phDrgPtr->DrugCode, SQLCODE, sqlca.sqlerrd[2]);
						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							// DonR 16Nov2021: For some reason, this INSERT sometimes fails to do anything (rows affected = 0)
							// even though the database didn't give us any error. In this case, force a database error and
							// write an appropriate message to log. (We'll see if the same rows fail to INSERT on a retry...)
							// DonR 18May2022: I've added logic in MacODBC.h to detect these "silent INSERT failures" and report
							// a "synthetic" error code: SQL_SILENT_INSERT_FAILURE = -29000. Once this change goes into Production
							// and we see that it's working (in other words, we see at least one SQL error -29000 logged), we can
							// delete this "else" since we will no longer have to explicitly check rows_affected after the INSERT.
							if (SQLERR_code_cmp (SQLERR_no_rows_affected) == MAC_TRUE)
							{
								GerrLogMini (	GerrId, "6005s: %d/%d (Largo %d) got SQLCODE %d on INSERT, but no rows were written - sending ERR_DATABASE_ERROR.",
												v_RecipeIdentifier, LineNum, phDrgPtr->DrugCode, SQLCODE);

								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}

						NumPrescriptionDrugsRowsAdded++;	// DonR 28Jul2021 diagnostics.
					}	// Need to insert.

					else
					{	// Need to update.
						NumPrescriptionDrugsRowsTriedToUpdate++;	// DonR 28Jul2021 diagnostics.

						// DonR 27Jul2021 BUG FIX: If the SELECT of the prescription_drugs row by Prescription ID
						// and Largo Code failed, that's a serious error - either we need to retry the transaction
						// (if it was some kind of DB contention error) or else log a severe error and reject the
						// transaction. (Note that row-not-found *is* a serious error in this case - it means the
						// pharmacy sent a Largo Code in 6005 that was *not* present in 6003, and that's not something
						// they're allowed to do.) So after the fix above, if we get here it means that the SELECT
						// *did* succeed - and we don't want to make the UPDATE conditional. We just want to attempt
						// the UPDATE and trap errors the normal way.
						//
						// Finally, update prescription_drugs. Note that this update has to happen
						// after the "gadget" logic, since the latter can change macabi_price_flg.
						// Note also that delivered_flg gets the same value as Action Type; this allows
						// routines like get_drugs_in_blood() to select only drug sales without having
						// to add an additional element to the WHERE clause.
						// DonR 23May2019 CR #29169: The value sent by pharmacy in phDrgPtr->MemberDiscPC is the
						// drug discount (set by the program in Trn. 6003), *not* the discount percent from the 
						// members table. Thus it should *not* be stored in member_discount_pt; if anywhere,
						// it should be in price_extension. However, even this is not necessary in the UPDATE
						// version of Trn. 6005, since price_extension is set by Trn. 6003 and the pharmacy
						// is not allowed to change it.
						// DonR 24May2022 BUG FIX: Use sq_VoucherAmtUsed instead of the value in phDrgPtr->VoucherAmtUsed; this gives
						// us a correctly-signed number even if we're performing a sale deletion and we have to do a retry because of
						// a DB-contention problem.
						// DonR Feb2023 User Story #232220: Add paid_for to columns UPDATEd.
						// DonR 27Mar2023 User Story #432608: Added 10 new columns to update.
						// DonR 31Jul2023 (24Dec2023 BUG FIX!) User Story #469361: Add 4 columns for new blood-duration logic.
						// DonR 04Feb2024 User Story #540234: Add NumCannabisProducts to update.
						ExecSQL (	MAIN_DB, TR6005spool_UPD_prescription_drugs,
									&sq_Op,							&sq_Units,						&v_ActionType,
									&report_as400_flag,				&phDrgPtr->StockOP,				&phDrgPtr->StockUnits,
									&sq_TotalDrugPrice,				&sq_TotalMemberPrice,			&phDrgPtr->MemberDiscPC,
									&phDrgPtr->MemberDiscPC,		&v_Comm_Error,					&phDrgPtr->SpecPrescNum,
								
									&phDrgPtr->SpecPrescNumSource,	&phDrgPtr->SupplierDrugPrice,	&phDrgPtr->DrugDiscountAmt,
									&phDrgPtr->DrugDiscountCode,	&v_ingr_1_code,					&v_ingr_2_code,
									&v_ingr_3_code,					&v_ingr_1_quant,				&v_ingr_2_quant,
									&v_ingr_3_quant,				&v_ingr_1_quant_std,			&v_ingr_2_quant_std,
								
									&v_ingr_3_quant_std,			&phDrgPtr->use_instr_template,	&phDrgPtr->how_to_take_code,
									&phDrgPtr->unit_code,			&phDrgPtr->DosesPerDay,			&phDrgPtr->NumPerDose,
									&phDrgPtr->Duration,			&phDrgPtr->course_treat_days,	&phDrgPtr->course_len_days,
									&phDrgPtr->course_len,			&phDrgPtr->course_len_units,	&phDrgPtr->days_of_week,
								
									&phDrgPtr->times_of_day,		&phDrgPtr->side_of_body,		&phDrgPtr->ElectPrStatus,
									&phDrgPtr->use_instr_changed,	&SaleDate,						&SaleTime,
									&phDrgPtr->MacabiPriceFlag,		&phDrgPtr->LinkToAddition,		&phDrgPtr->NumRxLinks,
									&sq_VoucherAmtUsed,				&paid_for,						&phDrgPtr->UsageInstrGiven,	// DonR 27Mar2023 begin.

									&phDrgPtr->MaccabiOtcPrice,		&phDrgPtr->SalePkgPrice,		&phDrgPtr->SaleNum4Price,
									&phDrgPtr->SaleNumBuy1Get1,		&phDrgPtr->Buy1Get1Savings,		&phDrgPtr->ByHandReduction,
									&phDrgPtr->IsConsignment,		&phDrgPtr->NumCourses,			&phDrgPtr->blood_start_date,		// DonR 27Mar2023 end, 02Aug2023 begin.
									&phDrgPtr->blood_duration,		&phDrgPtr->blood_last_date,		&phDrgPtr->blood_data_calculated,	// DonR 02Aug2023 end.
									&phDrgPtr->NumCannabisProducts,

									&v_RecipeIdentifier,			&phDrgPtr->LineNo,				END_OF_ARG_LIST						);

//GerrLogMini (	GerrId, "%s6005s: Update %d/%d (Largo %d, i = %d) - SQLCODE %d, %d rows affected.",
//				((phDrgPtr->LineNo == 1) ? "\n" : ""), v_RecipeIdentifier, phDrgPtr->LineNo, phDrgPtr->DrugCode, i, SQLCODE, sqlca.sqlerrd[2]);

						Conflict_Test (reStart);

						// DonR 23Aug2020: If we already know that we weren't able to read the drug line
						// according Prescription ID/Largo Code, log a "not found" error rather than
						// produce a whole major-error diagnostic in the log. Note that at least for now,
						// we're not flagging this as a major database error and aborting the transaction -
						// perhaps we should, but I don't want to change actual functionality when nobody
						// has complained about how it works at present.
						// DonR 19Jan2021: In fact, we *are* setting a major database error when the drug
						// line couldn't be read or updated - it was being done below, but we were logging
						// an additional major DB error to the log. Instead, just set v_ErrorCode here -
						// the result is the same, but the log is cleaner.
						// DonR 27Jul2021 BUG FIX: We now handle row-not-found and any other DB errors above,
						// immediately after SELECTing the prescription_drugs row - and any such error is
						// treated as a fatal one, since pharmacies are really not supposed to send drug lines
						// that were not present in Transaction 6003. So the only error-handling here will
						// deal with failures in the UPDATE statement - and of course those are all going to
						// be treated seriously.
						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
						else
						{
							// DonR 24Aug2021 BUG FIX: Added diagnostic and force an error if we didn't update
							// anything - this should never happen in real life, but somehow it does seem to 
							// be happening for some private-pharmacy spooled 6005's.
							if (SQLERR_code_cmp (SQLERR_no_rows_affected) == MAC_TRUE)
							{
								GerrLogMini (	GerrId, "6005s: No rows updated for %d line %d (Largo %d)!",
												v_RecipeIdentifier, phDrgPtr->LineNo, phDrgPtr->DrugCode);

								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}	// No rows updated!
							else
							{
								NumPrescriptionDrugsRowsUpdated++;	// DonR 28Jul2021 diagnostics.
							}	// A row was updated.
						}	// No database error.
					}	// Need to update prescription_drugs row.
				}	// Loop through drugs.


				// If any SQL errors were detected inside drug loop, break out of dummy loop.
				// DonR 21Jul2011: If we've already logged an error, there's no need to log it again.
				// DonR 28Jul2021 BUG FIX: If we hit a DB-contention error, v_ErrorCode will *not*
				// be set but reStart will be TRUE. If this is the case, we need to break out of the
				// "tries" loop and try re-performing the whole transaction - otherwise we're missing
				// out on at least one SQL operation that failed, but otherwise proceeding on our
				// merry way. So I added "reStart" to the "if" statement immediately below.
				if ((v_ErrorCode == ERR_DATABASE_ERROR) || (reStart))
				{
					break;	// If we have already trapped a DB error, break out of loop.
				}
				else
				{
					// This really should be redundant, but leave it here just in case.
					// DonR 27Nov2025: If the "leftover" SQL error is "not found", log something - but
					// not the full error report that alerts computer-room operators.
					if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
					{
						GerrLogMini (GerrId,	"Trn 6005-spool: After prescription_drugs INSERT/UPDATE, "
												"we have a residual not-found SQLCODE of %d.", SQLCODE);
					}
					else
					{
						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}
				}


				// Update max_drug_date in members table.
				// DonR 05Sep2006: Don't do this for non-Maccabi OTC purchases.
				if ((v_ActionType		== DRUG_SALE)			&&
					(delete_flag		!= ROW_SYS_DELETED)		&&
					(max_drug_date		>  sq_maxdrugdate)		&&
					(v_MemberID			>  0)					&&
					(v_MemberBelongCode	== MACABI_INSTITUTE))
				{
					ExecSQL (	MAIN_DB, UPD_members_max_drug_date,
								&max_drug_date,		&v_MemberID,
								&v_IDCode,			END_OF_ARG_LIST		);

					Conflict_Test (reStart);

					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}	// Need to update max_drug_date in members table.

				// If this is a deletion of all drugs in a sale, mark the original
				// prescriptions row as deleted.
				// DonR 04Jul2016: Instead of repeating essentially the same code in eight places (i.e. two
				// tables, Transactions 5005 and 6005, online and spooled versions), created a single function
				// MarkDeleted() that handles the deletion-flag update. It returns zero if all went OK, and
				// anything else indicates a database error.
				if ((v_ActionType == SALE_DELETION) && (delete_flag	!= ROW_SYS_DELETED))
				{
					if (MarkDeleted ("6005sp", v_DeletedPrID, 0, v_RecipeIdentifier) != 0)
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}	// Deletion processing: need to update original sale as completely deleted.

				// DonR 03Dec2024 User Story #309732: In "mark as paid" mode, suppress the "ordinary" table updates.
				if (v_ActionType == MARK_AS_PAID)
				{
					FORCE_SQL_OK;	// So we'll think all these updates succeeded without error.
				}
				else
				{
					// Insert or update prescriptions row.
					if (AddNewRows)
					{
						// DonR 09Aug2021 User Story #163882: Write the member's "darkonai_type" flag to the
						// prescriptions table. For now, we are *not* adding any logic to ensure that the
						// pharmacy has in fact sent 100% "hishtatfut" for all items being sold to a darkonai-plus
						// purchaser who is supposed to receive only "shovar" discounts.
						// DonR Feb2023 User Story #232220: Add paid_for to columns INSERTed.
						// DonR 20Apr2023 User Story #432608: Add Magento Order Number and the pharmacy-reported
						// value for (internal) Online Order Number.
						ExecSQL (	MAIN_DB, INS_prescriptions,
									&v_PharmNum,			&v_InstituteCode,
									&v_PriceListCode,		&v_MemberID,
									&v_IDCode,				&v_MemberBelongCode,
									&IntZero,				&ShortZero,
									&HeaderPrescSource,		&v_RecipeIdentifier,

									&v_SpecialConfNum,		&v_SpecialConfSource,
									&SaleDate,				&SaleTime,
									&v_ErrorCode,			&v_NumOfDrugLinesRecs,
									&v_CreditYesNo,			&v_MoveCard,
									&ShortZero,				&v_TerminalNum,

									&v_InvoiceNum,			&v_UserIdentification,
									&v_PharmRecipeNum,		&Member.maccabi_code,
									&IntZero,				&report_as400_flag,
									&v_Comm_Error,			&v_PharmPtnCode,
									&ShortZero,				&v_ClientLocationCode,

									&IntZero,				&v_MonthLog,
									&v_PriceListCode,		&IntZero,
									&IntZero,				&ShortZero,
									&v_ActionType,			&delete_flag,
									&IntZero,				&v_ReasonToDispense,

									&v_ActionType,			&v_DeletedPrID,
									&v_DeletedPrPharm,		&v_DeletedPrDate,
									&v_DeletedPrPhID,		&IntZero,
									&v_CardOwnerIDCode,		&v_CreditLinePmts,
									&v_PaymentType,			&v_RetnReasonCode,

									&ShortZero,				&ShortZero,
									&v_TotalTikraDisc,		&v_TotalCouponDisc,
									&TransactionID,			&ShortZero,
									&ShortZero,				&Member.insurance_type,
									&online_order_num,		&v_CreditYesNo,

									&v_6003CommError,		&Member.darkonai_type,
									&paid_for,				&MagentoOrderNum,
									END_OF_ARG_LIST										);

						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}	// In add-new-rows mode.

					else
					{
						// Update PRESCRIPTIONS table.
						// DonR 20Aug2018: Added update of card_owner_id (which is actually the TZ of the second authorizing
						// pharmacist after we've sent "need 2 cards to sell" errors) and card_owner_id_code (which is currently
						// "reserved for future use"). These two fields are written to RK9021P/EAZHZR and EAPUUA.
						// DonR Feb2023 User Story #232220: Add paid_for to columns UPDATEd.
						// DonR 20Apr2023 User Story #432608: Add MagentoOrderNum and online_order_num to UPDATE. Note that in
						// 6005-online, online_order_num will not be different from what was already there.
						ExecSQL (	MAIN_DB, TR6005_UPD_prescriptions,
									&v_InvoiceNum,			&v_UserIdentification,		&v_PharmRecipeNum,
									&ShortZero,				&v_ClientLocationCode,		&v_MonthLog,
									&v_ActionType,			&NOT_REPORTED_TO_AS400,		&v_CreditYesNo,
									&SaleDate,				&SaleTime,					&v_ErrorCode,
					
									&ShortZero,				&v_RetnReasonCode,			&v_CreditLinePmts,
									&v_PaymentType,			&v_TotalTikraDisc,			&v_TotalCouponDisc,
									&ShortZero,				&v_ReasonToDispense,		&v_PharmPtnCode,
									&v_6003CommError,		&v_CardOwnerID,				&v_CardOwnerIDCode,
									&paid_for,				&MagentoOrderNum,			&online_order_num,
					
									&v_RecipeIdentifier,	END_OF_ARG_LIST										);

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}

						// DonR 22May2013: Also mark prescription_msgs and prescription_usage rows as delivered. Since the
						// delivery isn't complete unless we write to the database without any problems, we can piggy-back
						// on the same error handling. (Note that "no rows affected" doesn't throw an error in
						// SQLCODE/SQLERR_error_test.)
						// Note also that this UPDATE should be applicable only in update mode - if AddNewRows is set TRUE,
						// there should be no corresponding prescription_msgs rows to update.
						if (SQLCODE == 0)
						{
							ExecSQL (	MAIN_DB, UPD_prescription_msgs_mark_delivered,
										&SysDate,				&SysTime,				&v_ActionType,
										&NOT_REPORTED_TO_AS400,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);

							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}

						// Note this is another UPDATE that should be applicable only in update mode - if AddNewRows is
						// set TRUE, I don't believe there will be any corresponding prescription_usage rows to update.
						if (SQLCODE == 0)
						{
							ExecSQL (	MAIN_DB, UPD_prescription_usage_mark_delivered,
										&SysDate,				&SysTime,				&v_ActionType,
										&NOT_REPORTED_TO_AS400,	&v_RecipeIdentifier,	END_OF_ARG_LIST	);

							if (SQLERR_error_test ())
							{
								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;
							}
						}

						Conflict_Test (reStart);

						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}	// Update (rather than insert) prescriptions row and other tables.


					// DonR 07Mar2023: Moved three update/insertion operations out of the "if updating"
					// block, so that they will execute whether where in update *or* insert mode:
					//   1) Update online_orders with sale data.
					//   2) Insert prescription_vouchers.
					//   3) New operations to update previous sales with new payment-method info, and add
					//      amounts for these sales to pharmacy_daily_sum.

					// 21Jun2018 Online Orders (SuperPharm) - update online order to reflect sale completion.
					// DonR 07Mar2023: Added condition on delete_flag == ROW_NOT_DELETED so that redundant
					// retransmissions of spooled transactions won't update the online_orders table.
					if ((SQLCODE			== 0)				&&
						(v_ActionType		== DRUG_SALE)		&&
						(delete_flag		== ROW_NOT_DELETED)	&&
						(online_order_num	>  0))
					{
						ExecSQL (	MAIN_DB, UPD_online_orders_RecordSaleAgainstOrder,
									&v_RecipeIdentifier,	&v_PharmNum,
									&SysDate,				&SysTime,
									&online_order_num,		&Phrm_info.web_pharmacy_code,
									&Phrm_info.owner,		END_OF_ARG_LIST					);

						Conflict_Test (reStart);
					}

					// DonR 02Jun2021 User Story #163882: Write any voucher-used info to prescription_vouchers.
					if (SQLCODE == 0)
					{
						for (VoucherNum = 0; (VoucherNum < NumVouchers) && (SQLCODE == 0); VoucherNum++)
						{
							ExecSQL	(	MAIN_DB, TR6005_INS_prescription_vouchers,
										&v_RecipeIdentifier,								&Voucher [VoucherNum].voucher_num,
										&v_MemberID,										&v_IDCode,
										&Voucher [VoucherNum].voucher_type,					&Voucher [VoucherNum].voucher_discount_given,
										&Voucher [VoucherNum].voucher_amount_remaining,		&Voucher [VoucherNum].original_voucher_amount,
										&SaleDate,											&SysDate,
										&SysTime,											&NOT_REPORTED_TO_AS400,
										END_OF_ARG_LIST																							);

							// DonR 06Mar2023: In "online" mode, we should never see a duplicate-key error
							// on this INSERT. However, it's entirely possible (I think) in spool mode.
							// Rather than do anything dramatic, just ignore duplicate-key errors.
							if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_TRUE)
							{
								sqlca.sqlcode = SQLCODE = 0;
							}

							Conflict_Test (reStart);
						}
					}	// No previous DB error, so try adding vouchers to prescription_vouchers.

					// DonR 04Feb2024 User Story #540234: Write any cannabis product details to pd_cannabis_products.
					if (SQLCODE == 0)	// No previous DB error.
					{
						short	LineNumber;
						int		GroupLargoCode;

						for (Product = 0; (Product < TotalNumCannabisProducts) && (SQLCODE == 0); Product++)
						{
							LineNumber		= phDrgs [CannabisProduct [Product].DrugLineSubscript].LineNo;
							GroupLargoCode	= phDrgs [CannabisProduct [Product].DrugLineSubscript].DrugCode;

							// DonR 18Mar2024: If this is a deletion, "flip" some numbers negative.
							if (v_ActionType == SALE_DELETION)
							{
								if (CannabisProduct [Product].op		> 0)
									CannabisProduct [Product].op		*= -1;

								if (CannabisProduct [Product].units		> 0)
									CannabisProduct [Product].units		*= -1;

								if (CannabisProduct [Product].product_sale_amount	> 0)
									CannabisProduct [Product].product_sale_amount	*= -1;

								if (CannabisProduct [Product].product_ptn_amount	> 0)
									CannabisProduct [Product].product_ptn_amount	*= -1;
							}

							ExecSQL	(	MAIN_DB, TR6005_INS_pd_cannabis_products,
										&v_RecipeIdentifier,
										&LineNumber,
										&CannabisProduct [Product].cannabis_product_code,
										&CannabisProduct [Product].cannabis_product_barcode,
										&GroupLargoCode,
										&CannabisProduct [Product].op,
										&CannabisProduct [Product].units,
										&CannabisProduct [Product].price_per_op,
										&CannabisProduct [Product].product_sale_amount,
										&CannabisProduct [Product].product_ptn_amount,
										&ROW_NOT_DELETED,
										&NOT_REPORTED_TO_AS400,
										&SysDate,
										&SysTime,
										END_OF_ARG_LIST											);

							Conflict_Test (reStart);

							// DonR 03Jun2025: If a pharmacy sent duplicate cannabis-product information,
							// log a message and try to fail gracefully.
							if (SQLERR_code_cmp (SQLERR_not_unique) == MAC_TRUE)
							{
								GerrLogMini (GerrId,	"6005-spool: Duplicate cannabis-product information from Pharmacy %d: "
														"Prescription ID %d, Line #%d, "
														"Product line number %d, Group Largo %d, Cannabis Product Code %d, "
														"Barcode %ld, OP %d, Units %d, Ptn %d. Rejecting!",
														v_PharmNum, v_RecipeIdentifier, LineNumber,
														Product, GroupLargoCode, CannabisProduct [Product].cannabis_product_code,
														CannabisProduct [Product].cannabis_product_barcode,
														CannabisProduct [Product].op, CannabisProduct [Product].units,
														CannabisProduct [Product].product_ptn_amount);

								SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
								break;	// So we don't log the database error again and create a panic.
							}	// INSERT failed on duplicate cannabis product.
						}
					}	// No previous DB error, so try adding product details to pd_cannabis_products.

				}	// DonR 09May2024 User Story #309732: Execute these updates only if we're *not*
					// in "mark as paid" mode.


				// DonR 05Mar2023 User Story #232220: If there is a list of previous sales to mark
				// as "paid", update prescriptions, prescription_drugs, and pharmacy_daily_sum. Note
				// that the pharmacy_daily_sum update has to be done first, since the relevant SQL
				// selects only *unpaid* sales to add to the Daily Sum table. This avoids adding the
				// same sale to the totals twice.
				// Note that (at least for now) we are *not* making these updates conditional on the
				// paid-for status of the current sale - even though it would be kind of crazy for
				// a not-yet-paid sale to include a list of previous sales that *are* now being paid.
				// We are also assuming that we will get a list of previous sales *only* when we are
				// selling stuff - deletions are still handled one at a time.
				// WORKINGPOINT: Should this happen in insert mode as well? I kind of think so... And
				// these SQL operations shouldn't cause problems if they're run more than once against
				// the same list of sales, I think.
				if (SQLCODE == 0)	// No previous DB error.
				{
					for (OtherSaleNum = 0; (OtherSaleNum < NumOtherSales) && (SQLCODE == 0); OtherSaleNum++)
					{
						// DonR 04Mar2024 User Story #232220: Pharmacies may, apparently, send the
						// last 6005 in the series with Credit Type 99 (= unpaid) and then include
						// the last Prescription ID in this list of transactions to mark "paid". In
						// order to avoid duplicate updates and other potential problems, we changed
						// the Credit Type up above if one of the "other sales" is in fact the current
						// sale. In this case, we also set the "other sale ID" to zero so we won't
						// update it again here.
						// DonR 02May2024 User Story #232220 YARPA BUG WORKAROUND: For some reason,
						// Yarpa is sending an "other sale" line along with deletion transactions
						// even if the deletion transaction is still "unpaid". This was causing the
						// deletion to be marked as "paid", and then a later update with the actual
						// Credit Type Used value wouldn't work because the SQL updates only rows
						// with paid_for = 0. The workaround is to skip the updates to prescriptions,
						// prescription_drugs, and pharmacy_daily_sum if the Credit Type Used value
						// is 99, since in fact this value means that the transaction should *not*
						// (yet) be marked as paid.
						if ((OtherSaleID [OtherSaleNum] == 0) || (OtherSaleCredLine [OtherSaleNum] == 99))
						{
							continue;
						}

						ExecSQL	(	MAIN_DB, UPD_pharmacy_daily_sum_from_prior_sale,
									&OtherSaleID [OtherSaleNum],	&Phrm_info.maccabi_pharmacy,
									&v_PharmNum,					&v_InstituteCode,
									&v_MonthLog,					&SysDate,
									&v_TerminalNum,					END_OF_ARG_LIST					);

						Conflict_Test (reStart);

						if (SQLCODE == 0)
						{
							// DonR 05Mar2024 User Story #232220: Use the Credit Type Used value from
							// the "extra sales" list, *not* the one reported for the current sale, to
							// update previous sales. There may be a mix of different Credit-Type values
							// in the list, since it's entirely possible that the member may be paying
							// for different purchases for different members. Also, we now update the
							// Payment Type value - although since we get this only for the current
							// transaction, we may be putting incorrect values there in some cases. I've
							// asked Iris if we should add Payment Method to the "extra sales" data sent
							// by the pharmacy instead of just copying it from the "header" Payment Type,
							// since we have 15 bytes there "reserved for future use" and this would use
							// up only 2 of them.
							ExecSQL	(	MAIN_DB, UPD_prescriptions_mark_paid,
										&OtherSaleCredLine	[OtherSaleNum],
										&OtherSalePmtType	[OtherSaleNum],
										&OtherSaleID		[OtherSaleNum],
										END_OF_ARG_LIST							);

							Conflict_Test (reStart);
						}

						if (SQLCODE == 0)
						{
							ExecSQL	(	MAIN_DB, UPD_prescription_drugs_mark_paid,
										&OtherSaleCredLine	[OtherSaleNum],
										&OtherSaleID		[OtherSaleNum],
										END_OF_ARG_LIST										);

							Conflict_Test (reStart);
						}
					}	// Loop through list of prior sales to update.
				}	// No previous SQL error, so update prior sales/pharmacy_daily_sum with payment data.

				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}

			}
			while (0);	// Dummy loop Should run only once.
			// End of dummy loop to prevent goto.

		}	// ReStart is FALSE.


		// DonR 28Jul2021: If there was any discrepancy between the number of prescription_drugs
		// rows inserted/updated and the number that *should* have been inserted/updated, produce
		// a (hopefully) helpful diagnostic message.
		if ((NumPrescriptionDrugsRowsAdded + NumPrescriptionDrugsRowsUpdated) != v_NumOfDrugLinesRecs)
		{
			if (reStart)
			{
				GerrLogMini (	GerrId,
								"Discrepancy in prescription_drugs quantity, but a DB conflict error was detected - tries = %d.",
								tries); 
			}
			else
			{
				if (SetErrorVar (&v_ErrorCode, v_ErrorCode))
				{
					GerrLogMini (	GerrId,
									"Discrepancy in prescription_drugs quantity, but a DB error %d was detected - reporting failure.",
									v_ErrorCode); 
				}
				else
				{
					// Should we force an error in this case? Mmmmaybe...

					GerrLogMini (	GerrId,
									"\nPrescription_drugs quantity discrepancy detected!"
									"\nAddNewRows                    = %d,"
									"\nNominal number of PD rows     = %d,"
									"\nTried to INSERT               = %d,"
									"\nSuccessful INSERTs            = %d,"
									"\nTried to UPDATE               = %d,"
									"\nSuccessful UPDATEs            = %d.",
									AddNewRows,								v_NumOfDrugLinesRecs,
									NumPrescriptionDrugsRowsTriedToAdd,		NumPrescriptionDrugsRowsAdded,
									NumPrescriptionDrugsRowsTriedToUpdate,	NumPrescriptionDrugsRowsUpdated	);
				}	// Ostensibly successful transaction - log the discrepancy in detail.
			}	// No DB conflict error detected - reStart is FALSE.
		}	// Discrepancy between v_NumOfDrugLinesRecs and prescription_drugs rows successfully added/updated.
//
//		else
//		{
//			// TEMPORARY.
//			GerrLogMini (	GerrId, "6005s: PrID %d # Lines = %d, %d added, %d/%d updated, reStart = %d, v_ErrorCode = %d.",
//							v_RecipeIdentifier, v_NumOfDrugLinesRecs, NumPrescriptionDrugsRowsAdded, NumPrescriptionDrugsRowsUpdated, NumPrescriptionDrugsRowsTriedToUpdate, reStart, v_ErrorCode);
//		}

		// DonR 27Aug2025: Clear the Pharmacy Spool Lock we set at the beginning of the transaction.
		ClearSpoolLock (v_PharmNum);

		// Commit the transaction.
		if (reStart == MAC_FALS)	// No retry needed.
		{
			if (!SetErrorVar (&v_ErrorCode, v_ErrorCode)) // Transaction OK
			{
				CommitAllWork ();
			}
			else
			{
				// Error, so do rollback.
				RollbackAllWork ();
			}

			if (SQLERR_error_test ())	// Commit (or rollback) failed.
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
			}
		}
		else
		{
			// Need to retry.
			if (TransactionRestart () != MAC_OK)
			{
				v_ErrorCode = ERR_DATABASE_ERROR;
				break;
			}

			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogMini (GerrId, "Table is locked for the <%d> time", (tries + 1));

			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}


	}	// End of retries loop.


	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}


	// Don't send warnings - only fatal errors.
	if (v_ErrorCode != NO_ERROR)
	{
		Sever = GET_ERROR_SEVERITY (v_ErrorCode);

		if (Sever <= FATAL_ERROR_LIMIT)
		{
			v_ErrorCode = NO_ERROR;
		}
	}

	// Create Response Message
	nOut =  sprintf (OBuffer,		 "%0*d",	MSG_ID_LEN,					6006				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	MSG_ERROR_CODE_LEN,			MAC_OK				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TPharmNum_len,				v_PharmNum			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TInstituteCode_len,			v_InstituteCode		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TTerminalNum_len,			v_TerminalNum		);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TErrorCode_len,				v_ErrorCode			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TMemberIdentification_len,	v_MemberID			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TIdentificationCode_len,	v_IDCode			);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TRecipeIdentifier_len,		v_RecipeIdentifier	);
	nOut += sprintf (OBuffer + nOut, "%0*d",	TDate_len,					SysDate				);
	nOut += sprintf (OBuffer + nOut, "%0*d",	THour_len,					SysTime				);


	// Return the size in Bytes of respond message
	*p_outputWritten			= nOut;
	*output_type_flg			= ANSWER_IN_BUFFER;
	ssmd_data_ptr->error_code	= v_ErrorCode;
	ssmd_data_ptr->terminal_num	= v_TerminalNum;

	// DonR 23Nov2017: Store number of drug lines in audit-trail variable.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = v_NumOfDrugLinesRecs;

	RESTORE_ISOLATION;

	return RC_SUCCESS;
}
// End of spooled-mode 6005 handler.


/*=======================================================================
||																		||
||			 HandlerToMsg_6011											||
||	Message handler for message 6011:									||
||			 Member drug history / ishurim download						||
||																		||
||	Added July 2025 User Story #417785.									||
||																		||
 =======================================================================*/

#define DOWNLOAD_ALL_SALES				1
#define DOWNLOAD_ALL_RX_SALES			2
#define DOWNLOAD_RX_TREATMENT_SALES		3
#define DOWNLOAD_RX_OPIOID_SALES		4
#define DOWNLOAD_RX_ADHD_SALES			5
#define RX_OPIOID_AND_ADHD_SALES		6

int HandlerToMsg_6011	(	int			TransactionID_in,
							char		*IBuffer,
							int			TotalInputLen,
							cJSON		*JSON_MaccabiRequest,
							char		*OBuffer,
							int			*p_outputWritten,
							int			*output_type_flg,
							SSMD_DATA	*ssmd_data_ptr,
							int			*NumProcessed_out	)
{
	// Local declarations.
	int				reStart;
	int				i;
	int				j;
	int				err;
	int				len;
	int				SysDate;
	int				SysTime;
	int				TrnValidationError			= 0;
	short			v_ErrorCode;
	bool			JSON_Mode					= false;

	// Request parameters.
	int				v_PharmNum					= 0;
	short			v_InstituteCode				= 0;	// Although in real life it's (almost) always 2.
	short			v_TerminalNum				= 0;
	int				PharmacistId				= 0;
	short			PharmacistIdType			= 0;
	int				TranslateTechIdHttpStatus	= 0;	// Will this be used in Trn. 6011?
	short			MemberCardDate				= 0;
	short			ServiceWithoutCardNeeded	= 0;	// Just so we have a value to store in the trn_6011_audit table.
	long			VisitNumber1				= 0L;
	long			VisitNumber2				= 0L;
	short			NumVisitNumbersProvided		= 0;
	short			PrescSource					= 0;
	int				ReceiptNumber				= 0;	// Added back in 01Dec2025.

//	int				NumLargosToSell				= 0;
//	int				LargoToSell					[MAX_TRN6011_LARGOS_TO_SELL];
//	cJSON			*LargosToSell				= NULL;
//	char			LargosToSellString			[1001];	// Maximum 99 drugs - so 1000 is more than enough length.
//
	char			ReservedInput	[20 + 1];
	short			ReportPeriodMonths;
	int				FirstOpioidSaleDate			= 0;
	int				FirstADHDSaleDate			= 0;
	int				FirstOrdinarySaleDate		= 0;
	short			MinPrescSource				= 1;
	bool			NonTreatmentDrugs			= false;
	bool			AllDrugTypes				= false;
	bool			Opioids						= false;
	bool			ADHD_drugs					= false;
//	bool			SellingOpioids				= false;
//	bool			SellingADHD_drugs			= false;

	// More miscellaneous variables.
	int				QualifyingVisitsFound		= 0;
	bool			QualifyingSalesFound		= false;
	int				MemberIdForSELECT			= 0;
	bool			GoodFetch					= false;
	bool			ForceCardExpiredErr			= false;
	bool			TransactionAuthorized		= false;
	char			fileName	[256];
	FILE			*outFP;
	PHARMACY_INFO	Phrm_info;
	ISOLATION_VAR;

	// Temporary Member ID fields.
	int			   	v_TempMembIdentification;
	short			v_TempIdentifCode;
	int				v_TempMemValidUntil;

	// Database arrays (and single-copy instances for DB queries) for prior sales and ishurim.
	T6011_Drugs		PriorSales	[MAX_TRN6011_PRIOR_SALES];
	T6011_Drugs		PriorSale;
	T6011_Ishurim	Ishurim		[MAX_TRN6011_ISHURIM];
	T6011_Ishurim	NextIshur;
	T6011_Ishurim	*LastIshur;

	// Other output-related variables.
	double			QuantityBought;						// Working copy of the quantity bought.
	int				EarliestSaleDateFound	= 22391231;	// So anything we find will be less than the default.
	int				LatestSaleDateFound		= -1;		// So anything we find will be greater than the default.
	int				Precision				= 6;		// Number of decimal places for float outputs in non-JSON format.
	short			NumPriorSales			= 0;
	short			NumIshurim				= 0;

	// JSON output variables.
	cJSON			*JSON_OutputObject		= NULL;
	cJSON			*JSON_OutputHeader		= NULL;
	cJSON			*JSON_OutputData		= NULL;
	cJSON			*JSON_OutputPriorSales	= NULL;
	cJSON			*JSON_PriorSale			= NULL;
	cJSON			*JSON_OutputIshurim		= NULL;
	cJSON			*JSON_Ishur				= NULL;
	cJSON			*JSON_IshurLargoList	= NULL;
	int				HTTP_response_status	= 200;	// Default to standard HTTP "OK".
	int				mac_status_code			= 0;


	// Body of function
 
	// Initialize variables.
	REMEMBER_ISOLATION;
	JSON_Mode				= (JSON_MaccabiRequest != NULL);
	PosInBuff				= IBuffer;
	v_ErrorCode				= NO_ERROR;
	reStart					= MAC_FALS;
	SysDate					= GetDate ();
	SysTime					= GetTime ();

	memset ((char *)&PriorSale,		0, sizeof (PriorSale)	);
	memset ((char *)PriorSales,		0, sizeof (PriorSales)	);
	memset ((char *)&NextIshur,		0, sizeof (NextIshur)	);
	memset ((char *)Ishurim,		0, sizeof (Ishurim)		);

	// Read message fields data into variables.
	if (JSON_Mode)
	{
		int	err_Tech_ID;
		int	err_Member_ID;
		int	err_Member_ID_Code;

		glbErrorCode = 0;	// Start off assuming no errors.

		v_InstituteCode	= 0;								// Already defaulted - just being paranoid. (It should really always be = 2; we
															// read it from the pharmacy table later on, in IS_PHARMACY_OPEN().)

		// NOTE: At this point, Transaction 6011 works with the traditional Member ID/Code combination
		// rather than with Technical ID. Just in case we eventually do start supporting Technical ID
		// (for data privacy), I'm leaving the translation code in place.
		err_Tech_ID			=	cJSON_GetIntByName		(JSON_MaccabiRequest, "TechnicalID",			OPTIONAL,	&Member.TechnicalID);	CHECK_JSON_ERROR ();
		err_Member_ID		=	cJSON_GetIntByName		(JSON_MaccabiRequest, "MemberID",				OPTIONAL,	&Member.ID);			CHECK_JSON_ERROR ();
		err_Member_ID_Code	=	cJSON_GetShortByName	(JSON_MaccabiRequest, "MemberID_Code",			OPTIONAL,	&Member.ID_code);		CHECK_JSON_ERROR ();

		// If the member's Technical ID was sent and the member's TZ number was *not* sent,
		// translate the Technical ID to TZ/TZ Code.
		if ((!err_Tech_ID) && (err_Member_ID))
		{
			err = TranslateTechnicalID (Member.TechnicalID, &Member.ID, &Member.ID_code, NULL, &TranslateTechIdHttpStatus);

			if (err)
			{
				GerrLogMini (GerrId, "Could not translate Technical ID %d to Member TZ/Code; TranslateTechnicalID() returned %d/HTTP response %d.",
							 Member.TechnicalID, err, TranslateTechIdHttpStatus);

				Member.ID = Member.ID_code = 0;	// Should be redundant! This function will throw an error for TZ = 0,
												// which is what we want in this case.
			}
		}	// Need to translate Technical ID into Member TZ/Member TZ Code.

		// Get all the rest of the request fields.
		// NOTE: I'm defining Doctor Visit Numbers 1 and 2 as individual fields rather than as an
		// array, because JSON arrays are variable-sized and here we limit ourselves to two values.
		cJSON_GetIntByName		(JSON_MaccabiRequest, "PharmacyID",			MANDATORY,	&v_PharmNum);			CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "InstitutionCode",	MANDATORY,	&v_InstituteCode);		CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "TerminalNum",		MANDATORY,	&v_TerminalNum);		CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "VersionNumber",		MANDATORY,	&VersionNumber);		CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "MemberCardDate",		MANDATORY,	&MemberCardDate);		CHECK_JSON_ERROR ();
		cJSON_GetLongByName		(JSON_MaccabiRequest, "DoctorVisitNumber1",	OPTIONAL,	&VisitNumber1);			CHECK_JSON_ERROR ();	// Optional request parameter.
		cJSON_GetLongByName		(JSON_MaccabiRequest, "DoctorVisitNumber2",	OPTIONAL,	&VisitNumber2);			CHECK_JSON_ERROR ();	// Optional request parameter.
		cJSON_GetIntByName		(JSON_MaccabiRequest, "ReceiptNumber",		OPTIONAL,	&ReceiptNumber);		CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "PrescSource",		MANDATORY,	&PrescSource);			CHECK_JSON_ERROR ();
		cJSON_GetIntByName		(JSON_MaccabiRequest, "PharmacistID",		MANDATORY,	&PharmacistId);			CHECK_JSON_ERROR ();
		cJSON_GetShortByName	(JSON_MaccabiRequest, "PharmacistIdType",	MANDATORY,	&PharmacistIdType);		CHECK_JSON_ERROR ();
//		cJSON_GetArrayByName	(JSON_MaccabiRequest, "LargosToSell",		MANDATORY,	&LargosToSell);			CHECK_JSON_ERROR ();
//
//		// DonR 21Jul2025: Use a new cJSON function to load the Largos to Check array in one swell foop.
//		cJSON_GetIntegerArray (LargosToSell, MAX_TRN6011_LARGOS_TO_SELL, LargoToSell, &NumLargosToSell);		CHECK_JSON_ERROR ();

		if (glbErrorCode)
			SetErrorVar (&v_ErrorCode, ERR_WRONG_FORMAT_FILE);

	}	// JSON mode - read input values from parsed JSON request structure.

	else
	{	// Non-JSON mode - read fixed-position input values from request string.
		// DonR 21Jul2025: Use a new cJSON function to load the Largos to Check array in one swell foop.
		v_PharmNum			= GetInt	(&PosInBuff,  7					); CHECK_ERROR ();	// 10,  7
		v_InstituteCode		= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 17,  2
		v_TerminalNum		= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 19,  2
		VersionNumber		= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 21,  2
		Member.ID			= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	// 23,  9
		Member.ID_code		= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 32,  1
		MemberCardDate		= GetShort	(&PosInBuff,  4					); CHECK_ERROR ();	// 33,  4
		PrescSource			= GetShort	(&PosInBuff,  2					); CHECK_ERROR ();	// 37,  2
		VisitNumber1		= GetLong	(&PosInBuff, 11					); CHECK_ERROR ();	// 39, 11
		VisitNumber2		= GetLong	(&PosInBuff, 11					); CHECK_ERROR ();	// 50, 11
		PharmacistId		= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	// 61,  9
		PharmacistIdType	= GetShort	(&PosInBuff,  1					); CHECK_ERROR ();	// 70,  1
		ReceiptNumber		= GetInt	(&PosInBuff,  7					); CHECK_ERROR();	// 71,  7
//
//		NumLargosToSell		= GetShort	(&PosInBuff,  3					); CHECK_ERROR ();	// 71,  3
//
//		for (i = 0; ((i < NumLargosToSell) && (i < MAX_TRN6011_LARGOS_TO_SELL)); i++)
//		{
//			LargoToSell [i]	= GetInt	(&PosInBuff,  9					); CHECK_ERROR ();	// 74, 9 (+ 9 x i)
//		}
//
	}	// Non-JSON mode - read fixed-position input values from request string.


	// Copy relevant fields to SSMD structure.
	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
	ssmd_data_ptr->member_id		= Member.ID;
	ssmd_data_ptr->member_id_ext	= Member.ID_code;

	// Use file output so we don't overflow the in-memory buffer.
	sprintf (fileName,
			 "%s/Trn6011_%0*d_%0*d.snd",
			 MsgDir,
			 7, v_PharmNum,
			 2, v_TerminalNum);


	// Top-level SQL Retry Loop.
	reStart = MAC_TRUE;

	// Avoid unnecessary lock errors by downgrading "isolation" for this transaction.
	SET_ISOLATION_DIRTY;

	for (tries = 0; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		reStart = MAC_FALS;

		// Create new file for response message.
		outFP = fopen (fileName, "w");

		if (outFP == NULL)
		{
			int	err = errno;

			GerrLogReturn (GerrId,
						   "\tCannot open output file '%s'\n\tError (%d) %s\n",
						   fileName,
						   err,
						   strerror(err));

			RESTORE_ISOLATION;
			return (ERR_UNABLE_OPEN_OUTPUT_FILE);
		}

		// Test pharmacy data.
		err = IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);
		if (err != MAC_OK)
		{
			SetErrorVar (&v_ErrorCode, err);

//			if (err == ERR_PHARMACY_NOT_FOUND)
//				mac_status_code = -98;
//
			break;
		}


		// One or two Doctor Visit Numbers can be sent as an alternative to requiring the
		// member's Magnetic Card date. There are two different ways this can work:
		//
		// 1) If the pharmacy is planning to sell medications against a Maccabi Doctor
		// (computerized) prescription, we check the Visit Number(s) to see if they have
		// at least one valid, unsold prescription. (This indicates that the pharmacy
		// has recently performed a Transaction 6001 and received fillable prescriptions.)
		//
		// 2) If the pharmacy is planning to sell medications against any other prescription
		// source, there may be no remaining unsold prescriptions for the Visit Number(s)
		// the pharmacy sends. In this case, we look to see whether each Doctor Visit
		// Number has at least one prescription that was sold today at the requesting
		// pharmacy.
		//
		// We use two different versions of the database query for these two possibilities,
		// since the first is both more common and much simpler - and thus should execute
		// faster. In either case, if two different Visit Numbers are provided, each one
		// of them must satisfy the relevant test.
		TransactionAuthorized	= false;	// Paranoid re-initialization.
		NumVisitNumbersProvided	= 0;		// Paranoid re-initialization.

		// First, see how many (potentially) valid Doctor Visit Numbers were provided.
		if (VisitNumber1 > 0)
		{
			NumVisitNumbersProvided = 1;
		}
		else
		{
			VisitNumber1 = -999999;	// A value that we know won't match anything -
									// although zero would probably be OK too.
		}

		if ((VisitNumber2 > 0) && (VisitNumber2 != VisitNumber1))	// Has to be positive *and* unique.
		{
			NumVisitNumbersProvided++;	// May be 1 *or* 2!
		}
		else
		{
			VisitNumber2 = -999999;	// A value that we know won't match anything -
									// although zero would probably be OK too.
		}

		// If at least one Visit Number was provided, check it (or them) against the
		// database using whichever query is appropriate.
		if (NumVisitNumbersProvided > 0)
		{
			if (PrescSource == RECIP_SRC_MACABI_DOCTOR)
			{
				ExecSQL (	MAIN_DB, TR6011_AreDoctorVisitsAlive,
							&QualifyingVisitsFound,
							&VisitNumber1,				&VisitNumber2,		&Member.ID,
							&Member.ID_code,			&SysDate,			END_OF_ARG_LIST		);
			}
			else
			{
				ExecSQL (	MAIN_DB, TR6011_DoctorVisitsSoldToday,
							&QualifyingVisitsFound,
							&VisitNumber1,				&VisitNumber2,		&Member.ID,
							&Member.ID_code,			&SysDate,			&v_PharmNum,
							END_OF_ARG_LIST													);
			}

			Conflict_Test (reStart);

			if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
			{
				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}

				// If we get here, the query succeeded and we have a useful value in
				// QualifyingVisitsFound. But we want to authorize the transaction only
				// if *both* Visit Numbers (if two were provided) qualified.
				TransactionAuthorized = (QualifyingVisitsFound == NumVisitNumbersProvided);

				if (!TransactionAuthorized)
				{
					TrnValidationError = ERR_6011_SALE_OR_VISIT_NOT_FOUND;
				}

			}	// Database returned something other than not-found.
		}	// At least one provided Visit Number is greater than zero.


		// DonR 01Dec2025: Add logic to verify by a previous Receipt Number, since in
		// some cases it's hard for the pharmacy-side system to give us Visit Numbers.
		// Note that in this case, the Receipt Number must be for the same member TZ,
		// the same pharmacy, a sale that took place today, *and* from the same Terminal
		// ID at the pharmacy.
		else
		{
			// The pharmacy did *not* provide any Doctor Visit Numbers, so try
			// checking request validity based on a Receipt Number.
			// 14Dec2025: This test is applicable only for Maccabi pharmacies,
			// and only when the current Prescription Source is something *other*
			// than "Maccabi Doctor".
			if (MACCABI_PHARMACY && (PrescSource != RECIP_SRC_MACABI_DOCTOR) && (ReceiptNumber > 0))
			{
				ExecSQL (	MAIN_DB, TR6011_ReceiptNumberCheck,
							&QualifyingSalesFound,
							&Member.ID,		&Member.ID_code,	&SysDate,
							&v_PharmNum,	&v_TerminalNum,		&ReceiptNumber,
							END_OF_ARG_LIST											);

				Conflict_Test (reStart);

				// Since TR6011_ReceiptNumberCheck returns TRUE/FALSE based on an 'EXISTS"
				// test, it should never return any non-conflict errors.
				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}

				// If we get here, the query succeeded and we have a useful
				// TRUE/FALSE value in QualifyingSalesFound.
				TransactionAuthorized = QualifyingSalesFound;

				if (!TransactionAuthorized)
				{
					TrnValidationError = ERR_6011_SALE_OR_VISIT_NOT_FOUND;
				}

			}	// Receipt Number is greater than zero.
		}	// Pharmacy did *not* provide any Doctor Visit Numbers.

		// DonR 27Nov2025 BUG FIX: If we authorized the transaction based on
		// provided Visit Number(s) or Receipt Number, we still have to read
		// the members row!
		if (TransactionAuthorized)
		{
			read_member (Member.ID, Member.ID_code);

			Conflict_Test (reStart);
		}

		// Test Member validity ONLY IF WE HAVE TO.
		// DonR 02Sep2025: If at least one Visit Number was supplied, we do NOT want
		// to check the card date even if it's valid.
		// DonR 01Dec2025: The same applies if the pharmacy supplied a Receipt Number.
		if (	(!TransactionAuthorized)			&&
				(NumVisitNumbersProvided	== 0)	&&
				(ReceiptNumber				== 0)		)
		{
			// Member ID must be non-zero.
			if (Member.ID == 0)
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
				break;
			}

			// Test temporary members.
			// If there's a temporary card but it's expired, we should return ERR_CARD_EXPIRED
			// rather than ERR_MEMBER_ID_CODE_WRONG (= not found).
			if (Member.ID_code == 7)
			{
				ExecSQL (	MAIN_DB, READ_tempmemb,
							&v_TempIdentifCode,	&v_TempMembIdentification,	&v_TempMemValidUntil,
							&Member.ID,			END_OF_ARG_LIST										);

				Conflict_Test (reStart);

				if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
				{
					SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
					break;
				}

				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}

				// If we get here, we managed to read the temporary card.
				// DonR 05Apr2017 CR #11541: Assign the member ID/Code even if the temporary
				// card has expired - but force a "card expired" error.
				Member.ID				= v_TempMembIdentification;
				Member.ID_code			= v_TempIdentifCode;
				Member.UsingTempMembId	= true;
				ForceCardExpiredErr		= (v_TempMemValidUntil < SysDate);
			}	// Temporary Member test.


			// After Temporary Member stuff, Member ID must be 58 or greater.
			if (Member.ID < 58)
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
				break;
			}

			// Try to read Member row.
			// NOTE: Using new read_member function for simplicity. It does *not* do any
			// real error-handling.
			read_member (Member.ID, Member.ID_code);

			Conflict_Test (reStart);

			// DonR 28Oct2025 User Story #429086: Just for esthetics, we now call SetMemberFlags()
			// from within read_member() - so there's no need to call it explicitly here.
//			// DonR 04Dec2022 User Story #408077: Use a new function to set some Member flags and values.
//			SetMemberFlags (SQLCODE);
//			
			if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
				break;
			}
			
			if (SQLERR_error_test ())
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				break;
			}
			else
			{
				// TEMPORARY FOR TESTING!
				// If the member's Card Date from the database is 5555, act as if
				// the pharmacy sent that date as well.
				// DonR 29May2022: Add a testing-system-only criterion to the "if".
				if ((Member.card_date == 5555) && (!TikrotProductionMode))
					MemberCardDate = 5555;


				// DonR 03Jun2018 order-for-delivery (SuperPharm) enhancement: If this is an online order,
				// we want to operate as if member has passed a valid magnetic card even though no card
				// was in fact used. The easiest way to do this is simply to copy the card-date value from
				// the members table to the card-date value that the pharmacy ordinarily sends.
				// DonR 27Aug2018: For online orders, force Digital Status TRUE even if the Card Date
				// value from the database is zero.
				// BUT: If the pharmacy *did* send a non-zero Card Date, we need to deal with it the way
				// we do in ordinary circumstances.
				// DonR 09Aug2021 User Story #163882: Darkonaim who are flagged as always getting service
				// without a magnetic card don't need any further checks - just copy their date, the same
				// as for online orders.
				if (Member.darkonai_no_card)
				{
					MemberCardDate			= Member.card_date;
					TransactionAuthorized	= 2;
				}
				else
				{
					// Not a no-card darkonai, so we need to look at the Card Date sent by the pharmacy.
					// If pharmacy did send a non-zero Card Date, we start off with the assumption that
					// it's valid and we can send digital prescriptions; we'll validate the date below.
					// If the pharmacy sent zero for the Card Date, check for service without card.
					// Remember whether the pharmacy sent zero for Card Date, so we have a yes/no value
					// to write to the trn_6011_audit table.
					ServiceWithoutCardNeeded = (MemberCardDate == 0) ? 1 : 0;
					TransactionAuthorized = ((MemberCardDate > 0) && (MemberCardDate < 9998))	?
													1 : CheckForServiceWithoutCard (&Member, Phrm_info);

					// If TransactionAuthorized is FALSE then we need to send an error to the pharmacy.
					if (!TransactionAuthorized)
					{
						SetErrorVar (&v_ErrorCode, NO_SERVICE_WITHOUT_CARD);
					}
				}

				// Validate date of member's magnetic card. If it wasn't valid, we won't read
				// prescriptions from the database.
				if ((!Member.UsingTempMembId								)	&&	// Don't check temp. members
					(CheckCardDate											)	&&	// DonR 05Apr2017 CR #11541: Global tokef-checking parameter.
					(MemberCardDate				>  0						)	&&	// 10Jan2005: 1 is a valid card date!
					(MemberCardDate				<  9999						)	&&	// CR #32984: 9998 should never be sent in Trn. 6001 - so give error ERR_CARD_EXPIRED.
					((MemberCardDate != 9997) || (Member.MemberTzahal == 0)	)	&&	// 10Oct2011: Special card for soldiers.
					(MemberCardDate				!= Member.card_date			)	&&	// Date on card doesn't match DB version.
					(Member.card_date			>  0						)	&&  // Yulia 20030213: DB date is "for real".
					(Member.ID					!= 59						)	&&	// Special case - exempt real members...
					(Member.ID					!= 83						))		// ...whose ID's have been used for testing.
				{
					// DonR 30Jul2013: Because a lot of new Maccabi Sheli cards were sent out by mail - and members'
					// data was updated with the new card dates before those cards had arrived - a new table,
					// membercard, has been added to list additional/alternative valid card dates for any given
					// member. Accordingly, check this table before sending a "card expired" error.
					ExecSQL (	MAIN_DB, READ_MemberCard,
								&Member.card_date,
								&Member.ID,			&Member.ID_code,
								&MemberCardDate,	END_OF_ARG_LIST		);

					if (SQLCODE != 0)
					{
						// Pharmacy did send a non-zero value, but it doesn't check out as a valid card date.
						// In this case, set an error code, disable reading prescriptions from the database,
						// *and* disregard any "extra" Largo Codes - so we won't return any prescription
						// or participation data.
						TransactionAuthorized = 0;
						SetErrorVar (&v_ErrorCode, ERR_CARD_EXPIRED);
					}
				}	// Pharmacy sent a non-zero card date but it did *not* match the one from the Members table.

				// DonR 05Apr2017 CR #11541: If pharmacy used an expired temporary card, send
				// a "card expired" error (instead of a "member ID not found" error).
				// Note that the global CheckCardDate flag (from sysparams) does *not*
				// affect how we deal with temporary cards - it applies only to the date
				// on "real" Maccabi cards.
				if (Member.UsingTempMembId && ForceCardExpiredErr)
				{
					TransactionAuthorized = 0;
					SetErrorVar (&v_ErrorCode, ERR_CARD_EXPIRED);
				}	// CR #11541 end.

			}	// Successfully read member information.

			// Logical data tests on Member eligibility.
			// DonR 25Nov2021 User Story #206812: Get died-in-hospital indicator from the Ishpuz system.
			// DonR 28Nov2022 User Story #407955: Allow pharmacies to perform RequestType 1 for non-valid
			// (or no-longer-valid) members.
			// DonR 30Nov2022 User Story #408077: Use a new macro MEMBER_IN_MEUHEDET (defined in MsgHndlr.h)
			// to decide if the person is a Meuhedet member.
			if ((MEMBER_INELIGIBLE)	|| (MEMBER_IN_MEUHEDET))
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_NOT_ELEGEBLE);
				break;
			}

		}	// Transaction wasn't authorized based on Doctor Visit Number or
			// Receipt Number, so we had to check member info.

		if (!TransactionAuthorized)
		{
			// DonR 14Dec2025: If the pharmacy sent one or two Visit Numbers or a
			// Receipt Number (and any other necessary conditions for using them
			// were met) and the validation failed, send a different error code
			// rather than the default "Member not eligible" one.
			SetErrorVar (&v_ErrorCode, ((TrnValidationError > 0) ? TrnValidationError : ERR_MEMBER_NOT_ELEGEBLE)	);
			break;
		}


		// Redundant, paranoid variable re-initialization.
		NumPriorSales	= 0;

		// Set up database-query parameters based on values from pharmacy_type_params.

		// Prior sale dates are inclusive - so the "days" variables do *not* include today.
		FirstOpioidSaleDate		= IncrementDate (SysDate, (0 - Phrm_info.prior_sale_opioid_days));
		FirstADHDSaleDate		= IncrementDate (SysDate, (0 - Phrm_info.prior_sale_ADHD_days));
		FirstOrdinarySaleDate	= IncrementDate (SysDate, (0 - Phrm_info.prior_sale_ordinary_days));
//GerrLogMini (GerrId, "FirstOpioidSaleDate = %d, FirstADHDSaleDate = %d, FirstOrdinarySaleDate = %d.",
//	FirstOpioidSaleDate, FirstADHDSaleDate, FirstOrdinarySaleDate);

		// Only DOWNLOAD_RX_SALES allows retrieval of non-treatment drugs.
		// DonR 30Dec2025 BUG FIX: At least for now, *all* requests should include non-treatment items.
		// However, I'm renaming the macro here to DOWNLOAD_ALL_RX_SALES and fixing the relevant logic.
		// Here are the relevant options and what they will do:
		//
		// DOWNLOAD_ALL_SALES			(= 1) sends both prescription and non-prescription sales, treatment
		//								and non-treatment drugs, and all drug_type values.
		//
		// DOWNLOAD_ALL_RX_SALES		(= 2) sends only prescription sales, and includes both treatment
		//								and non-treatment drugs, as well as all drug_type values.
		//
		// DOWNLOAD_RX_TREATMENT_SALES	(= 3) sends only prescription sales, and includes only treatment
		//								drugs. Includes all drug_type values. (This is the only option
		//								that disables non-"treatment" items.)
		//
		// DOWNLOAD_RX_OPIOID_SALES		(= 4) prescription sales of opioids only. (In real life, all these
		//								drugs should be "treatments" - but we won't impose this condition
		//								in the WHERE clause.)
		//
		// DOWNLOAD_RX_ADHD_SALES		(= 5) prescription sales of ADHD drugs only. (In real life, all
		//								these drugs should be "treatments" - but we won't impose this
		//								condition in the WHERE clause.)
		//
		// RX_OPIOID_AND_ADHD_SALES		(= 6) prescription sales of opioid *and* ADHD drugs only. (In real
		//								life, all these drugs should be "treatments" - but we won't impose
		//								this condition in the WHERE clause.)

		// Most Download Type values specify only prescription sales.
		MinPrescSource		=	(Phrm_info.prior_sale_download_type == DOWNLOAD_ALL_SALES) ? 0 : 1;

		// Only DOWNLOAD_RX_TREATMENT_SALES excludes non-treatment items.
		NonTreatmentDrugs	=	(Phrm_info.prior_sale_download_type != DOWNLOAD_RX_TREATMENT_SALES);

		// If download type is DOWNLOAD_RX_TREATMENT_SALES, *all* treatment drugs including opioids
		// and ADHD drugs will be included. The SELECT statement should include a row if there's a
		// match on AllDrugTypes OR Opioids OR ADHD_drugs.
		AllDrugTypes		= (	(Phrm_info.prior_sale_download_type	== DOWNLOAD_RX_TREATMENT_SALES)		||
								(Phrm_info.prior_sale_download_type	== DOWNLOAD_ALL_RX_SALES)			||
								(Phrm_info.prior_sale_download_type	== DOWNLOAD_ALL_SALES)					);

		// Opioids and ADHD drugs.
		Opioids				= (	(Phrm_info.prior_sale_download_type == DOWNLOAD_RX_OPIOID_SALES)		||
								(Phrm_info.prior_sale_download_type == RX_OPIOID_AND_ADHD_SALES)			);

		ADHD_drugs			= (	(Phrm_info.prior_sale_download_type == DOWNLOAD_RX_ADHD_SALES)			||
								(Phrm_info.prior_sale_download_type == RX_OPIOID_AND_ADHD_SALES)			);

//GerrLogMini (GerrId,	"6011: Download Type %d - MinPrescSource %d, NonTreatmentDrugs %d, AllDrugTypes %d, "
//						"Opioids %d, ADHD_drugs %d.",
//						Phrm_info.prior_sale_download_type, MinPrescSource, NonTreatmentDrugs, AllDrugTypes, Opioids, ADHD_drugs);

//		// If the transaction is supposed to retrieve only psychoactive drugs, check the list of drugs to be
//		// sold in order to see if there are opioids and/or ADHD drugs on the list. If the pharmacy isn't
//		// selling something in the category, we won't send prior sales for that category.
//	// Opioids = true;	// JUST FOR TESTING!
//		if (Opioids || ADHD_drugs)
//		{
//			// Build a string version of the list of Largo Codes the pharmacy intends to sell.
//			strcpy (LargosToSellString, "_");
//			for (i = 0, len = 1; i < NumLargosToSell; i++)
//			{
//				len += sprintf (LargosToSellString + len, "%d_", LargoToSell [i]);
//			}
//
//			ExecSQL (	MAIN_DB, TR6011_ListIncludesOpioidsOrADHD_drugs,
//						&SellingOpioids,		&SellingADHD_drugs,
//						&LargosToSellString,	END_OF_ARG_LIST				);
// GerrLogMini (GerrId, "TR6011_ListIncludesOpioidsOrADHD_drugs: SellingOpioids = %d, SellingADHD_drugs = %d,\n"
//	"LargosToSellString {%s}, SQLCODE %d.", SellingOpioids, SellingADHD_drugs, LargosToSellString, SQLCODE);
//
//			Conflict_Test (reStart);
//
//			if (SQLERR_error_test ())
//			{
//				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
//				break;
//			}
//
//			// Disable reporting of drugs that are *not* in one of the "dangerous" categories being sold.
//			if (!SellingOpioids)
//				Opioids = false;
//
//			if (!SellingADHD_drugs)
//				ADHD_drugs = false;
//		}
		
// GerrLogMini (GerrId, "6011 criteria: Sales from %d, min source %d, non-treatment %d, all treatment %d, Opioids %d, ADHD %d\n"
//	"LargosToSellString = {%s}",
//	FirstPriorSaleDate, MinPrescSource, NonTreatmentDrugs, AllDrugTypes, Opioids, ADHD_drugs, LargosToSellString);

// WORKINGPOINT
		// For Secret Investigators, force a "nothing to see here" response by setting the
		// Member ID for SELECTs to a nonsense value. For everyone else, the Member ID we
		// select by is just a copy of the one from the member-data structure. (This way
		// we are performing unnecessary SELECTs for the secret investigators; but that
		// represents only a tiny percentage of overall transaction volume, and doing it
		// this way keeps the code simple (or at least less horribly complicated).
		MemberIdForSELECT = (SECRET_INVESTIGATOR) ? -9999 : Member.ID;


		// Declare and open the prior-sales cursor.
		DeclareAndOpenCursorInto (	MAIN_DB,	TR6011_PriorSaleDownload,
									&PriorSale.date,				&PriorSale.largo_code,
									&PriorSale.op,					&PriorSale.units,
									&PriorSale.pharmacy_code,		&PriorSale.pharmacy_name,
									&PriorSale.presc_source,		&PriorSale.pr_src_desc,
									&PriorSale.doctor_id_type,		&PriorSale.doctor_id,			// 10

									&PriorSale.rule_number,			&PriorSale.qty_limit_chk_type,
									&PriorSale.ingr_1_code_bot,		&PriorSale.ingr_2_code_bot,
									&PriorSale.ingr_3_code_bot,		&PriorSale.ingr_1_quant_bot,
									&PriorSale.ingr_2_quant_bot,	&PriorSale.ingr_3_quant_bot,
									&PriorSale.digital_rx,			&PriorSale.use_instr_template,	// 20

									&PriorSale.how_to_take_code,	&PriorSale.units_per_dose,
									&PriorSale.unit_code,			&PriorSale.doses_per_day,
									&PriorSale.duration,			&PriorSale.course_treat_days,
									&PriorSale.course_length,		&PriorSale.course_units,
									&PriorSale.days_of_week,		&PriorSale.times_of_day,		// 30

									&PriorSale.side_of_body,		&PriorSale.UsageInstrGiven,
									&PriorSale.NumCourses,			&PriorSale.economypri_group,
									&PriorSale.doc_first_name,		&PriorSale.doc_last_name,
									&PriorSale.speciality_desc,		&PriorSale.special_presc_num,
									&PriorSale.qty_lim_ingr,		&PriorSale.qty_lim_units,		// 40
			
									&PriorSale.unit_desc_heb,										// 41

									&MemberIdForSELECT,				&Member.ID_code,
									&MinPrescSource,				&NonTreatmentDrugs,
									&AllDrugTypes,					&Opioids,
									&ADHD_drugs,					&FirstOpioidSaleDate,
									&FirstADHDSaleDate,				&FirstOrdinarySaleDate,			// 10
		
									END_OF_ARG_LIST														);

		Conflict_Test (reStart);

		if (SQLERR_error_test ())
		{
			SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
			break;
		}

		// Scroll through the cursor, process what needs to be processed, and store the results.
		do
		{
			FetchCursor (	MAIN_DB,	TR6011_PriorSaleDownload	);
// GerrLogMini (GerrId, "6011 fetched date %d Largo %d, SQLCODE %d.", PriorSale.date, PriorSale.largo_code, SQLCODE);

			Conflict_Test (reStart);
					
			if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
			{
				break;
			}
			else
			{
				if (SQLERR_error_test ())
				{
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
					break;
				}
			}	// Something other than end-of-fetch.

			GoodFetch = true;

			// If the sale was against a paper prescription with a Doctor License Number,
			// try to find the doctor using the doctor_percents table.
			if	(	(PriorSale.doctor_id_type	== 1					)	&&	// License number.
					(PriorSale.presc_source		>  RECIP_SRC_NO_PRESC	)	&&	// Not an OTC sale.
					(PriorSale.doctor_id		>  0					)	&&	// Non-zero license number.
					(*PriorSale.doc_last_name	== (char)0				)		// We don't already have a doctor name.
				)
			{
				char	DummyPhone	[10 + 1];
				short	DummyCheckInteractions;
				int		DummyRealDoctorTZ;

				ExecSQL (	MAIN_DB, READ_DoctorByLicenseNumber,
							&PriorSale.doc_first_name,		&PriorSale.doc_last_name,
							&DummyPhone,					&DummyCheckInteractions,
							&DummyRealDoctorTZ,

							&PriorSale.doctor_id,			END_OF_ARG_LIST					);

				// If we didn't get a "hit", blank out the doctor-name variables.
				// (Shouldn't really be necessary - just paranoia.)
				if (SQLERR_code_cmp (SQLERR_ok) != MAC_TRUE)
				{
					strcpy (PriorSale.doc_first_name,	"");
					strcpy (PriorSale.doc_last_name,	"");

					if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
					{
						if (SQLERR_error_test ())
						{
							SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							break;
						}
					}	// Something other than not-found.
				}	// Something other than successful read.
			}	// Non-zero Doctor License Number needs to be looked up.

			// Strip leading/trailing spaces from text columns. (Strictly speaking, we don't
			// have to do this for non-JSON output; but it's a little neater to do it here,
			// when we're working with a single-copy structure rather than the output array.)
			StripAllSpaces (	PriorSale.doc_first_name	);
			StripAllSpaces (	PriorSale.doc_last_name		);
			StripAllSpaces (	PriorSale.speciality_desc	);
			StripAllSpaces (	PriorSale.pr_src_desc		);
			StripAllSpaces (	PriorSale.pharmacy_name		);
			StripAllSpaces (	PriorSale.qty_lim_units		);
			StripAllSpaces (	PriorSale.unit_code			);
			StripAllSpaces (	PriorSale.course_units		);
			StripAllSpaces (	PriorSale.days_of_week		);
			StripAllSpaces (	PriorSale.times_of_day		);
			StripAllSpaces (	PriorSale.side_of_body		);
			StripAllSpaces (	PriorSale.UsageInstrGiven	);

			// Set up Ishur Quantity Limit fields. If we used ishur limits in this prior sale,
			// we need to figure out which ingredient was used (since the ishur limit is not
			// always for the first ingredient on the list), and make sure the ingredient
			// usage is in the correct units. (For now, we'll convert to the units used in the
			// ishur - but this may change.)
			if	(PriorSale.qty_limit_chk_type == SP_PR_PURCHASE_LIMIT)
			{
				QuantityBought = 0.0;

				if (PriorSale.ingr_1_code_bot == PriorSale.qty_lim_ingr)
				{
					QuantityBought	= PriorSale.ingr_1_quant_bot;
				}
				else
				if (PriorSale.ingr_2_code_bot == PriorSale.qty_lim_ingr)
				{
					QuantityBought	= PriorSale.ingr_2_quant_bot;
				}
				else
				if (PriorSale.ingr_3_code_bot == PriorSale.qty_lim_ingr)
				{
					QuantityBought	= PriorSale.ingr_3_quant_bot;
				}
				else
				// If none of the sold ingredients match the ishur's quantity-limit ingredient,
				// don't report anything to the pharmacy. In reality, this should never happen.
				{
					QuantityBought	= 0.0;
					strcpy (PriorSale.unit_desc_heb, "");
				}

			}	// Sale included ishur-based quantity-limit checking.
			else
			// Any quantity-limit checking that was performed did *not* involve "ishur kaspi"
			// limits - so we don't report it in this transaction.
			{
				QuantityBought	= 0.0;
				strcpy (PriorSale.unit_desc_heb, "");
			}

			// WORKINGPOINT: Once we have a proper specification from Iris, convert limit-ingredient
			// usage to the proper unit for reporting. For the moment, just report what we got from
			// prescription_drugs.
			PriorSale.ingr_quant_to_report = QuantityBought;

			// Set up minimum/maximum sale dates for prior sales found.
			if (PriorSale.date < EarliestSaleDateFound)
				EarliestSaleDateFound = PriorSale.date;

			if (PriorSale.date > LatestSaleDateFound)
				LatestSaleDateFound = PriorSale.date;

			// Set the sold-by-us flag *before* suppressing the prior-sale
			// pharmacy code for private pharmacies!
			PriorSale.sold_by_us = (PriorSale.pharmacy_code == Phrm_info.pharmacy_code) ? 1 : 0;

			// For private pharmacies, suppress stuff that only MaccabiPharm is supposed to receive.
			if (PRIVATE_PHARMACY)
			{
				PriorSale.pharmacy_code		= 0;		// Send to MaccabiPharm only.
				PriorSale.pharmacy_name [0]	= (char)0;	// Send to MaccabiPharm only.
				PriorSale.economypri_group	= 0;		// Send to MaccabiPharm only.
				PriorSale.presc_source		= 0;		// Send to MaccabiPharm only.
			}

			// Finally, copy the prior-sale structure into the array.
			PriorSales [NumPriorSales++] = PriorSale;

		}	// "Do" block.
		while (GoodFetch);
		// End of loop for reading prior drug sale rows.

		CloseCursor (	MAIN_DB,	TR6011_PriorSaleDownload	);


		// If enabled for this pharmacy, also get a list of AS/400 ishurim.
		if (Phrm_info.enable_ishur_download)
		{
			// Set up pointer to the last ishur in the ishurim array.
			LastIshur	= &Ishurim [0];
			NumIshurim	= 0;	// More paranoid re-initialization.

			// Read each row into the NextIshur structure, so we don't override the
			// current ishur until we've copied it to the ishurim array. Note also
			// that we use MemberIdForSELECT instead of Member.ID, so that we will
			// retrieve no data for Secret Investigators.
			DeclareAndOpenCursorInto (	MAIN_DB,	TR6011_IshurDownload,
										&NextIshur.main_largo_code,		&NextIshur.special_presc_num,	&NextIshur.treatment_start,
										&NextIshur.stop_use_date,		&NextIshur.qty_lim_flg,			&NextIshur.qty_lim_per_day,
										&NextIshur.qty_lim_treat_days,	&NextIshur.qty_lim_course_len,	&NextIshur.qty_lim_courses,
										&NextIshur.largo_code,			&NextIshur.unit_desc_heb,

										&MemberIdForSELECT,				&SysDate,						&SysDate,
										&Member.ID_code,				&SysDate,						&SysDate,
										END_OF_ARG_LIST																					);

			Conflict_Test (reStart);

			if (SQLERR_error_test ())
			{
				SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				break;
			}

			// Scroll through the cursor, process what needs to be processed, and store the results.
			do
			{
				FetchCursor (	MAIN_DB,	TR6011_IshurDownload	);
// GerrLogMini (GerrId, "6011 fetched Ishur %d Largo %d, SQLCODE %d.", Ishur.special_presc_num, Ishur.largo_code, SQLCODE);

				Conflict_Test (reStart);
					
				if (SQLERR_code_cmp (SQLERR_end_of_fetch) == MAC_TRUE)
				{
					break;
				}
				else
				{
					if (SQLERR_error_test ())
					{
						SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
						break;
					}
				}	// Something other than end-of-fetch.

				GoodFetch = true;

				// If this is a new Ishur Number, set up for adding it to the array. Otherwise,
				// add the new Largo Code to the list in the current ishur structure. (Note
				// that all this logic relies on the ORDER BY in the TR6011_IshurDownload query!)
				if (NextIshur.special_presc_num != LastIshur->special_presc_num)
				{
					// The first ishur we read does *not* advance the pointer, since it's
					// already pointing at the first item in the array.
					if (NumIshurim > 0)
					{
						LastIshur++;
					}

					// TEMPORARY: At the moment, we aren't getting real values for "Main Largo Code",
					// so just force in the first Largo Code we see for the ishur.
					if (NextIshur.main_largo_code == 0)
					{
						NextIshur.main_largo_code = NextIshur.largo_code;
					}

					// If the Quantity Limit Flag is set FALSE, don't report any other
					// quantity-limit fields.
					if (!NextIshur.qty_lim_flg)
					{
						NextIshur.qty_lim_per_day		= 0.0;
						NextIshur.qty_lim_treat_days	=
						NextIshur.qty_lim_course_len	=
						NextIshur.qty_lim_courses		= 0;
						NextIshur.unit_desc_heb [0]		= (char)0;
					}

					NextIshur.num_largos_in_ishur = 0;

					// Copy NextIshur into the Ishurim array.
					*LastIshur = NextIshur;

					NumIshurim++;
				}

				// Add the new Largo Code to the list for this ishur.
				LastIshur->LargoCodeList [LastIshur->num_largos_in_ishur++] = NextIshur.largo_code;

			}	// "Do" block.
			while (GoodFetch);
			// End of loop for reading prior drug sale rows.

			CloseCursor (	MAIN_DB,	TR6011_IshurDownload	);

		}	// Ishur download is enabled.

	}	// End of Database Retries loop.
	
	
	// See if we've exceeded the maximum retry count.
	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}


	// Prepare and send Response Message (Transaction 6002).
	// DonR 21Apr2021: Enable JSON output.
	// DonR 17Nov2025: If there were no prior sales at all, send zeroes to the
	// pharmacy rather than the "starter" values.
	// DonR 20Nov2025: For some reason that I can't fathom, this fix appears to have been
	// working for Maccabi pharmacies but not for private pharmacies. Previously it was
	// just after the prior-sale cursor was closed, before the ishur cursor was opened.
	// I'm moving it here just to see if that somehow solves the problem.
	if (NumPriorSales < 1)
	{
		EarliestSaleDateFound = LatestSaleDateFound = 0;
	}

	if (JSON_Mode)
	{
		JSON_OutputObject = cJSON_CreateObject ();

		if (JSON_OutputObject == NULL)
		{
			GerrLogMini (GerrId, "Couldn't create JSON_OutputObject!");
			// We should obviously do something more than log an error here -
			// but I'm not yet sure just what. In any case, creating the object
			// should never fail in real life - I hope!
		}
		else
		{
			// Create and populate Response Header object.
			JSON_OutputHeader = cJSON_AddObjectToObject (JSON_OutputObject, "Header");

			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "ResponseTransactionID",	6012						);	// Is this really necessary?
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "CommError",				MAC_OK						);	// Is this really necessary?
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "PharmacyID",				Phrm_info.pharmacy_code		);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "InstituteCode",			Phrm_info.institute_code	);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "TerminalNum",				v_TerminalNum				);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "ErrorCode",				v_ErrorCode					);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "MemberID",					Member.ID					);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "MemberID_Code",			Member.ID_code				);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "EarliestSaleDate",			EarliestSaleDateFound		);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "LatestSaleDate",			LatestSaleDateFound			);

			JSON_OutputData = cJSON_AddObjectToObject (JSON_OutputObject, "Data");

			JSON_OutputPriorSales = cJSON_AddArrayToObject (JSON_OutputData, "PriorSales");

			for (i = 0; i < NumPriorSales; i++)
			{
				JSON_PriorSale = cJSON_AddNewObjectToArray (JSON_OutputPriorSales);

				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "SaleDate",				PriorSales [i].date					);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "LargoSold",				PriorSales [i].largo_code			);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "GenericGroup",			PriorSales [i].economypri_group		);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "SoldOP",					PriorSales [i].op					);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "SoldUnits",				PriorSales [i].units				);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "SoldByThisPharmacy",		PriorSales [i].sold_by_us			);
//				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "SoldAtPharmacyCode",		PriorSales [i].pharmacy_code		);
				cJSON_AddStringToObject		(JSON_PriorSale, "SoldAtPharmacyName",		PriorSales [i].pharmacy_name		);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "PrescSource",				PriorSales [i].presc_source			);
				cJSON_AddStringToObject		(JSON_PriorSale, "PrescSourceDesc",			PriorSales [i].pr_src_desc			);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "DigitalPresc",			PriorSales [i].digital_rx			);
				cJSON_AddStringToObject		(JSON_PriorSale, "DoctorFamilyName",		PriorSales [i].doc_last_name		);
				cJSON_AddStringToObject		(JSON_PriorSale, "DoctorFirstName",			PriorSales [i].doc_first_name		);
				cJSON_AddStringToObject		(JSON_PriorSale, "DoctorSpecialityDesc",	PriorSales [i].speciality_desc		);
//				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "RuleNumber",				PriorSales [i].rule_number			);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "UsageInstrTemplate",		PriorSales [i].use_instr_template	);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "HowToTakeCode",			PriorSales [i].how_to_take_code		);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "UnitsPerDose",			PriorSales [i].units_per_dose		);
				cJSON_AddStringToObject		(JSON_PriorSale, "UnitCode",				PriorSales [i].unit_code			);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "DosesPerDay",				PriorSales [i].doses_per_day		);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "TreatmentDuration",		PriorSales [i].duration				);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "CourseTreatmentDays",		PriorSales [i].course_treat_days	);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "CourseLength",			PriorSales [i].course_length		);
				cJSON_AddStringToObject		(JSON_PriorSale, "CourseLengthUnit",		PriorSales [i].course_units			);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "NumCourses",				PriorSales [i].NumCourses			);
				cJSON_AddStringToObject		(JSON_PriorSale, "DaysOfWeek",				PriorSales [i].days_of_week			);
				cJSON_AddStringToObject		(JSON_PriorSale, "TimesOfDay",				PriorSales [i].times_of_day			);
				cJSON_AddStringToObject		(JSON_PriorSale, "SideOfBody",				PriorSales [i].side_of_body			);
				cJSON_AddStringToObject		(JSON_PriorSale, "UsageInstrGiven",			PriorSales [i].UsageInstrGiven		);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "IshurNumber",				PriorSales [i].special_presc_num	);
				cJSON_AddAnyNumberToObject	(JSON_PriorSale, "IshurLimitQtySold",		PriorSales [i].ingr_quant_to_report	);
				cJSON_AddStringToObject		(JSON_PriorSale, "IshurQtyLimitUnits",		PriorSales [i].unit_desc_heb		);
			}	// Loop through prior sales.

// QUESTION: Do we want to send an empty "Ishurim" array even if enable_ishur_download is FALSE?
// If so, we don't need "if (Phrm_info.enable_ishur_download)" here.
			if (Phrm_info.enable_ishur_download)
			{
				JSON_OutputIshurim = cJSON_AddArrayToObject (JSON_OutputData, "Ishurim");
		
				for (i = 0; i < NumIshurim; i++)
				{
					JSON_Ishur = cJSON_AddNewObjectToArray (JSON_OutputIshurim);

					cJSON_AddAnyNumberToObject	(JSON_Ishur, "MainLargoCode",			Ishurim [i].main_largo_code		);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "IshurNumber",				Ishurim [i].special_presc_num	);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "StartDate",				Ishurim [i].treatment_start		);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "StopDate",				Ishurim [i].stop_use_date		);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "HasQtyLimit",				Ishurim [i].qty_lim_flg			);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "DailyLimitAmount",		Ishurim [i].qty_lim_per_day		);
					cJSON_AddStringToObject		(JSON_Ishur, "LimitUnitDesc",			Ishurim [i].unit_desc_heb		);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "CourseTreatmentDays",		Ishurim [i].qty_lim_treat_days	);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "CourseLengthDays",		Ishurim [i].qty_lim_course_len	);
					cJSON_AddAnyNumberToObject	(JSON_Ishur, "NumCourses",				Ishurim [i].qty_lim_courses		);

					JSON_IshurLargoList = cJSON_AddArrayToObject (JSON_Ishur, "LargoCodes");

					for (j = 0; j < Ishurim [i].num_largos_in_ishur; j++)
					{
						cJSON_AddAnyNumberToObject	(JSON_IshurLargoList, "LargoCode",	Ishurim [i].LargoCodeList [j]	);
					}

				}	// Loop through ishurim.

			}	// Ishur download is enabled.

			// Send the output JSON hierarchy to file and delete it from memory.
			cJSON_PrintToFP (JSON_OutputObject, outFP);
//			cJSON_PrintUnformattedToFP (JSON_OutputObject, outFP);
			cJSON_Delete (JSON_OutputObject);

		}	// JSON_OutputObject is NOT NULL.
	}	// JSON output mode.

	else
	{	// Non-JSON mode - send fixed-position output values to output file.
		fprintf (outFP, "%0*d",	  5,		6012						);
		fprintf (outFP, "%0*d",	  4,		MAC_OK						);
		fprintf (outFP, "%0*d",	  7,		Phrm_info.pharmacy_code		);	//  1
		fprintf (outFP, "%0*d",	  2,		Phrm_info.institute_code	);	//  2
		fprintf (outFP, "%0*d",	  2,		v_TerminalNum				);	//  3
		fprintf (outFP, "%0*d",	  4,		v_ErrorCode					);	//  4
		fprintf (outFP, "%0*d",	  9,		Member.ID					);	//  5
		fprintf (outFP, "%0*d",	  1,		Member.ID_code				);	//  6
		fprintf (outFP, "%0*d",	  8,		EarliestSaleDateFound		);	//  7
		fprintf (outFP, "%0*d",	  8,		LatestSaleDateFound			);	//  8
		// Header length = 50.

		fprintf (outFP, "%0*d",	  3,		NumPriorSales				);	//  9

		for (i = 0; i < NumPriorSales; i++)
		{
			// Determine the number of decimal places to output Limit Ingredient Usage.
			Precision = 6;	// Default to 01.123456
			do
			{
				if (PriorSales [i].ingr_quant_to_report >=        10.0) Precision--; else break;
				if (PriorSales [i].ingr_quant_to_report >=       100.0) Precision--; else break;
				if (PriorSales [i].ingr_quant_to_report >=      1000.0) Precision--; else break;
				if (PriorSales [i].ingr_quant_to_report >=     10000.0) Precision--; else break;
				if (PriorSales [i].ingr_quant_to_report >=    100000.0) Precision--; else break;
				if (PriorSales [i].ingr_quant_to_report >=   1000000.0) Precision--; else break;	// All the way down to zero decimal places!

				// We don't really see numbers this big - but if we ever do, we don't want
				// to break the output format by trying to report them.
				if (PriorSales [i].ingr_quant_to_report >= 999999999.0)
				{
					PriorSales [i].ingr_quant_to_report = 0.0;	// Suppress numbers that won't fit.
				}
			}
			while (0);


			fprintf (outFP, "%0*d",		  8,			PriorSales [i].date					);	// 10
			fprintf (outFP, "%0*d",		  9,			PriorSales [i].largo_code			);	// 11
			fprintf (outFP, "%0*d",		  5,			PriorSales [i].economypri_group		);	// 12
			fprintf (outFP, "%0*d",		  5,			PriorSales [i].op					);	// 13
			fprintf (outFP, "%0*d",		  5,			PriorSales [i].units				);	// 14
			fprintf (outFP, "%0*d",		  1,			PriorSales [i].sold_by_us			);	// 15
//			fprintf (outFP, "%0*d",		  7,			PriorSales [i].pharmacy_code		);	// REMOVED
			fprintf (outFP, "%-*.*s",	 30,  30,		PriorSales [i].pharmacy_name		);	// 16
			fprintf (outFP, "%0*d",		  2,			PriorSales [i].presc_source			);	// 17
			fprintf (outFP, "%-*.*s",	 15,  15,		PriorSales [i].pr_src_desc			);	// 18
			fprintf (outFP, "%0*d",		  1,			PriorSales [i].digital_rx			);	// 19
			fprintf (outFP, "%-*.*s",	 14,  14,		PriorSales [i].doc_last_name		);	// 20 - Maccabi Doc Rx only.
			fprintf (outFP, "%-*.*s",	  8,   8,		PriorSales [i].doc_first_name		);	// 21 - Maccabi Doc Rx only.
			fprintf (outFP, "%-*.*s",	 25,  25,		PriorSales [i].speciality_desc		);	// 22 - Maccabi Doc Rx only.
			fprintf (outFP, "%0*d",		  1,			PriorSales [i].use_instr_template	);	// 23
			fprintf (outFP, "%0*d",		  3,			PriorSales [i].how_to_take_code		);	// 24
			fprintf (outFP, "%0*d",		  6,			PriorSales [i].units_per_dose		);	// 25
			fprintf (outFP, "%-*.*s",	  3,   3,		PriorSales [i].unit_code			);	// 26
			fprintf (outFP, "%0*d",		  1,			PriorSales [i].doses_per_day		);	// 27
			fprintf (outFP, "%0*d",		  3,			PriorSales [i].duration				);	// 28
			fprintf (outFP, "%0*d",		  3,			PriorSales [i].course_treat_days	);	// 29
			fprintf (outFP, "%0*d",		  2,			PriorSales [i].course_length		);	// 30
			fprintf (outFP, "%-*.*s",	  6,   6,		PriorSales [i].course_units			);	// 31
			fprintf (outFP, "%0*d",		  3,			PriorSales [i].NumCourses			);	// 32
			fprintf (outFP, "%-*.*s",	 20,  20,		PriorSales [i].days_of_week			);	// 33
			fprintf (outFP, "%-*.*s",	200, 200,		PriorSales [i].times_of_day			);	// 34
			fprintf (outFP, "%-*.*s",	 10,  10,		PriorSales [i].side_of_body			);	// 35
			fprintf (outFP, "%-*.*s",	100, 100,		PriorSales [i].UsageInstrGiven		);	// 36
			fprintf (outFP, "%0*d",		  9,			PriorSales [i].special_presc_num	);	// 37 - MaccabiPharm only.
			fprintf (outFP, "%0*.*f",	  9, Precision,	PriorSales [i].ingr_quant_to_report	);	// 38 - MaccabiPharm only.
//			fprintf (outFP, "%0*d",		  9,			PriorSales [i].rule_number			);	// DISABLED
			fprintf (outFP, "%-*.*s",	  8,   8,		PriorSales [i].unit_desc_heb		);	// 39 - MaccabiPharm only.
		}	// Loop through prior sales.

		// If enable_ishur_download is FALSE, NumIshurim will always be zero.
		fprintf (outFP, "%0*d",	  3,		NumIshurim							);				// 40

		for (i = 0; i < NumIshurim; i++)
		{
			// Determine the number of decimal places to output Daily Limit Amount.
			Precision = 6;	// Default to 01.123456
			do
			{
				if (Ishurim [i].qty_lim_per_day >=        10.0) Precision--; else break;
				if (Ishurim [i].qty_lim_per_day >=       100.0) Precision--; else break;
				if (Ishurim [i].qty_lim_per_day >=      1000.0) Precision--; else break;
				if (Ishurim [i].qty_lim_per_day >=     10000.0) Precision--; else break;
				if (Ishurim [i].qty_lim_per_day >=    100000.0) Precision--; else break;
				if (Ishurim [i].qty_lim_per_day >=   1000000.0) Precision--; else break;	// All the way down to zero decimal places!

				// We don't really see numbers this big - but if we ever do, we don't want
				// to break the output format by trying to report them.
				if (Ishurim [i].qty_lim_per_day >= 999999999.0)
				{
					Ishurim [i].qty_lim_per_day = 0.0;	// Suppress numbers that won't fit.
				}
			}
			while (0);

			fprintf (outFP, "%0*d",		9,				Ishurim [i].main_largo_code		);		// 41
			fprintf (outFP, "%0*d",		9,				Ishurim [i].special_presc_num	);		// 42
			fprintf (outFP, "%0*d",		8,				Ishurim [i].treatment_start		);		// 43
			fprintf (outFP, "%0*d",		8,				Ishurim [i].stop_use_date		);		// 44
			fprintf (outFP, "%0*d",		1,				Ishurim [i].qty_lim_flg			);		// 45
			fprintf (outFP, "%0*.*f",	9, Precision,	Ishurim [i].qty_lim_per_day		);		// 46 FORMAT MAY NEED REVISION!
			fprintf (outFP, "%-*.*s",	8, 8,			Ishurim [i].unit_desc_heb		);		// 47
			fprintf (outFP, "%0*d",		2,				Ishurim [i].qty_lim_treat_days	);		// 48 PER COURSE - CHECK!
			fprintf (outFP, "%0*d",		3,				Ishurim [i].qty_lim_course_len	);		// 49
			fprintf (outFP, "%0*d",		2,				Ishurim [i].qty_lim_courses		);		// 50
			fprintf (outFP, "%0*d",		3,				Ishurim [i].num_largos_in_ishur	);		// 51

			for (j = 0; j < Ishurim [i].num_largos_in_ishur; j++)
			{
				fprintf (outFP, "%0*d",	 9,				Ishurim [i].LargoCodeList [j]	);		// 52
			}

		}	// Loop through ishurim.

	}	// Non-JSON mode - send fixed-position output values to output file.


	fclose (outFP);

	// Write the name of output-file on string for T-SWITCH.
	*p_outputWritten = sprintf (OBuffer, "%s", fileName);
	*output_type_flg = ANSWER_IN_FILE;

	// DonR 27Jun2018: Up to now, we weren't saving the error code for this transaction. Now we are!
	// DonR 31May2020: Added assignment of Terminal ID to ssmd_data_ptr structure, so it'll be
	// recorded properly in messages_details.
	ssmd_data_ptr->error_code	= v_ErrorCode;
	ssmd_data_ptr->terminal_num	= v_TerminalNum;

	// Store number of prescription rows plus ishurim read from DB in audit variable.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = (NumPriorSales + NumIshurim);


	// Write to the Transaction 6011 Audit table. Don't do any real error handling, but do
	// write to the log if there's a problem. Note that we don't really need an explicit
	// COMMIT, since the SqlServer.c mainline has one anyway.
	ExecSQL (	MAIN_DB, TR6011_WriteAudit,
				&v_PharmNum,		&v_InstituteCode,			&v_TerminalNum,
				&SysDate,			&SysTime,					&Member.ID,
				&Member.ID_code,	&MemberCardDate,			&PrescSource,
				&VisitNumber1,		&VisitNumber2,				&PharmacistId,
				&PharmacistIdType,	&v_ErrorCode,				&NumPriorSales,
				&NumIshurim,		&ServiceWithoutCardNeeded,	END_OF_ARG_LIST		);

	SQLERR_error_test ();	// Possibly temporary, just to find any bugs in the TR6011_WriteAudit SQL setup.

	RESTORE_ISOLATION;

	return  RC_SUCCESS;
}	// End of 6011 handler.



/*=======================================================================
||																		||
||			 HandlerToMsg_6102											||
||	Message handler for message 6102:									||
||			 Count valid prescriptions for a list of members			||
||           (normally a family) for "Chanut Virtualit")				||
||																		||
 =======================================================================*/

int HandlerToMsg_6102 (	int			TransactionID_in,
						char		*IBuffer,
						int			TotalInputLen,
						cJSON		*JSON_MaccabiRequest,
						char		*OBuffer,
						int			*p_outputWritten,
						int			*output_type_flg,
						SSMD_DATA	*ssmd_data_ptr,
						int			*NumProcessed_out	)
{
	// Local variable declarations.
	short			v_ErrorCode;
	int				err;
	int				reStart;
	int				mac_status_code			= 0;
	int				NumProcessed			= 0;
	int				ListCounter				= 0;
	int				NumPrescriptions		= 0;

	int				Technical_ID			= 0;
	int				v_MemberIdentification	= 0;
	short			v_IdentificationCode	= 0;
	int				TranslateTechIdHttpStatus;
	PHARMACY_INFO	Phrm_info;

	cJSON			*JSON_InputData			= NULL;
	cJSON			*JSON_InputMembersList	= NULL;
	cJSON			*JSON_InputTechnicalID	= NULL;
	cJSON			*JSON_OutputObject		= NULL;
	cJSON			*JSON_OutputHeader		= NULL;
	cJSON			*JSON_OutputData		= NULL;
	cJSON			*JSON_OutputMemberArray	= NULL;
	cJSON			*JSON_OutputMember		= NULL;
	int				HTTP_response_status	= 200;	// Default to standard HTTP "OK".

	int				SysDate;
	int				SysTime;
	int				MinUntilDate;
	ISOLATION_VAR;


	// Body of function
 
	// Initialize variables.
	REMEMBER_ISOLATION;
	v_ErrorCode				= NO_ERROR;
	reStart					= MAC_FALS;
	SysDate					= GetDate ();
	SysTime					= GetTime ();

	// Date for deciding whether prescriptions are eligible to be filled.
	// DonR 13Jan2022: Use a parameter from pharmacy_type_params to control the Valid
	// Until Date tolerance. Since we don't get a Pharmacy Code in this transaction,
	// the SQL query uses hard-coded values for Permission Type, Owner, and Web
	// Pharmacy Code.
	ExecSQL (	MAIN_DB, Trn6102_READ_pharmacy_type_params,
				&Phrm_info.select_late_rx_days_buying_in_person		,	&Phrm_info.select_late_rx_days_ordering_online	,
				&Phrm_info.select_late_rx_days_filling_online_order	,	&Phrm_info.allow_online_order_days_before_expiry,
				END_OF_ARG_LIST																								);

	// No real error-handling - just use the current date if we couldn't retrieve anything.
	if (SQLCODE)
	{
		MinUntilDate = SysDate;
		SQLERR_error_test ();
	}
	else	// Good read of pharmacy_type_params.
	{
		MinUntilDate = AddDays (SysDate, (0 -	Phrm_info.select_late_rx_days_ordering_online));
	}


	// Read message fields data into variables.
	cJSON_GetObjectByName	(JSON_MaccabiRequest,	"_data",		MANDATORY,	&JSON_InputData);			CHECK_JSON_ERROR ();
	cJSON_GetArrayByName	(JSON_InputData,		"members_list",	MANDATORY,	&JSON_InputMembersList);	CHECK_JSON_ERROR ();

	NumProcessed = cJSON_GetArraySize (JSON_InputMembersList);

	if (glbErrorCode)
		SetErrorVar (&v_ErrorCode, ERR_WRONG_FORMAT_FILE);

	// SQL Retry Loop.
	reStart = MAC_TRUE;

	// Avoid unnecessary lock errors by downgrading "isolation".
	SET_ISOLATION_DIRTY;

	for (tries = 0; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		reStart = MAC_FALS;

		// Create output JSON objects.
		//
		// First, clear any existing data (in case we're retrying).
		if (JSON_OutputObject != NULL)
			cJSON_Delete (JSON_OutputObject);	// This should delete all "child" objects.

		// Now (re-)create the objects.
		JSON_OutputObject = cJSON_CreateObject ();

		if (JSON_OutputObject == NULL)
		{
			GerrLogMini (GerrId, "Couldn't create JSON_OutputObject!");
			// We should obviously do something more than log an error here -
			// but I'm not yet sure just what. In any case, creating the object
			// should never fail in real life - I hope!
		}

		// For the moment (at least), don't bother error-trapping the creation
		// of the subsidiary JSON objects.
		JSON_OutputHeader		= cJSON_AddObjectToObject	(JSON_OutputObject,	"header");
		JSON_OutputData			= cJSON_AddObjectToObject	(JSON_OutputObject,	"_data");
		JSON_OutputMemberArray	= cJSON_AddArrayToObject	(JSON_OutputData,	"members_list");


		// Master loop - read request and process it as we go.
		for (ListCounter = 0; ListCounter < NumProcessed; ListCounter++)
		{
			cJSON_GetArrayItemByNumber	(JSON_InputMembersList,	ListCounter,	MANDATORY,	&JSON_InputTechnicalID);	CHECK_JSON_ERROR ();
			err = cJSON_GetIntByName	(JSON_InputTechnicalID,	"technical_id",	MANDATORY,	&Technical_ID);				CHECK_JSON_ERROR ();

			if (glbErrorCode)
				SetErrorVar (&v_ErrorCode, ERR_WRONG_FORMAT_FILE);

			if (err)
			{
				continue;
			}

			// If we get here, we should actually have a Technical ID to look up.
			JSON_OutputMember = cJSON_AddNewObjectToArray (JSON_OutputMemberArray);

			err = TranslateTechnicalID (Technical_ID, &v_MemberIdentification, &v_IdentificationCode, NULL, &TranslateTechIdHttpStatus);

			if (err)
			{
				GerrLogMini (GerrId, "Trn. 6102: Could not translate Technical ID %d to Member TZ/Code; TranslateTechnicalID() returned %d/HTTP response %d.",
							 Technical_ID, err, TranslateTechIdHttpStatus);

				v_MemberIdentification = v_IdentificationCode = 0;	// Should be redundant!
			}

			// Now that we know who the member really is, see how many valid prescriptions s/he has.
			if (v_MemberIdentification)
			{
				ExecSQL	(	MAIN_DB, TR6102_READ_PrescriptionCount,
							&NumPrescriptions,
							&v_MemberIdentification,	&v_IdentificationCode,
							&MinUntilDate,				END_OF_ARG_LIST			);
				
				Conflict_Test (reStart);

				if (SQLCODE != 0)
				{
					NumPrescriptions = 0;
					SQLERR_error_test ();
					SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
				}
			}
			else
			{
				NumPrescriptions = 0;
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			}

			cJSON_AddAnyNumberToObject	(JSON_OutputMember,	"technical_id",					Technical_ID		);
			cJSON_AddAnyNumberToObject	(JSON_OutputMember,	"member_valid_prescriptions",	NumPrescriptions	);
			cJSON_AddAnyNumberToObject	(JSON_OutputMember,	"member_status_code",			(v_ErrorCode == ERR_MEMBER_ID_CODE_WRONG) ? -97 : 0	);

		}	// Loop through the input Members List array.


		// Retry if we hit a DB problem.
		if (reStart != MAC_FALS)	// DB errors - do a retry.
		{
			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogReturn (GerrId, "Trn. 6102: Table is locked for the <%d> time", tries);
			
			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}	// DB error occurred.

	}	// End of Database Retries loop.

	// See if we've exceeded the maximum retry count.
	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Trn. 6102: Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}

	// Populate Response Header object.
	if (SetErrorVar (&v_ErrorCode, v_ErrorCode))
	{
		// We hit a severe error.
		cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "E"				);
		cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "mac_error_code",		v_ErrorCode		);

		// If we've already set mac_status_code to something, keep that value; otherwise set it now.
		// If something in the incoming request was missing or incorrect, report a -98 status;
		// otherwise report a "generic" -99 error.
		if (v_ErrorCode == ERR_WRONG_FORMAT_FILE)
		{
			mac_status_code = -98;
			HTTP_response_status = 400;	// "Error on request" occurred.
		}
		else
		{
			mac_status_code = -99;
			HTTP_response_status = 500;	// Any miscellaneous fatal error occurred.
		}
	}
	else
	{
		// No severe error.
		HTTP_response_status = 200;	// Already defaulted, but paranoia is our friend!

		cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "S"	);
		mac_status_code = 0;
	}

	if (mac_status_code)
	{
		cJSON_AddAnyNumberToObject (JSON_OutputHeader, "mac_status_code",		mac_status_code);

		switch (mac_status_code)
		{
			case 0:		cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "Success"			);	break;
//			case -97:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "NoTechId"			);	break;
			case -98:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "RequestError"		);	break;
			case -99:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "InternalError"		);	break;
			default:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "UnknownError"		);	break;
		}
	}

	cJSON_AddAnyNumberToObject (JSON_OutputHeader, "HTTP_response_status",	HTTP_response_status);

#if 0
// TEMPORARY - TEST NEW JSON SEARCH FUNCTION.
do
{
	cJSON	*TestPtr;
	char	TestBuffer [5001];

//	TestPtr = cJSON_FindMatchingItem (JSON_OutputObject, "_data/members_list/member_status_code", -97);
	TestPtr = cJSON_FindMatchingItem (JSON_OutputObject, "_data/members_list/member_status_code", 0);
	cJSON_PrintPreallocated (TestPtr, TestBuffer, 5000, 1);
	GerrLogMini (GerrId, "Search for Status 0 first occurrence:\n%s\n", TestBuffer);
	TestPtr = cJSON_FindNextMatchingItem (JSON_OutputObject, "_data/members_list/member_status_code", 0, TestPtr);
	cJSON_PrintPreallocated (TestPtr, TestBuffer, 5000, 1);
//	GerrLogMini (GerrId, "Search for Status -97:\n%s\n", TestBuffer);
	GerrLogMini (GerrId, "\nSearch for Status 0 second occurrence:\n%s\n", TestBuffer);
	TestPtr = cJSON_GetParentObject (TestPtr);
	cJSON_PrintPreallocated (TestPtr, TestBuffer, 5000, 1);
	GerrLogMini (GerrId, "\nSearch for logical parent:\n%s\n", TestBuffer);

} while (0);
#endif

	// Send the output JSON hierarchy to file and delete it from memory.
	cJSON_PrintPreallocated (JSON_OutputObject, OBuffer, 65535, 1);
//	cJSON_PrintToFP (JSON_OutputObject, outFP);
//	cJSON_PrintToFP (JSON_OutputObject, stdio);
//	cJSON_PrintUnformattedToFP (JSON_OutputObject, outFP);
	cJSON_Delete (JSON_OutputObject);

	// Return the size in Bytes of response message.
	*p_outputWritten			= strlen (OBuffer);
	*output_type_flg			= ANSWER_IN_BUFFER;


	// DonR 27Jun2018: Up to now, we weren't saving the error code for this transaction. Now we are!
	ssmd_data_ptr->error_code	= v_ErrorCode;

	// DonR 23Nov2017: Store numberbar of prescription rows read from DB in audit variable;
	// leave "extra" largos out of the picture.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = NumProcessed;

	RESTORE_ISOLATION;

	return  RC_SUCCESS;
}	// End of 6102 handler.


/*===========================================================================
||																			||
||			 HandlerToMsg_6103												||
||	Message handler for message 6103:										||
||			 Predicted participation for a group of drugs, including		||
||           Meishar and Nihul Tikrot reductions for "Chanut Virtualit"		||
||																			||
 ===========================================================================*/

int HandlerToMsg_6103 (	int			TransactionID_in,
						char		*IBuffer,
						int			TotalInputLen,
						cJSON		*JSON_MaccabiRequest,
						char		*OBuffer,
						int			*p_outputWritten,
						int			*output_type_flg,
						SSMD_DATA	*ssmd_data_ptr,
						int			*NumProcessed_out	)
{
	// Local variable declarations.
	int					i;
	int					err;
	int					reStart;
	int					i_dummy;
	int					l_dummy;
	int					RowsFound;
	int					mac_status_code			= 0;
	int					ListCounter				= 0;
	int					NumPrescriptions		= 0;
	int					v_RecipeIdentifier		= 0;	// Used only if we need to contact Meishar and/or Nihul Tikrot.
	short				NumProcessed			= 0;	// Mapped to num_lines, which is a SMALLINT.
	short				NumDuplicates			= 0;
	short				DrugAlreadyInList		= 0;
	short				SameDrugSameDoctor		= 0;
	short				v_ErrorCode				= 0;

	int					v_PharmNum				= 0;
	short				v_InstituteCode			= 0;
	PHARMACY_INFO		Phrm_info;

	int					Technical_ID			= 0;
	int					TranslateTechIdHttpStatus;

	TDrugListRow		*DL;
	TDoctorPrescRow		*Rx;
	int					Yarpa_Price;
	int					Maccabi_Price;
	int					Supplier_Price;	// Ignored here, but still part of a lookup.
	int					UnitPrice;
	short				PriceCode;
	int					ReducedPrice;
	int					IshurPharm;
	int					IshurLargo;
	short				TikraFlag;
	short				SpecPresNumSrc;
	short				TikraTypeCode;
	short				InsuranceUsed;
	short				InHealthBasket;
	short				PermissionType;
	double				PtnWorkVar;
	double				PtnPerPackage_f;
	double				MemberPtn_f;
	double				DiscountMultiplier_f;
	int					PtnBeforeDiscount;
	Tmember_price_row	PriceRow;
	int					PtnOpPrice;
	int					AltYarpaPrice;
	int					MatchingDiagnosis;

	int					GadgetCodeFound;
	int					v_service_code;
	int					MaccabiPharmYarpa_Price;
	short				v_service_number;
	short				v_service_type;
	short				enabled_without_rx;
	short				GadgetPrevPurchaseClassCode;
	short				GadgetMinPrevPurchases;
	short				GadgetMaxPrevPurchases;
	bool				GoToMeishar;
	int					FullPackages;
	int					MeisharInfoCode;
	int					QuantityPermitted;
	int					RequestNum;
	int					PtnPrice;
	int					Insurance;

	cJSON				*JSON_InputData			= NULL;
	cJSON				*JSON_InputItemsList	= NULL;
	cJSON				*JSON_RxToGetPtn		= NULL;

	cJSON				*JSON_OutputObject		= NULL;
	cJSON				*JSON_OutputHeader		= NULL;
	cJSON				*JSON_OutputData		= NULL;
	cJSON				*JSON_OutputItemsArray	= NULL;
	cJSON				*JSON_OutputItem		= NULL;
	int					HTTP_response_status	= 200;	// Default to standard HTTP "OK".

	int					SysDate;
	int					SysTime;
	T6001_Drugs			SPres					[MAX_TRN6001_DRUGS];

	short				action_type				= 1;					// No deletions/returns in Trn. 6103.
	short				MemberBelongCode		= MACABI_INSTITUTE;		// Trn. 6103 will be used only for Maccabi members.
	short				terminal_id				= 0;					// No terminal ID is sent by Chanut Virtualit.
	short				origin_code				= 6103;

	// "Nihul Tikrot" remote procedure call buffers and related fields.
	char				DrugTikraType		[MAX_REC_ELECTRONIC];
	char				DrugCoupon			[MAX_REC_ELECTRONIC];
	int					DrugRefundOffset	[MAX_REC_ELECTRONIC];
	char				TikrotHeader		[RPC_INP_HEADER_LEN];
	char				TikrotCurrentSale	[RPC_INP_CURRSALE_LEN];
	char				TikrotPriorSales	[RPC_INP_PRIORSALES_LEN];
	char				TikraType			[MAX_TIKRA_TIKROT_OUT];
	char				TikraPeriodDesc		[MAX_TIKRA_TIKROT_OUT] [7];
	short				TikraBasket			[MAX_TIKRA_TIKROT_OUT];
	short				TikraInsurance		[MAX_TIKRA_TIKROT_OUT];
	int					TikraAggPrevPtn		[MAX_TIKRA_TIKROT_OUT];
	int					TikraAggPrevWaived	[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrPtn		[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrWaived		[MAX_TIKRA_TIKROT_OUT];
	int					TikraCurrLevel		[MAX_TIKRA_TIKROT_OUT];
	short				TikraCouponCode		[MAX_TIKRA_COUPONS_OUT];
	int					TikraCouponAmt		[MAX_TIKRA_COUPONS_OUT];
	int					FamilyMemberTZ		[MAX_FAMILY_SIZE];
	short				FamilyMemberTZCode	[MAX_FAMILY_SIZE];
	short				FamilySize;
	short				FamilySalePrID_count;
	char				*HeaderRtn;
	char				*TikrotRtn;
	char				*CurrentSaleRtn;
	char				*CouponsRtn;
	short				TikrotStatus;
	short				TikrotRPC_Called;
	short				TikrotRPC_Error;
	short				NumTikrotLines;
	short				NumSaleLines;
	short				NumCouponLines;
	short				v_NumDrugLinesSent;
	short				MemberBuyingTikMazon		= 0;
	short				MemberBuyingLH_FSH			= 0;	// DonR 12Feb2025 User Story #376480
	short				CheckThisDrugPiryonTikra	= 0;	// DonR 12Feb2025 User Story #376480
	short				CheckMonthlyPiryonTikra		= 0;	// DonR 12Feb2025 User Story #376480
	short				AnIshurHasTikra				= 0;
	char				*WritePtr;
	int					Yesterday;
	int					FamilySalePrID;
	int					tikra_discount	= 0;
	int					subsidy_amount	= 0;

	ISOLATION_VAR;


	// Body of function
 
	// Initialize variables.
	REMEMBER_ISOLATION;
	v_ErrorCode				= NO_ERROR;
	reStart					= MAC_FALS;
	SysDate					= GetDate ();
	SysTime					= GetTime ();

	memset ((char *)SPres,		0, sizeof(SPres));
	memset ((char *)&Phrm_info,	0, sizeof(PHARMACY_INFO));
	v_RecipeIdentifier	= 0;	// Paranoid redundant re-initialization.
	v_ErrorCode			= 0;	// Paranoid redundant re-initialization.
	tikra_discount		= 0;	// Paranoid redundant re-initialization.
	subsidy_amount		= 0;	// Paranoid redundant re-initialization.


	// Read message fields data into variables.
	cJSON_GetIntByName		(JSON_MaccabiRequest,	"technical_id",		MANDATORY,	&Technical_ID);				CHECK_JSON_ERROR ();
	cJSON_GetIntByName		(JSON_MaccabiRequest,	"pharmacy_id",		MANDATORY,	&v_PharmNum);				CHECK_JSON_ERROR ();

	// Read requested drugs into array.
	cJSON_GetObjectByName	(JSON_MaccabiRequest,	"_data",			MANDATORY,	&JSON_InputData);			CHECK_JSON_ERROR ();
	cJSON_GetArrayByName	(JSON_InputData,		"items_list",		MANDATORY,	&JSON_InputItemsList);		CHECK_JSON_ERROR ();

	NumProcessed = cJSON_GetArraySize (JSON_InputItemsList);

	for (ListCounter = 0; ListCounter < NumProcessed; ListCounter++)
	{
		cJSON_GetArrayItemByNumber	(JSON_InputItemsList,	ListCounter,		MANDATORY,	&JSON_RxToGetPtn);							CHECK_JSON_ERROR ();

		err = cJSON_GetIntByName	(JSON_RxToGetPtn,		"orig_largo",		MANDATORY,	&SPres[ListCounter].Rx.largo_prescribed);	CHECK_JSON_ERROR ();
		err = cJSON_GetIntByName	(JSON_RxToGetPtn,		"dispense_largo",	MANDATORY,	&SPres[ListCounter].DL.largo_code);			CHECK_JSON_ERROR ();
		err = cJSON_GetIntByName	(JSON_RxToGetPtn,		"doctor_id",		MANDATORY,	&SPres[ListCounter].Rx.doctor_id);			CHECK_JSON_ERROR ();
		err = cJSON_GetIntByName	(JSON_RxToGetPtn,		"prescription_id",	MANDATORY,	&SPres[ListCounter].Rx.doctor_presc_id);	CHECK_JSON_ERROR ();
		err = cJSON_GetShortByName	(JSON_RxToGetPtn,		"units_ordered",	MANDATORY,	&SPres[ListCounter].TotalUnitsToSell);		CHECK_JSON_ERROR ();
		err = cJSON_GetIntByName	(JSON_RxToGetPtn,		"dr_visit_date",	MANDATORY,	&SPres[ListCounter].Rx.visit_date);			CHECK_JSON_ERROR ();	// Added to specification 05Jul2021.

		if (err)
		{
			continue;
		}
	}

	// If we hit an error getting input data, store the error code now, but don't quit the function.
	if (glbErrorCode)
		SetErrorVar (&v_ErrorCode, ERR_WRONG_FORMAT_FILE);


	// Translate Technical ID to Member TZ and attempt to read member data.
	err = TranslateTechnicalID (Technical_ID, NULL, NULL, &Member, &TranslateTechIdHttpStatus);

	if (err)
	{
		GerrLogMini (GerrId, "6103: Could not translate Technical ID %d to Member TZ/Code; TranslateTechnicalID() returned %d/HTTP response %d.",
						Technical_ID, err, TranslateTechIdHttpStatus);

		Member.member_id = 0;	// Setting to zero should be redundant!
								// This function should throw an error for TZ = 0, which is what we want in this case.
	}

	// Copy relevant fields to SSMD structure.
	// Note that Member.ID and Member.ID_code are redundant now, and should really be eliminated.
	ssmd_data_ptr->pharmacy_num		= v_PharmNum;
	ssmd_data_ptr->member_id		= Member.ID;
	ssmd_data_ptr->member_id_ext	= Member.ID_code;


	// SQL Retry Loop.
	reStart = MAC_TRUE;

	// Avoid unnecessary lock errors by downgrading "isolation".
	SET_ISOLATION_DIRTY;

	for (tries = 0; tries < SQL_UPDATE_RETRIES && reStart == MAC_TRUE; tries++)
	{
		reStart = MAC_FALS;

		// Test pharmacy data.
		err = IS_PHARMACY_OPEN (v_PharmNum, v_InstituteCode, &Phrm_info);
		if (err != MAC_OK)
		{
			SetErrorVar (&v_ErrorCode, err);
//
//			if (err == ERR_PHARMACY_NOT_FOUND)
//				mac_status_code = -98;
//
			break;
		}

		// Use the Institute Code we read from the pharmacy table.
		// (Note that at least in this transaction, Institute Code isn't really used for anything much.)
		v_InstituteCode = Phrm_info.institute_code;


		// Test Member validity.
		// Member ID must be non-zero. In fact, it must be at least 58, for some reason.
		if (Member.member_id < 58)
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			break;
		}

		// Try to read Member row.
		// DonR 13May2020 CR #31591: Add new Member-on-Ventilator flag. This is
		// currently stored in the old column "asaf_code" (which was sent from
		// AS/400 but never used for anything); when we switch to MS-SQL, the
		// column should be renamed.
		ExecSQL (	MAIN_DB, READ_members_full,
					&Member.last_name,				&Member.first_name,				&Member.date_of_bearth,
					&Member.maccabi_code,			&Member.spec_presc,				&Member.maccabi_until,
					&Member.payer_tz,				&Member.payer_tz_code,			&Member.sex,
					&Member.phone,					&Member.house_num,				&Member.street,
					&Member.city,					&Member.zip_code,				&Member.insurance_type,

					&Member.keren_mac_code,			&Member.keren_mac_from,			&Member.keren_mac_until,
					&Member.mac_magen_code,			&Member.mac_magen_from,			&Member.mac_magen_until,
					&Member.yahalom_code,			&Member.yahalom_from,			&Member.yahalom_until,
					&Member.carry_over_vetek,		&Member.keren_wait_flag,		&Member.illness_bitmap,
					&Member.card_date,				&Member.update_date,			&Member.update_time,

					&Member.authorizealways,		&Member.updated_by,				&Member.check_od_interact,
					&Member.credit_type_code,		&Member.max_drug_date,			&Member.member_discount_pt,
					&Member.insurance_status,		&Member.idnumber_main,			&Member.idcode_main,
					&Member.has_tikra,				&Member.has_coupon,				&Member.in_hospital,
					&Member.VentilatorDiscount,		&Member.darkonai_type,			&Member.force_100_percent_ptn,

					&Member.darkonai_no_card,		&Member.has_blocked_drugs,		&Member.died_in_hospital,
					&Member.mahoz,					&Member.dangerous_drug_status,

					&Member.member_id,				&Member.mem_id_extension,		END_OF_ARG_LIST					);
// GerrLogMini (GerrId, "Member %d (Technical ID %d): member_discount_pt = %d, discount_percent = %d, SQLCODE = %d.", Member.member_id, Technical_ID, Member.member_discount_pt, Member.discount_percent, SQLCODE);

		Conflict_Test (reStart);

		// DonR 04Dec2022 User Story #408077: Use a new function to set some Member flags and values.
		SetMemberFlags (SQLCODE);
			
		if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
		{
			SetErrorVar (&v_ErrorCode, ERR_MEMBER_ID_CODE_WRONG);
			break;
		}
			
		if (SQLERR_error_test ())
		{
			SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
			break;
		}
		else
		{	// Successful read of member data.

			// Logical data tests on Member eligibility.
			// DonR 25Nov2021 User Story #206812: Get died-in-hospital indicator from the Ishpuz system.
			// (Currently disabled.)
			// DonR 30Nov2022 User Story #408077: Use new macro MEMBER_INELIGIBLE (defined in MsgHndlr.h)
			// to decide if this member is eligible. Also, use a new macro MEMBER_IN_MEUHEDET (defined in
			// MsgHndlr.h) to decide if the person is a Meuhedet member.
			if ((MEMBER_INELIGIBLE) || (MEMBER_IN_MEUHEDET))
//				(Member.died_in_hospital)				||		// CONDITION DISABLED, AT LEAST FOR NOW.
			{
				SetErrorVar (&v_ErrorCode, ERR_MEMBER_NOT_ELEGEBLE);
				break;
			}

		}	// Successful read of member data.


		// Now that we've done the preliminary stuff, process the list of prescriptions
		// the "virtual pharmacy" sent.
		// NOTE: This transaction is executed *after* Transaction 6101, which checks for
		// generic-drug substitution. Accordingly, we can accept "dispense_largo" (loaded
		// to SPres[ListCounter].DL.largo_code) as the drug to check for "hishtatfut"
		// without worrying about generic subsitution.
		// QUESTION: Will we need more information than what the pharmacy sends? If so,
		// we can do a lookup based on what we do get: Member TZ, Doctor Prescription ID,
		// and Largo Prescribed. The relevant SQL would presumably be a variation of
		// TR6001_doctor_presc_cur_simplified.
		for (ListCounter = 0; ListCounter < NumProcessed; ListCounter++)
		{
			DL = &SPres[ListCounter].DL;
			Rx = &SPres[ListCounter].Rx;

			// Start with the assumption that nothing is wrong.
			SPres[ListCounter].DrugAnswerCode	= NO_ERROR;
			SPres[ListCounter].DFatalErr		= MAC_FALS;

			// DonR 28Apr2025 User Story #390071: Predicting participation now requires that we
			// know the doctor-chosen Rule Number, if any; if the doctor did specify a "nohal"
			// from drug_extension, predict_member_participation() will use it automatically so
			// the pharmacy will not have to issue a pharmacy ishur.
			ExecSQL (	MAIN_DB, READ_Rx_DoctorRuleNumber,
						&Rx->rule_number,
						&Member.ID,				&Member.ID_code,		&Rx->doctor_id,
						&Rx->doctor_presc_id,	&Rx->largo_prescribed,	&Rx->visit_date,
						END_OF_ARG_LIST														);

			// Do NOT treat errors here as fatal - just log them and continue.
			if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
			{
				Rx->rule_number = 0;	// Should be redundant.
				GerrLogMini (GerrId,	"Trn. 6103: READ_Rx_DoctorRuleNumber couldn't find data for "
										"Member %d/%d Doctor %d Presc ID %d Largo Prescribed %d Visit Date %d.",
										Member.ID, Member.ID_code, Rx->doctor_id, Rx->doctor_presc_id,
										Rx->largo_prescribed, Rx->visit_date										);
			}
			else
			if (SQLERR_error_test ())
			{
				Rx->rule_number = 0;	// Should be redundant.
				GerrLogMini (GerrId,	"Trn. 6103: READ_Rx_DoctorRuleNumber failed (SQLCODE %d) for "
										"Member %d/%d Doctor %d Presc ID %d Largo Prescribed %d Visit Date %d.",
										SQLCODE, Member.ID, Member.ID_code, Rx->doctor_id, Rx->doctor_presc_id,
										Rx->largo_prescribed, Rx->visit_date										);
			}

			// DonR 28Oct2021 User Story #202451: Start with the assumption that this is the
			// first occurrence of this Largo Code in the list.
			SPres[ListCounter].FirstOccurrenceOfLargoSubscript = ListCounter;

			// The same drug may appear several times in the list of prescriptions. To save time,
			// copy stuff from the first instance of a drug in the prescription list rather than
			// looking everything up in the database multiple times.
			// Note that in general, we're not very interested in the prescribed drug in this
			// transaction - only in the drug to be dispensed.
			for (i = DrugAlreadyInList = SameDrugSameDoctor = 0; i < ListCounter; i++)
			{
				if (SPres[i].DL.largo_code == DL->largo_code)		// Repeat drug.
				{
					// DonR 28Oct2021 User Story #202451: Set FirstOccurrenceOfLargoSubscript to the
					// correct value, so we know that this array element is a repeat of an earlier
					// Largo Code.
					SPres[ListCounter].FirstOccurrenceOfLargoSubscript = i;
					NumDuplicates++;

					// Copy the stuff that's drug-dependent but *not* doctor-dependent.
					if (!DrugAlreadyInList)	// We need to copy the drug stuff only once.
					{
						DrugAlreadyInList							= 1;
						SPres[ListCounter].DL						= SPres[i].DL;
						SPres[ListCounter].YarpaPrice				= SPres[i].YarpaPrice;
						SPres[ListCounter].MaccabiPrice				= SPres[i].MaccabiPrice;			// DonR 25Jan2022 BUG FIX - need to copy Maccabi Price as well as Yarpa Price.
						SPres[ListCounter].LargoBlockedForMember	= SPres[i].LargoBlockedForMember;	// DonR 21Nov2021 User Story #196891
						// Don't break here, since the same drug may have been prescribed by multiple
						// doctors and we want to avoid database lookups to determine participation,
						// when possible.
					}

					// We can safely copy participation info from a previous item in the array if the two
 					// items are for the same drug AND the same doctor, OR if they're for the same non-specialist
					// drug (in which case the prescribing doctor is irrelevant in determining participation).
					// DonR 28Apr2025 User Story #390071: If two different doctors prescribed the same drug BUT one
					// of them chose a Rule Number and the other didn't (or they both did, but using different
					// "nohalim"), do NOT set SameDrugSameDoctor TRUE - we need to predict participation based, in
					// part, on the rule number(s) the doctor(s) chose. We will assume, though, that the same doctor
					// consistently chose the same rule (or left it out), so there is a limit to our paranoia. (This
					// is how Transaction 6003 works, and we want to be as consistent as possible.)
					SameDrugSameDoctor	=	(	(	(DL->specialist_drug == 0)
													&&
													(Rx->rule_number	== SPres[i].Rx.rule_number)
												)
												||
												(	Rx->doctor_id		== SPres[i].Rx.doctor_id)
											);
//					SameDrugSameDoctor	= ((DL->specialist_drug	== 0)		||
//										   (Rx->doctor_id		== SPres[i].Rx.doctor_id));

					if (SameDrugSameDoctor)
					{
						SPres[ListCounter].PriceCode		= SPres[i].PriceCode;
						SPres[ListCounter].ReducedPrice		= SPres[i].ReducedPrice;
						SPres[ListCounter].FixedPriceFlag	= SPres[i].FixedPriceFlag;
						SPres[ListCounter].PriceMessageCode	= SPres[i].PriceMessageCode;	// NIU for 6103 as specified, but leave it in just in case!

						// DonR 27Apr2021 "Chanut Virtualit":
						// Copy the Shape Name only if it's the same drug *and* the same doctor - otherwise
						// there might be a "dispense as written" ishur that applies to some prescriptions
						// but not to others for the same drug. In theory, if there are prescriptions for
						// the same drug from multiple doctors, this will result in extra lookups to the
						// drug_shape table; but in real life, I don't think this happens all that often,
						// and the lookup is a fast and simple one anyway.
						// (Note that as of now, we don't actually use Shape stuff in this transaction.)
						strcpy (SPres[ListCounter].ShapeName, SPres[i].ShapeName);			// NIU for 6103 as specified, but leave it in just in case!

						break;	// No need to keep looking, since we've found our perfect match!

					}	// Same drug, same doctor - copy participation data.
				}	// Same drug - copy drug_list data.
			}	// Loop through array to find drug/drug+doctor matches.

			// If this is the first occurrence of this drug in the list, read its drug_list info.
			// Note that we are *not* using the drug prescribed, since we already performed
			// generic substitution in Transaction 6101.
			if (!DrugAlreadyInList)
			{
				// DonR 08Apr2018: Added new "see deleted drugs" parameter to read_drug(). Since deleted
				// drugs shouldn't be dispensed, here we just set the parameter FALSE.
				if (!read_drug (DL->largo_code,
								NO_MAX_LARGO,
								&Phrm_info,
								false,		// Deleted drugs are "invisible".
								DL,
								NULL))
	 			{
					// DonR 01Nov2020: Add logging of any unexpected DB error reading drug_list.
					if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
					{
						SQLERR_error_test ();
					}

					// Although it should never happen in real life, we need to define what we
					// will do if a drug is not found - since the virtual pharmacy sent the list
					// of drugs, we can't just skip the drug even if there's a problem!

				}
				else	// Good read of drug_list.
 				{
					// DonR 21Nov2021 User Story #196891: Check whether this drug is blocked for this member.
					// DonR 13Mar2025 User Story #384811: To support more detailed drug-blocking based on
					// different categories of Darkonaim (Maccabi, Harel Tourists, Harel Foreign Workers),
					// add Darkonai Type (3 times) to the READ_CheckDrugBlockedForMember parameter list.
					if ((Member.has_blocked_drugs) || (DL->has_member_type_exclusion))	// Don't waste a DB lookup if we know we won't get results.
					{
						ExecSQL (	MAIN_DB, READ_CheckDrugBlockedForMember,
									&RowsFound,
									&Member.ID,
									&Member.darkonai_type,	&Member.darkonai_type,	&Member.darkonai_type,
									&DL->largo_code,		&Member.ID_code,		END_OF_ARG_LIST			);

						if ((SQLCODE == 0) && (RowsFound > 0))
						{
							// Mark this drug as blocked - so for private pharmacies, we'll know we have to
							// force participation to 100%, and we'll pass an indicator to the Nihul Tikrot
							// application so it knows to leave this item out of its calculations.
							// NOTE: SPres is already initialized to all-zeroes, so we don't need a separate
							// initialization for SPres[DrugCount].LargoBlockedForMember.
							SPres[ListCounter].LargoBlockedForMember = 1;
						}
						else
						{
							if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
							{
								SQLERR_error_test ();
							}
						}
					}	// Member has blocked drugs.

					// Set flag for member if at least one item to be checked is "Mazon im Tikra".
					// DonR 12Feb2025 User Story #376480: Only a value of 1 for tikrat_mazon_flag
					// indicates member is buying a relevant food/supplement. Now a value of 2
					// indicates that the drug is a fertility treatment (LH/FSH) that may be eligible
					// for a new category of monthly tikra discount.
					if (DL->tikrat_mazon_flag == 1)
						MemberBuyingTikMazon = true;

					// DonR 12Feb2025 User Story #376480: All drugs involved in the new monthly LH/FSH tikra
					// feature *should* have the same value for tikrat_piryon_pharm_type - but it's best to
					// be a little paranoid and allow for the possibility that there may in future be some
					// drugs that get this tikra at different categories of pharmacy. So we need to use two
					// different boolean variables: CheckThisDrugPiryonTikra tells us whether the current
					// drug line qualifies for this tikra, while CheckMonthlyPiryonTikra tells us whether any
					// drug in the current sale request qualifies.
					if (DL->tikrat_mazon_flag == 2)
					{
						MemberBuyingLH_FSH			=	true;
						CheckThisDrugPiryonTikra	=	(	((DL->tikrat_piryon_pharm_type == 0) && PRIVATE_PHARMACY	) ||
															((DL->tikrat_piryon_pharm_type == 1) && MACCABI_PHARMACY	) ||
															( DL->tikrat_piryon_pharm_type == 2							) ||
															((DL->tikrat_piryon_pharm_type == 6) && MACCABI_PHARMACY	) ||
															((DL->tikrat_piryon_pharm_type == 6) && PRATI_PLUS_PHARMACY	)	);
					}
					else
					{
						CheckThisDrugPiryonTikra	=	false;
					}

					// DonR 12Feb2025 User Story #376480: Instead of sending Nihul Tikrot the value in
					// drug_list/tikrat_mazon_flag, we need to send zero (actually sent as a space) when
					// tikrat_mazon_flag == 2 but the requesting pharmacy does not qualify for tikrot on
					// LH/FSH fertility drugs. We support this by creating a new structure element,
					// SPres[].TikratMazonFlagSend. Note that we need to use DL.tikrat_mazon_flag in this
					// condition, since we need to qualify each drug line based on its own criteria!
					SPres[ListCounter].TikratMazonFlagSend =
						((DL->tikrat_mazon_flag == 1) || CheckThisDrugPiryonTikra) ? DL->tikrat_mazon_flag : 0;

					// If *any* drug qualifies for the monthly LH/FSH tikra, set the need-to-check flag TRUE.
					CheckMonthlyPiryonTikra = (CheckMonthlyPiryonTikra || CheckThisDrugPiryonTikra);

					// For Chanut Virtualit, retrieve the drug's Yarpa Price so we can check
					// (later on) whether it's too expensive for pickup/delivery, and also
					// use it to calculate member participation.
					ExecSQL (	MAIN_DB, READ_PriceList_simple,
								&Yarpa_Price,		&Maccabi_Price,				&Supplier_Price,
								&DL->largo_code,	&Phrm_info.price_list_num,	END_OF_ARG_LIST		);

					SPres[ListCounter].YarpaPrice	= (SQLCODE == 0) ? Yarpa_Price		: 0;
					SPres[ListCounter].MaccabiPrice	= (SQLCODE == 0) ? Maccabi_Price	: 0;
				}	// Good read of drug_list.
			}	// Need to read a new drug from drug_list table.

			// If we haven't already gotten participation info for the same drug and doctor, do it now.
			if (!SameDrugSameDoctor)
			{
				// Substitute Generic Drugs IF member doesn't have an AS/400 ishur for the prescribed drug.
				// Per Iris Shaya, if there is an AS/400 ishur for this member/drug, don't perform
				// generic-drug substitution. Note that (at least for now) we aren't worrying about
				// the extension of expired ishurim here - we look only at "normal", active ishurim!
				// DonR 22Mar2011: Reordered last two WHERE criteria to conform to index structure.
				// DonR 23Mar2011: Don't look for an AS/400 ishur if we already know member doesn't have one.
				// DonR 12Sep2012: Ishurim with Member Price Code of zero are invalid - ignore them!
				// NOTE: For now at least, we are NOT looking at all the conditions for an ishur to apply
				// to the member's participation; this means, for example, that if the ishur is good for
				// Maccabi pharmacies only, we'll still use the ishur's participation info even if the
				// member is at a private pharmacy.
				// DonR 12Jul2017: Instead of using a cursor, just do a SELECT FIRST 1.
				// DonR 18Feb2018: It might be possible to collapse these two into a single SELECT, using
				// an ORDER BY / CASE construction - i.e. ORDER BY CASE sl.largo_code
				// WHEN :LargoPrescribed THEN -999 ELSE dl.economypri_seq. I'm not sure if this would work,
				// but it might be fun to try!
				// NOTE: Because we already performed any required generic substitution in Transaction 6101
				// (including looking for ishurim for substitute drugs) at this point we can just look for
				// an ishur for the drug to be dispensed - we already know that this is the "right" drug.
				// DonR 21Nov2021 User Story #196891: Note that we are *not* disabling ishur participation
				// checks for drugs blocked in member_blocked_drugs. This is the same here as in 6001/6101
				// and 6003; I'm assuming that nobody would block a drug for which there was a member ishur,
				// or issue an ishur for a blocked drug.
				if (Member.spec_presc)
				{
					// DonR 07Nov2022 BUG FIX 272058: If this is an ishur that's "attached" to a particular pharmacy,
					// Maccabi pharmacies other than the "attached" one can still sell the drug with the ishur
					// discount - they just get a ERR_SPEC_PR_FOR_OTHER_PHARM_WRN warning message in Transaction
					// 6003. Accordingly, we need these ishurim to be visible to all Maccabi pharmacies in
					// Transaction 6001/6101. To support this, added a second instance of the Maccabi Pharmacy
					// flag to the relevant SQL as the 8th input parameter.
					ExecSQL (	MAIN_DB, TR6103_READ_special_prescs,
								&PriceCode,					&ReducedPrice,					&IshurPharm,
								&PermissionType,			&IshurLargo,					&TikraFlag,
								&SpecPresNumSrc,			&TikraTypeCode,					&InsuranceUsed,
								&InHealthBasket,

								&Member.member_id,			&DL->largo_code,				&SysDate,
								&SysDate,					&Phrm_info.maccabi_pharmacy,	&Phrm_info.private_pharmacy,
								&v_PharmNum,				&Phrm_info.maccabi_pharmacy,	&Member.mem_id_extension,
								END_OF_ARG_LIST																				);

					if (SQLCODE == 0)	// Successful ishur read.
					{
						SPres[ListCounter].PriceCode			= PriceCode;
						SPres[ListCounter].ReducedPrice			= ReducedPrice;
						SPres[ListCounter].SpecPrescNumSource	= SpecPresNumSrc;
						SPres[ListCounter].IshurTikraType		= TikraTypeCode;
						SPres[ListCounter].InsuranceUsed		= InsuranceUsed;
						SPres[ListCounter].InHealthBasket		= InHealthBasket;
						SPres[ListCounter].FixedPriceFlag		= ((PriceCode == 1) && (ReducedPrice > 0)) ? 1 : 0;
						SPres[ListCounter].FoundAs400Ishur		= true;										// Get ptn. from ishur, even if it's 100% w/o fixed price.
						SPres[ListCounter].PtnRequiresPratiPlus	= (PermissionType == 6) ? 1 : 0;
						AnIshurHasTikra							= (TikraFlag > 0) ? 1 : AnIshurHasTikra;	// I.e. set TRUE or else leave the current value unchanged.
					}	// Found an applicable ishur.
				}	// Member has an AS/400 Ishur for something.

				// At this point, if the Member Price Code variable has a non-zero value, we're taking
				// participation from an AS/400 ishur.
				if (SPres[ListCounter].PriceCode < 1)
				{
					// DonR 07Jun2015: Moved call to predict_member_participation() inside the "this drug is not
					// covered by an AS/400 ishur" block, since we don't grant other discounts if we're getting
					// participation (even if it's full price!) from an AS/400 ishur.
					//
					// Predict member participation and generate discount-possible message code, if applicable.
					// Note that Doctor ID Type is zero (= Maccabi doctor) by definition for prescriptions in doctor_presc.
					//
					// DonR 30Jan2019 CR #27234: If the requesting pharmacy does not have "hesder Maccabi", do *not*
					// calulate predicted participation - just send the full price.
					// DonR 16Aug2021 User Story #163882: Treat darkonaim-plus people who always pay 100% (minus shovarim
					// they get from their insurance company) the same as people buying drugs at non-hesder pharmacies.
					// DonR 28Apr2025 User Story #390071: Add doctor-chosen Rule Number to predict_member_participation()
					// arguments, since 6003 now uses these rules automatically to grant discounts without requiring a
					// pharmacy ishur.
					if ((HESDER_MACCABI) && (!Member.force_100_percent_ptn) && (!SPres[ListCounter].LargoBlockedForMember))
					{
						err = predict_member_participation (&Member,
															DL,
															&Phrm_info,
															0,	// Doctor ID Type.
															Rx->doctor_id,
															Rx->visit_date,		// Added to specification 05Jul2021.
															Rx->rule_number,	// DonR 28Apr2025 User Story #390071.
															&SPres[ListCounter].PriceCode,
															&SPres[ListCounter].PricePercent,
															&SPres[ListCounter].FixedPriceFlag,
															&SPres[ListCounter].ReducedPrice,
															&PermissionType,
															&SPres[ListCounter].InsuranceUsed,
															&SPres[ListCounter].InHealthBasket,
															NULL);
					}
					else
					{
						// Members buying drugs at non-hesder pharmacies, as well as darkonaim-plus
						// people who don't get Maccabi discounts, pay full price.
						SPres[ListCounter].PriceCode		= 1;	// = 100%
						SPres[ListCounter].FixedPriceFlag	= 0;	// = No discounted price
						SPres[ListCounter].ReducedPrice		= 0;	// = No discounted price
						SPres[ListCounter].InsuranceUsed	= 0;	// = No insurance
						SPres[ListCounter].InHealthBasket	= 0;	// = Not in Health Basket
						PermissionType						= 0;	// = Full-price participation is not dependent on "Prati Plus".
					}

					SPres[ListCounter].PtnRequiresPratiPlus = (PermissionType == 6) ? 1 : 0;
				}	// Drug to be sold is not covered by AS/400 ishur.

				// If we haven't found any discount at all, force InHealthBasket FALSE.
				if ((SPres[ListCounter].PriceCode < 2) && (SPres[ListCounter].ReducedPrice == 0))
				{
					SPres[ListCounter].InHealthBasket	= 0;	// = Not in Health Basket
				}

			}	// SameDrugSameDoctor is FALSE - this is the first occurrence of this Largo Code in the list of prescriptions.


			// At this point, we know the member participation per OP; now calculate the
			// actual participation based on the quantity the pharmacy specified.

			// DonR 26Apr2021 "Chanut Virtualit": Calculate the actual member participation
			// based on quantity prescribed, PriceCode, and ReducedPrice.
			if (SPres[ListCounter].ReducedPrice > 0)
			{
				PtnPerPackage_f = (double)SPres[ListCounter].ReducedPrice;
			}
			else
			{
				// If we didn't get a fixed price (from an ishur or from some kind of "nohal"),
				// we have to muck about with percentages, minimum/maximum prices, and so on.
				GET_MEMBER_PRICE_ROW (SPres[ListCounter].PriceCode, &PriceRow);
// ADD ERROR HANDLING!

				// DonR 20May2021: Moved the price_list lookup to just after we read the drug_list table,
				// so we can use the drug's Yarpa Price to check whether it's too expensive for pickup
				// or delivery.
				// DonR 20Jan2022: If we haven't found any other reduced price (either a fixed price
				// or a participation percentage less than 100), use the Maccabi Price if it exists.
				// Note that the use of the Maccabi Price mean that the sale is no longer at 100% for
				// purposes of preventing full-price sales at MaccabiPharm.
				PtnOpPrice = ((PriceRow.member_price_prcnt == 10000) && (SPres[ListCounter].MaccabiPrice > 0)) ?
								SPres[ListCounter].MaccabiPrice : SPres[ListCounter].YarpaPrice;

				// DonR 29Jun2023 User Story #461368: In order to reduce inflation, the Ministry of Health has
				// ordered a six-month price freeze on member participation for drugs in the Health Basket. We
				// are implementing this by adding a special price list (Price List Code = 21) that will store
				// the June 2023 prices; the Yarpa Price from this list will be used for participation calculation
				// in place of the new, higher Yarpa Price if all the conditions are met. Note that the "treatments
				// only" logic is being implemented on the AS/400 feed to the RK9017P/price_list table, so we don't
				// need it here - but I'm leaving it here in remarked-out form anyway, just in case we decide later
				// to enable it.
				// DonR 04Jul2023 User Story #461368: Updated criteria to match what Orli Spiegel is doing on AS/400.
				// Now we *do* check for "trufot", but we do *not* check Insurance Used. In real life, the results
				// should be the same, since Health Basket is normally FALSE when non-basic insurance is used and
				// only "trufot" should be included in Price List 21 anyway.
				// Marianna 09Jul2023 User Story #463302: Add a new sysparams flag, alt_price_list_only_if_cheaper, to
				// allow the "frozen" alternate Yarpa Price to be used unconditionally, even if it's higher than the
				// price from the current price list.
				if ((SysDate									>= alt_price_list_first_date	)	&&
					(SysDate									<= alt_price_list_last_date		)	&&
					(alt_price_list_code						>  0							)	&&
					(DL->largo_type								== 'T'							)	&&	// This is a "treatment" (i.e. a normal drug).
//					(SPres[ListCounter].InHealthBasket			!= 0							)	&&	// Implies a prescription sale with price < 100%.
//					(SPres[ListCounter].InsuranceUsed			== BASIC_INS_USED				))
					(SPres[ListCounter].InHealthBasket			!= 0							))
				{
					ExecSQL (	MAIN_DB, READ_AlternateYarpaPrice,
								&AltYarpaPrice,
								&DL->largo_code,					&alt_price_list_code,
								&SPres[ListCounter].YarpaPrice,		&alt_price_list_only_if_cheaper,	// Marianna 09Jul2023 User Story #463302.
								END_OF_ARG_LIST															);

					Conflict_Test (reStart);

					if (SQLCODE ==  0)
					{
						// Copy the alternate Yarpa price to the working OP Price variable.
						PtnOpPrice = AltYarpaPrice;
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6103: Substituting Price List %d price of %d for default Yarpa Price %d for Largo %d.",
//	alt_price_list_code, PtnOpPrice, SPres[ListCounter].YarpaPrice, DL->largo_code);
					}	// Successful read of alternate (frozen) Yarpa Price.
					else
					{	// Did NOT read an alternate (frozen) Yarpa Price. PtnOpPrice will retain its default value.

						if (SQLERR_code_cmp (SQLERR_not_found) == MAC_TRUE)
						{
							// Not Found is perfectly OK - take no action other than (redundantly)
							// setting SPres[i].AlternateYarpaPrice to zero.
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6103: Did NOT find a Price List %d price better than the default Yarpa Price %d for Largo %d.",
//	alt_price_list_code, SPres[ListCounter].YarpaDrugPrice, DL->largo_code);
						}
						else
						{
							if (SQLERR_error_test ())
							{
if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6103: SQLCODE %d trying to read Price List %d for a price better than the default Yarpa Price %d for Largo %d.",
	SQLCODE, alt_price_list_code, SPres[ListCounter].YarpaPrice, DL->largo_code);
										SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
							}
						}	// Some SQL error other than not-found.
					}	// Did NOT successfully read an alternate (frozen) Yarpa Price.
				}	// We want to try reading an alternate (frozen) Yarpa Price for this item.
					// DonR 29Jun2023 User Story #461368 end.

				// If there is a minimum discounted price, use that if the package price is within range.
				// If price is below the minimum, there is no discount.
				if ((PriceRow.min_reduced_price > 0) && (PriceRow.max_pkg_price > 0))
				{
					if ((PtnOpPrice >= PriceRow.min_reduced_price) &&
						(PtnOpPrice <= PriceRow.max_pkg_price))	// Or just "<"?
					{
						PtnPerPackage_f = (double)PriceRow.min_reduced_price;
					}
					else
					{
						// If price is above the top of the range for the minimum discounted price,
						// apply percentage discount.
						if (PtnOpPrice > PriceRow.max_pkg_price)
						{
							PtnPerPackage_f = (double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
						}
						else
						{
							PtnPerPackage_f = (double)PtnOpPrice;	// Cheap drug = no discount.
						}
					}
				}	// Participation type has a minumum per-package price.
				else
				{
					// For any participation code without minimum/maximum pricing, just apply the code's percentage discount.
					PtnPerPackage_f = (double)PtnOpPrice * (double)PriceRow.member_price_prcnt / (double)10000;
				}	// This Price Code has no minimum per-package price.
			}	// No fixed price, so we have to derive the per/OP price from price_list and member_price.

			// Save the per-OP member participation.
			SPres[ListCounter].MemberPtnPerPackage = (int)(PtnPerPackage_f + 0.5001);

			// Now multiply PtnWorkVar (the net per-package price) by the total number of fractional
			// packages to sell. To avoid size-of-variable limitations, use a double-precision float
			// variable for calculations.
			MemberPtn_f = PtnPerPackage_f * ((double)SPres[ListCounter].TotalUnitsToSell / (double)DL->package_size);
// GerrLogMini (GerrId, "Ptn %d/OP = %f for %f OP.", SPres[ListCounter].MemberPtnPerPackage, PtnWorkVar, ((double)SPres[ListCounter].TotalUnitsToSell / (double)DL->package_size));

			// We add a smidgin to member participation in case any precision issue causes us to lose an agora.
			SPres[ListCounter].TotalMemberPtn = (int)(MemberPtn_f + 0.5001);
// GerrLogMini (GerrId, "Pre-Meishar TotalMemberPtn for %d units of %d = %d.", SPres[ListCounter].TotalUnitsToSell, DL->largo_code, SPres[ListCounter].TotalMemberPtn);


			// DonR 14Jun2004: If "drug" being purchased is a device in the "gadgets" table,
			// retrieve the appropriate information and query the AS400 for participation information.
			// Note that for Transaction 6103, all items are prescribed - so we're not interested
			// in non-prescription gadgets rows. Note also that if the same Largo Code to sell appears
			// more than once in the list, we will go to Meishar *only* for the first occurrence -
			// otherwise we might think Meishar is authorizing more units than it will actually allow.
			// (If later we need to have this transaction deal with non-prescription sales too, we'll
			// need to add another variable to the WHERE criteria to SELECT only appropriate gadgets
			// rows.)
			// DonR 19Aug2025 User Story #442308: If Nihul Tikrot calls are disabled, disable Meishar calls as well.
			if ((SPres[ListCounter].DL.in_gadget_table)		&&
				(!DrugAlreadyInList)						&&	// This is the first occurrence of this Largo Code in the list.
				(!Member.force_100_percent_ptn)				&&	// DonR 21Nov2021: This line was missing!
				(!SPres[ListCounter].LargoBlockedForMember)	&&	// DonR 21Nov2021 User Story #196891.
				(TikrotRPC_Enabled)							&&	// If Nihul Tikrot calls are disabled, disable Meishar calls too.
				(MEISHAR_PHARMACY))								// DonR 01Jul2012: New macro conditionally enables Prati Plus pharmacies.
			{
				// For this transaction (without a "Gadget Code" or other info supplied by the pharmacy),
				// all we can do is SELECT the first gadgets row we find for this Largo Code; this means
				// that in some cases we may get a negative response from Meishar when in fact we could
				// get a Meishar discount with a different Gadget Code.
				// DonR 28Feb2024 User Story #551403: Read three new columns from the gadgets table to
				// support conditional calls to Meishar based on purchase history.
				ExecSQL (	MAIN_DB, TR6103_READ_gadgets,
							&GadgetCodeFound,			&v_service_code,				&v_service_number,
							&v_service_type,			&enabled_without_rx,			&GadgetPrevPurchaseClassCode,
							&GadgetMinPrevPurchases,	&GadgetMaxPrevPurchases,
							&DL->largo_code,			&Phrm_info.maccabi_pharmacy,	&Member.MemberMaccabi,
							&Member.MemberHova,			&Member.MemberKeva,				END_OF_ARG_LIST					);

				Conflict_Test (reStart);

				if (SQLCODE == 0)
				{
					GoToMeishar = true;
				}
				else
				{
					GoToMeishar = false;

					// Don't log ordinary "not found" errors.
					if (SQLERR_code_cmp (SQLERR_not_found) != MAC_TRUE)
					{
						SQLERR_error_test ();
					}
				}

				// The Virtual Pharmacy will send the number of individual units the member wants, rather
				// than an even number of packages. For most "Meishar" items, Package Size = 1 so there's
				// no difference; but for those items that do have Package Size > 1, we need to leave the
				// leftover units out of the Meishar call. NOTE (A) that if the number of units requested
				// is less than a full package, we don't want to go to Meishar at all; and (B) when Meishar
				// comes back to us with an authorized quantity, we need to interpret it when Package Size
				// is greater than 1.
				FullPackages = (DL->package_size < 2) ? SPres[ListCounter].TotalUnitsToSell : SPres[ListCounter].TotalUnitsToSell / DL->package_size;

				if (FullPackages < 1)
					GoToMeishar = false;	// Suppress Meishar call when less than a full package is requested.

				if (GoToMeishar)	// I.e. we found an applicable gadgets row and everything else looks good to go.
				{
					// At least for now, we're not worrying about non-prescription sales - and in any case,
					// there's no provision in Transaction 6103 for the pharmacy to supply an OTC unit price.

					// DonR 14Nov2012: We no longer want to send the reduced "Maccabi" price to Meishar;
					// instead, we just send the ordinary unit price, with VAT deducted for Eilat pharmacies.
					// DonR 20Jan2014: For private pharmacies, send the price from Price List 2 (normally used
					// for Maccabi pharmacies) to Meishar as the default unit price.
					if (PRIVATE_PHARMACY)
					{
						ExecSQL (	MAIN_DB, READ_GetStandardMaccabiPharmPriceForMeishar,
									&MaccabiPharmYarpa_Price,	&DL->largo_code,	END_OF_ARG_LIST		);

						// No error trapping - just disable the price substitution.
						if (SQLCODE != 0)
							MaccabiPharmYarpa_Price = 0;
					}
					else
					{
						// For Maccabi pharmacies, we never want (or need) to do this substitution.
						MaccabiPharmYarpa_Price = 0;
					}

					// DonR 20Jan2014: Use Yarpa Price if we're at a private pharmacy and we read it
					// successfully from Price List 2; otherwise use the normal Yarpa Price.
					UnitPrice = (MaccabiPharmYarpa_Price > 0) ? MaccabiPharmYarpa_Price : SPres[ListCounter].YarpaPrice;

					// DonR 25Mar2012: For members buying stuff at VAT-exempt pharmacies (i.e. in Eilat),
					// take VAT off the unit price sent to AS/400. The AS/400 "meishar" application is
					// supposed to send a response that will reflect this reduction, and so we won't
					// have to deduct VAT later on.
					if (Phrm_info.vat_exempt != 0)
					{
						UnitPrice = (int)(((double)UnitPrice * no_vat_multiplier) + .5001);
					}

					// DonR 04Jul2021: Meishar and Nihul Tikrot both want a unique non-zero Prescription ID -
					// so if we need to contact either of those applications, grab a new ID and (later) create
					// a dummy row in the prescriptions table to ensure that the Prescription ID stays unique.
					if (v_RecipeIdentifier == 0)
					{
						err = GET_PRESCRIPTION_ID (&v_RecipeIdentifier);

						if (err != NO_ERROR)
						{
							// This is an error we should never see in real life - so don't bother with
							// real-life error trapping.
							SetErrorVar (&v_ErrorCode, err);
							v_RecipeIdentifier = 0;	// Re-initialize, just in case.
							GerrLogReturn (GerrId, "Can't get PRESCRIPTION_ID for 6103/Meishar - error %d.", state);
						}
					}

//					gettimeofday (&EventTime[EVENT_GADGET_START], 0);

					err = as400EligibilityTest (v_PharmNum,
												v_RecipeIdentifier,
												Member.member_id,
												Member.mem_id_extension,
												(int)v_service_code,
												(int)v_service_number,
												(int)v_service_type,
												DL->largo_code,
												FullPackages,		// Converted from total units requested.
												(int)UnitPrice,
												(int)2,				// Retries
												&MeisharInfoCode,	// DonR 23Dec2014. For now, should be either 0 or 88.
												&l_dummy,			// plIdNumber
												&i_dummy,			// pnIdCode
												&QuantityPermitted,
												&RequestNum,
												&PtnPrice,
												&Insurance);

//					gettimeofday (&EventTime[EVENT_GADGET_END], 0);

					GerrLogFnameMini ("gadgets_log",
									   GerrId,
									   "6103: AS400 err = %d.",
									   (int)err);
//GerrLogMini (GerrId, "6103: Meishar returned %d for PrID %d - TZ %d Largo %d, Ptn = %d, %d authorized.",
//			 err, v_RecipeIdentifier, Member.member_id, DL->largo_code, PtnPrice, QuantityPermitted);

					// For this transaction, we're going to ignore most Meishar errors - just stick
					// with the participation we got from other sources.
					if (err == enHasEligibility)
					{
						// To get the correct total member participation, start with what we previously calculated
						// (which may include "leftover" units that weren't part of the Meishar request, as well
						// as full OP beyond what Meishar authorized); then add the total participation authorized
						// by Meishar (which is for whatever quantity Meishar authorized); and subtract the "normal"
						// participation we calculated for the OPs that are now getting the Meishar discount.
						SPres[ListCounter].TotalMemberPtn += (		PtnPrice	// (for QuantityPermitted packages)
																-	(QuantityPermitted * SPres[ListCounter].MemberPtnPerPackage)	);

						// DonR 22Feb2022: To eliminate rounding errors, we're also remembering the participation amounts
						// as double-precision numbers, PtnPerPackage_f and MemberPtn_f. In the case of Meishar participation,
						// we need to update the float version of Total Member Participation as well.
						MemberPtn_f += (		(float)PtnPrice	// (for QuantityPermitted packages)
											-	((float)QuantityPermitted * PtnPerPackage_f)			);

						switch (Insurance)
						{
							case 1:
							case 2:
							case 3:
							case 7:		SPres[ListCounter].InsuranceUsed	= Insurance;		break;

							default:	SPres[ListCounter].InsuranceUsed	= BASIC_INS_USED;	break;
						}

						// Set parameters for later Nihul Tikrot call.
						SPres[ListCounter].SpecPrescNumSource	= 0;	// Since we're overriding the AS/400 ishur, if there was one.
						SPres[ListCounter].IshurTikraType		= 0;	// Since we're overriding the AS/400 ishur, if there was one.
						SPres[ListCounter].PriceCode			= 1;	// Treat the whole drug line as "fixed price", even if it's a "hybrid" of Meishar and non-Meishar.
						SPres[ListCounter].InHealthBasket		= 0;	// Meishar participation turns off other discounts.
					}	// Getting participation from Meishar.
				}	// GoToMeishar is TRUE - i.e. we found an applicable gadgets row for this Largo Code.
			}	// Meishar item, Meishar pharmacy, and this is the first time this item is found in the list.


			// Member discount percent calculation.
			//
			// Member discounts apply if:
			//
			// A) The drugs are being bought with a prescription. This is *always* true in 6103, so it's
			//    not part of the "if" here.
			//
			// B) The member is entitled to a discount: Either by having Member Rights 7 or 17
			//    (entitled to a 100% discount) or with an explicit discount level set by
			//    Member Discount Percent.
			//    DonR 04Dec2014: Member can also get an automatic 100% discount if s/he has
			//    a match between his/her serious-illness bitmap and the drug's illness bitmap.
			//    This is implemented with the new macro GETS_100PCT_DISCOUNT.
			//
			// C) Drug is in Health Pack (i.e. "The Basket") - this can be set from drug_list,
			//    drug_extension, spclty_largo_prcnt, or an AS400 ishur.
			//
			// D) The drug's Largo Type is appropriate for the type of discount being granted. For this, we now use
			//    Largo Type lists from Sysparams to qualify discounts instead of hard-coded values. For flexibility,
			//    there are separate lists for illness-based and non-illness-based discounts, as well as the new
			//    category of "ventilator" discounts. The comparision between a drug's Largo Type and these lists is
			//    performed in read_drug() and stored in DL.IllnessDiscounts/VentilatorDiscounts/NonIllnessDiscounts.
			if ( (MEMBER_GETS_DISCOUNTS)																			&&	// Condition (B).
				((SPres[ListCounter].InHealthBasket != 0)	|| (IGNORE_HEALTH_BASKET (SPres[ListCounter].DL)))		&&	// Condition (C).
				((SPres[ListCounter].DL.IllnessDiscounts)	|| (SPres[ListCounter].DL.VentilatorDiscounts) || (SPres[ListCounter].DL.NonIllnessDiscounts)) )	// Condition (D) - revised by CR #31591.
			{
				// DonR 13May2020 CR #31591: Add a new category of "ventilator" discounts. These are
				// given for members with their VentilatorDiscount flag set non-zero (currently comes
				// from members/asaf_code, which should be renamed when we migrate to MS-SQL), for
				// all items with Largo Type matching a list - currently "B", "Y", or "D".
				if (((Member.VentilatorDiscount) && (SPres[ListCounter].DL.VentilatorDiscounts))	||
					(GETS_100PCT_DISCOUNT_WITHOUT_DIAGNOSIS (SPres[ListCounter].DL)))
				{
					SPres[ListCounter].AdditionToPrice	= 10000;
				}
				else
				{
					if (GETS_100PCT_DISCOUNT_WITH_DIAGNOSIS (SPres[ListCounter].DL))
					{
						// If we get here, we need to see if one or more of the member's diagnoses
						// corresponds with a listed diagnosis for the drug being sold.
						MatchingDiagnosis = 0;

						ExecSQL (	MAIN_DB,
									READ_Find_member_diagnosis,
									Find_diagnosis_from_member_diagnoses,
									&MatchingDiagnosis,
									&SPres[ListCounter].DL.largo_code,	&Member.member_id,
									&Member.mem_id_extension,			END_OF_ARG_LIST		);

						// If we didn't get a positive count(*) and a valid SQL result code, check against
						// additional member diagnoses in the special_prescs table.
						if ((SQLCODE != 0) || (MatchingDiagnosis < 1))
						{
							ExecSQL (	MAIN_DB,
										READ_Find_member_diagnosis,
										Find_diagnosis_from_special_prescs,
										&MatchingDiagnosis,
										&SPres[ListCounter].DL.largo_code,		&Member.member_id,
										&SysDate,								&SysDate,
										&Member.mem_id_extension,				END_OF_ARG_LIST		);
						}

						if ((SQLCODE == 0) && (MatchingDiagnosis > 0))
						{
							SPres[ListCounter].AdditionToPrice	= 10000;
						}
					}	// 100% discount conditional on diagnosis-code match.
				}	// Did *not* grant a 100% discount based on non-diagnosis match. 

				if (SPres[ListCounter].AdditionToPrice != 10000)	// No 100% discount - does member have a discount percentage set?
				{
					if ((Member.mem_id_extension == 9) && (Member.darkonai_type == 2))
					{
						GET_MEMBER_PRICE_ROW (SPres[ListCounter].PriceCode, &PriceRow);
						
						// Marianna 24Mar2022 Epic 232192: Type 2 Darkonaim (Harel Foreign Workers) get a 100% discount
						// if the participation percentage is less or equal to a configurable value - currently 15%.
						if (PriceRow.member_price_prcnt <= DarkonaiMaxHishtatfutPct)
						{
							SPres[ListCounter].AdditionToPrice = 10000; // 100% discount
						} // Get 100% discount darkonai
					}

					// DonR 12Jan2004: Make sure we don't overwrite a big discount with a little one.
					// DonR 13May2020 CR #31591: For flexibility, make this discount conditional on
					// the drug's NonIllnessDiscounts flag, which is set by read_drug() based on whether
					// the drug's Largo Type matches the list set in sysparams/memb_disc_4_types.
					if ((SPres[ListCounter].DL.NonIllnessDiscounts) && (Member.discount_percent > SPres[ListCounter].AdditionToPrice))
						SPres[ListCounter].AdditionToPrice = Member.discount_percent;
				}	// No 100% discount granted, so we need to look at the member's Discount Percent (if it's non-zero).

			}	// Member may be entitled to a discount.


			// Compute the actual amount of any member discount granted, and reduce the net
			// participation by that amount. (Note that these numbers are in agorot.)
			// DonR 22Feb2022: Perform the discount computation using a double-precision
			// float variable in order to avoid rounding errors.
			PtnBeforeDiscount	= SPres[ListCounter].TotalMemberPtn;
			PtnWorkVar			= MemberPtn_f;

			if (SPres[ListCounter].AdditionToPrice > 0)
			{
				// Multiply PtnWorkVar by the net percentage (= 100% minus the member discount).
				PtnWorkVar *= (((double)10000 - (double)SPres[ListCounter].AdditionToPrice) / (double)10000);

				// Assign float value back to integer variable - adding a smidgin in case any precision
				// issue causes us to lose an agora.
				SPres[ListCounter].TotalMemberPtn = (int)(PtnWorkVar + 0.5001);

				// If there is a member discount, store it in SPres[ListCounter].DiscountApplied.
				SPres[ListCounter].DiscountApplied = PtnBeforeDiscount - SPres[ListCounter].TotalMemberPtn;
			}
			else
			{
				SPres[ListCounter].DiscountApplied = 0;
			}
// GerrLogMini (GerrId, "PtnBeforeDiscount = %d, AdditionToPrice = %d, Discounted Ptn = %d.",
//	PtnBeforeDiscount, SPres[ListCounter].AdditionToPrice, SPres[ListCounter].TotalMemberPtn);

			// DonR 28Oct2021 User Story #202451: Because Nihul Tikrot can handle only one occurrence of a given
			// Largo Code per transaction, we need to consolidate the Member Participation amount for each unique
			// Largo Code in the request. We're assuming that all instances of the same Largo Code will get the
			// same per-OP member participation - which should be true in almost all cases. The only exception
			// should be where a prescription from Doctor X gets a specialist discount while a prescription from
			// Doctor Y does not - but this really shouldn't happen in real life. (Remember that
			// SPres[ListCounter].FirstOccurrenceOfLargoSubscript == ListCounter for the first occurrence of each
			// Largo Code in the list!)
			// DonR 09Jan2022: We are now calculating member discounts - so the number that's passed to Nihul
			// Tikrot is net of any such discounts, just as it is in Transaction 6003.
			SPres[SPres[ListCounter].FirstOccurrenceOfLargoSubscript].AggregatePtnForThisLargo += SPres[ListCounter].TotalMemberPtn;

		}	// Loop to process the list of prescriptions the "virtual pharmacy" sent.


		// If necessary, call the AS/400 "Nihul Tikrot" application to get Tikrot/Coupon/Subsidy information.
		NumTikrotLines	= NumSaleLines		= NumCouponLines		= FamilySalePrID_count	= 0;
		TikrotStatus	= TikrotRPC_Called	= TikrotRPC_Error		= 0;
		*TikrotHeader	= *TikrotPriorSales	= *TikrotCurrentSale	= (char)0;

//		gettimeofday (&EventTime[EVENT_START_TO_TIK], 0);

		// Contact AS/400 "Nihul Tikrot" application if:
		// (A) There hasn't been a fatal error for this sale/deletion.
		// (B) There is at least one (presumably valid) drug line.
		// (C) This is not a sale to an IDF soldier. (DonR 07Dec2011, "Tzahal" enhancement)
		// (D) Sale meets relevancy conditions.
		// (E) The global "Nihul Tikrot Enabled" flag is set TRUE - this is tested separately,
		//     since we write to log if it's FALSE.
		// DonR 12Feb2025 User Story #376480: Added CheckMonthlyPiryonTikra to the list of
		// relevancy conditions in section D.
		if	(	(!SetErrorVar (&v_ErrorCode, 0))		&&			// (A)
				(NumProcessed			>  0)			&&			// (B)
				(Member.MemberTzahal	== 0)			&&			// (C)

				(	Member.has_tikra		||
					Member.has_coupon		||
					MemberBuyingTikMazon	||
					CheckMonthlyPiryonTikra	||	//DonR 12Feb2025 User Story #376480
					AnIshurHasTikra
				)													// (D)
			)
		{
			if (TikrotRPC_Enabled)																		// (E)
			{
				TikrotRPC_Called = 1;

				// DonR 04Jul2021: Meishar and Nihul Tikrot both want a unique non-zero Prescription ID -
				// so if we need to contact either of those applications, grab a new ID and (later) create
				// a dummy row in the prescriptions table to ensure that the Prescription ID stays unique.
				if (v_RecipeIdentifier == 0)
				{
					err = GET_PRESCRIPTION_ID (&v_RecipeIdentifier);

					if (err != NO_ERROR)
					{
						// This is an error we should never see in real life - so don't bother with
						// real-life error trapping.
						SetErrorVar (&v_ErrorCode, err);
						v_RecipeIdentifier = 0;	// Re-initialize, just in case.
						GerrLogReturn (GerrId, "Can't get PRESCRIPTION_ID for 6103/Meishar - error %d.", state);
					}
				}

				// Build list of up to 25 recent sales (in the last two days) to family.
				WritePtr	= TikrotPriorSales;
				Yesterday	= IncrementDate (SysDate, -1);

//				gettimeofday (&EventTime[EVENT_FAM_SALES_START], 0);

				// Select cursor for recent family sales (used for "Nihul Tikrot" RPC call).
				// DonR 10Apr2011: Declare cursor only if it's needed.
				// DonR 09Jan2012: If the member's head-of-family Teudat Zehut number is
				// zero, skip the family-prescriptions check.
				if (Member.idnumber_main > 0)
				{
					DeclareAndOpenCursorInto (	MAIN_DB, READ_FamilySales_cur,
												&FamilySalePrID,
												&Member.idnumber_main,	&Member.idcode_main,
												&Yesterday,				&SysDate,
												END_OF_ARG_LIST									);

					if (!SQLERR_error_test ())
					{
						// Fetch data and store in buffer.
						// For now at least, no real error checking; just quit when we hit anything.
						// We're already in "dirty read" mode, so we should be more or less OK.
						for ( ; ; )
						{
							FetchCursor (	MAIN_DB, READ_FamilySales_cur	);

							if (SQLCODE == 0)
							{
								WritePtr += sprintf (WritePtr, "%0*d", 9,	FamilySalePrID);
								if (++FamilySalePrID_count >= MAX_TIKRA_PREV_SALES)
									break;	// Buffer capacity reached.
							}
							else
							{
								break;
							}
						}
					}

					CloseCursor (	MAIN_DB, READ_FamilySales_cur	);
				}	// Non-zero head-of-family T.Z. number.

//				gettimeofday (&EventTime[EVENT_FAM_SALES_END], 0);
				// Done with recent-sales list-building.

				// Build request header.
				WritePtr = TikrotHeader;
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	v_RecipeIdentifier					);
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	0									);	// v_DeletedPrID
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	Member.member_id					);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	Member.mem_id_extension				);
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	action_type							);	// Always 1 for Trn. 6103.
				WritePtr += sprintf (WritePtr, "%0*d" ,	  8,	0									);	// v_DeletedPrDate
				WritePtr += sprintf (WritePtr, "%0*d" ,	  9,	Member.idnumber_main				);	// Family head TZ.
				WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	Member.idcode_main					);	// Family head TZ Code.
				WritePtr += sprintf (WritePtr, "%c"    ,		ONE_OR_BLANK (Member.has_coupon)	);
				WritePtr += sprintf (WritePtr, "%+0*d" , 10,	0									);	// v_DeletedPrSubAmt
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	(NumProcessed - NumDuplicates)		);	// Assuming all items on pharmacy list are valid.
				WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	FamilySalePrID_count				);


				// Build list of drugs (up to 50) in the current request.
				// 34 characters per Drug Line.
				// DonR 28Oct2021 User Story #202451: Because Nihul Tikrot can handle only one occurrence of a given
				// Largo Code, we consolidate the member participation into a new variable and send only the first
				// occurrence (with aggregate member participation) of each Largo Code.
				WritePtr = TikrotCurrentSale;
				for (i = v_NumDrugLinesSent = 0; (i < NumProcessed) && (v_NumDrugLinesSent < MAX_TIKRA_CURR_SALE); i++)
				{
					// DonR 28Oct2021 User Story #202451: Send only the first occurrence of each Largo Code.
					if (SPres[i].FirstOccurrenceOfLargoSubscript != i)
						continue;

					// DonR 11May2025 User Story #394813: For Harel darkonaim with shovarim, if the drug
					// is flagged as being in the Health Basket in drug_list, send that value even though
					// participation is 100%; this way Nihul Tikrot will know to apply shovarim. Note that
					// here we test for PriceCode and ReducedPrice individually; we don't have to worry
					// about Meishar participation, since Meishar is disabled when Member.force_100_percent_ptn
					// is TRUE.
					// DonR 22May2025 User Story #394813: We need to use the new "unprocessed" copy of the
					// in-health-basket flag here.
					short health_basket_send = SPres[i].InHealthBasket;

					if	(	(	Member.mem_id_extension						== DARKONAI	)		&&
							(	Member.darkonai_type						== 1		)		&&	// Harel insurance with 100% hishtatfut.
							(	Member.has_coupon										)		&&
							(	Member.force_100_percent_ptn							)		&&	// This *should* force the next 3 conditions TRUE!
							(	SPres[i].PriceCode							<  2		)		&&	// == 100% hishtatfut.
							(	SPres[i].ReducedPrice						== 0		)		&&	// == 100% hishtatfut with no fixed-price reduction.
							(	SPres[i].DL.health_basket_new_unprocessed	>  0		)	)
					{
						health_basket_send	= SPres[i].DL.health_basket_new_unprocessed;	// Should be either 4 or 5.
						SPres[i].PriceCode	= 11;											// == "Maccabi 100%"
					}
  
					DL = &SPres[i].DL;

					// DonR 30Jul2024 User Story #338533: Largo Code Length is now a Sysparams variable.
					// DonR 12Feb2025 User Story #376480: Send "1" or "2" for Tikrat Mazon flag, not
					// just "1". Also, send the value from the new structure element "TikratMazonFlagSend"
					// rather than from the drug_list value; if the requesting pharmacy is not qualified
					// for fertility tikrot, we want to send a space instead of "2".
					WritePtr += sprintf (WritePtr, "%0*d"  ,  NihulTikrotLargoLen,	DL->largo_code					);
					WritePtr += sprintf (WritePtr, "%c "   ,		DL->largo_type									);
					WritePtr += sprintf (WritePtr, "%c"    ,		ONE_TWO_BLANK (SPres[i].TikratMazonFlagSend)	);
					WritePtr += sprintf (WritePtr, "%0*d"  ,  5,	DL->parent_group_code							);

					// DonR 08Mar2017 CR #11036: Send Ishur Source even if the ishur didn't involve Tikra.
					WritePtr += sprintf (WritePtr, "%c",			DIGIT_OR_BLANK (SPres[i].SpecPrescNumSource)	);
					WritePtr += sprintf (WritePtr, "%0*d"  ,  3,	SPres[i].IshurTikraType							);
					WritePtr += sprintf (WritePtr, "%+0*d" , 10,	SPres[i].AggregatePtnForThisLargo				);	// DonR 28Oct2021 User Story #202451: Send aggregate ptn per Largo Code.
					WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	SPres[i].PriceCode								);
					WritePtr += sprintf (WritePtr, "%s"    ,		(SPres[i].LargoBlockedForMember) ? "1" : " "	);	// DonR 18Nov2021 User Story #196891 plus 15Dec2021 HOT FIX.
//					WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	SPres[i].InHealthBasket							);
					WritePtr += sprintf (WritePtr, "%0*d"  ,  1,	health_basket_send								);	// DonR 11May2025 User Story #394813
					WritePtr += sprintf (WritePtr, "%0*d"  ,  2,	SPres[i].InsuranceUsed							);
					WritePtr += sprintf (WritePtr, " "				/* Deletion Tikra Flag - NIU */					);

					v_NumDrugLinesSent++;
				}
// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003 set up %d current sales - calling stored procedure.", v_NumDrugLinesSent);


				// Finally (well, not quite finally), call the RPC to invoke the AS/400 "Tikrot" program.
				TikrotRPC_Error = CallTikrotSP (TikrotHeader,	TikrotCurrentSale,	TikrotPriorSales,
												&HeaderRtn,		&TikrotRtn,			&CurrentSaleRtn,	&CouponsRtn);

// if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6103 called Nihul Tikrot with\n{%s}\n - TikrotRPC_Error = %d.", TikrotCurrentSale, TikrotRPC_Error);
				// DonR 03Aug2010: If the Tikrot RPC call failed, change "Tikrot Called" from 1 to 2.
				if (TikrotRPC_Error != 0)
				{
					TikrotRPC_Called = 2;
				}

				// Pull values from output header.
				PosInBuff = HeaderRtn + 9;	// Ignore Prescription ID - we know it already!

				TikrotStatus = GetShort (&PosInBuff, 4);
if ((!TikrotProductionMode) && (!((TikrotStatus == 1) || (TikrotStatus == 2)))) GerrLogMini (GerrId, "Trn 6103: TikrotStatus = %d.", TikrotStatus);

				// DonR 06Jun2010: Orly Spiegel changed the status returned. Now 1 means that everything's
				// OK but no reductions in price were granted; 2 means that reductions in price were
				// granted; and any other value means that something went wrong.
				if ((TikrotStatus == 1) || (TikrotStatus == 2))
				{
					NumTikrotLines	= GetShort (&PosInBuff, 2);
					NumSaleLines	= GetShort (&PosInBuff, 2);
					NumCouponLines	= GetShort (&PosInBuff, 2);
//if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6103: TikrotStatus = %d; %d Tikrot Lines, %d Sale Lines, %d Coupon Lines.",
//										TikrotStatus, NumTikrotLines, NumSaleLines, NumCouponLines);
				}
				else
				{
					NumTikrotLines = NumSaleLines = NumCouponLines = 0;

					// DonR 25Jun2020: In order to diagnose an intermittent problem in communicating with
					// the "ODBC listener" program on AS/400, dump HeaderRtn to log if TikrotStatus has
					// an unrecognized value.
					if (TikrotRPC_Error != -1)	// Don't bother logging HeaderRtn for comms errors.
					{
						// DonR 07Jul2020: Ignore known, common Nihul Tikrot error codes - we want
						// to log only the weird stuff.
						switch (TikrotStatus)
						{
							case  51:
							case  52:
							case  53:
							case 101:
							case 102:
							case 103:	break;

							default:	GerrLogMini (GerrId, "PID %d/6103: Got HeaderRtn {%s}, TikrotRPC_Error = %d.",
													 (int)getpid(), HeaderRtn, TikrotRPC_Error);
										break;
						}
					}	// Strange, uncommon Nihul Tikrot Status code returned, without a communications error.
				}	// TikrotStatus isn't 1 or 2.
//if (!TikrotProductionMode) GerrLogMini (GerrId, "Trn 6003: After CallTikrotSP, NumTikrotLines = %d, NumSaleLines = %d, NumCouponLines = %d.", NumTikrotLines, NumSaleLines, NumCouponLines);

				// Decode Tikrot Lines output.
				// 59 characters/line.
				PosInBuff = TikrotRtn;
				for (i = 0; i < NumTikrotLines; i++)
				{
					TikraType			[i] = GetChar	(&PosInBuff);
					TikraBasket			[i] = GetShort	(&PosInBuff,  1);
					TikraInsurance		[i] = GetShort	(&PosInBuff,  2);
					TikraAggPrevPtn		[i] = GetInt	(&PosInBuff, 10);
					TikraAggPrevWaived	[i] = GetInt	(&PosInBuff, 10);
					TikraCurrPtn		[i] = GetInt	(&PosInBuff, 10);
					TikraCurrWaived		[i] = GetInt	(&PosInBuff, 10);
					TikraCurrLevel		[i] = GetInt	(&PosInBuff,  9);
					GetString (&PosInBuff, TikraPeriodDesc [i],  6);

//					// DonR 18Oct2010: Convert AS/400 Windows (1255) Hebrew to DOS (862) Hebrew - and
//					// then reverse it, since AS/400 has strange ways of dealing with Hebrew.
					// DonR 17Jul2023: AS/400 gives us the Tikra Period Description reversed from all
					// the other Hebrew we get from the database - so reverse it to match. (Note that
					// this is not a new functional change - I'm just commenting it more clearly, and
					// changing the function name from buf_convert() to buf_reverse() for clarity.)
					buf_reverse ((unsigned char *)TikraPeriodDesc [i], 6);

					// DonR 09Aug2016: Keep track of total Tikra discount sent to pharmacy.
					tikra_discount += TikraCurrWaived [i];
				}

				// Decode Current Sale Lines output.
				// 17 characters/line.
				PosInBuff = CurrentSaleRtn;
				for (i = 0; i < NumSaleLines; i++)
				{
					// DonR 30Jul2024 User Story #338533: Largo Code Length is now a Sysparams variable.
					PosInBuff += NihulTikrotLargoLen;	// Ignore Largo Code - array order will be unchanged!
					DrugTikraType		[i] = GetChar	(&PosInBuff);
					DrugCoupon			[i] = GetChar	(&PosInBuff);
					DrugRefundOffset	[i] = GetInt	(&PosInBuff, 10);
				}

				// Decode Coupon Lines output.
				PosInBuff = CouponsRtn;
				for (i = 0; i < NumCouponLines; i++)
				{
					TikraCouponCode		[i] = GetShort	(&PosInBuff,  3);
					TikraCouponAmt		[i] = GetInt	(&PosInBuff, 10);

					// DonR 09Aug2016: Keep track of total subsidy amount sent to pharmacy.
					subsidy_amount += TikraCouponAmt [i];
				}
			}	// "Nihul Tikrot" calls are enabled.
			else
			{
				GerrLogMini (GerrId, "Trn. 6103: AS/400 not contacted - \"Nihul Tikrot\" calls are disabled!");
			}
		}	// Need to call AS/400 "Tikrot" program via ODBC RPC.


		// If we needed to use a new Prescription ID for Meishar and/or Nihul Tikrot, write a
		// minimally-populated, non-delivered row to the prescriptions table - mostly to ensure
		// that the Prescription ID remains unique, but also to record a few values in case we
		// need to check anything afterwards.
		// Note that other than logging an error message, no real error-handling is needed here.
		if (v_RecipeIdentifier > 0)
		{
			ExecSQL (	MAIN_DB, INS_prescriptions_placeholder_row,
						&v_RecipeIdentifier,		&action_type,			&Member.member_id,
						&Member.mem_id_extension,	&MemberBelongCode,		&Member.maccabi_code,
						&v_PharmNum,				&v_InstituteCode,		&terminal_id,
						&SysDate,					&SysTime,				&NumProcessed,
						&TikrotRPC_Called,			&TikrotRPC_Error,		&TikrotStatus,
						&tikra_discount,			&subsidy_amount,		&origin_code,
						&v_ErrorCode,				END_OF_ARG_LIST									);

			// Log any errors, but don't do anything else - this INSERT isn't all that crucial.
			if (SQLCODE != 0)
			{
				// DonR 11Dec2023: If we get an "ordinary" DB contention error here, write a less-alarming
				// message to the log; this will prevent the XPLG Monitor system from reporting it as a
				// critical error and sending everyone emails about it.
				if (SQLERR_code_cmp (SQLERR_access_conflict) == MAC_TRUE)
				{
					GerrLogMini (	GerrId,
									"SQL operation INS_prescriptions_placeholder_row returned access-conflict "
									"SQLCODE %d - ignoring it and proceeding.",
									SQLCODE	);
				}
				else
				{
					SQLERR_error_test ();
				}
			}
//			else
//			{
//				GerrLogMini (GerrId, "6103 successfully added PrID %d.", v_RecipeIdentifier);
//			}
		}


		// Create output JSON objects.
		//
		// First, clear any existing data (in case we're retrying).
		if (JSON_OutputObject != NULL)
			cJSON_Delete (JSON_OutputObject);	// This should delete all "child" objects.

		// Now (re-)create the objects.
		JSON_OutputObject = cJSON_CreateObject ();

		if (JSON_OutputObject == NULL)
		{
			GerrLogMini (GerrId, "Couldn't create JSON_OutputObject!");
			// We should obviously do something more than log an error here -
			// but I'm not yet sure just what. In any case, creating the object
			// should never fail in real life - I hope!
		}

		// For the moment (at least), don't bother error-trapping the creation
		// of the subsidiary JSON objects.
		JSON_OutputHeader		= cJSON_AddObjectToObject	(JSON_OutputObject,	"header");

		// Populate Response Header object.
		if (SetErrorVar (&v_ErrorCode, v_ErrorCode))
		{
			// We hit a severe error.
			cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "E"			);
			cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "mac_error_code",		v_ErrorCode	);

			// If we've already set mac_status_code to something, keep that value; otherwise set it now.
			// If something in the incoming request was missing or incorrect, report a -98 status;
			// otherwise report a "generic" -99 error.
			if (v_ErrorCode == ERR_WRONG_FORMAT_FILE)
			{
				mac_status_code = -98;
				HTTP_response_status = 400;	// "Error on request" occurred.
			}
			else
			{
				mac_status_code = -99;
				HTTP_response_status = 500;	// Any miscellaneous fatal error occurred.
			}
		}
		else
		{
			// No severe error.
			HTTP_response_status = 200;	// Already defaulted, but paranoia is our friend!

			cJSON_AddStringToObject		(JSON_OutputHeader, "mac_status_severity", "S"	);
			mac_status_code = 0;
		}

		if (mac_status_code)
		{
			cJSON_AddAnyNumberToObject (JSON_OutputHeader, "mac_status_code",		mac_status_code);

			switch (mac_status_code)
			{
				case 0:		cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "Success"			);	break;
//				case -97:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "NoTechId"			);	break;
				case -98:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "RequestError"		);	break;
				case -99:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "InternalError"		);	break;
				default:	cJSON_AddStringToObject (JSON_OutputHeader, "mac_notification", "UnknownError"		);	break;
			}
		}

		cJSON_AddAnyNumberToObject (JSON_OutputHeader, "HTTP_response_status",	HTTP_response_status);
//		cJSON_AddAnyNumberToObject	(JSON_OutputHeader, "TEST_MISPAR_MIZAHEH",	v_RecipeIdentifier	);

		// For the moment (at least), don't bother error-trapping the creation
		// of the subsidiary JSON objects.
		JSON_OutputData			= cJSON_AddObjectToObject	(JSON_OutputObject,	"_data");

		// Write Nihul Tikrot / Voucher discounts to _data object. Note that Nihul Tikrot (like pretty
		// much all Linux Pharmacy stuff) works in agorot - but Chanut Virtualit wants output in the
		// form of shekels, so we have to divide by 100.
		cJSON_AddAnyNumberToObject (JSON_OutputData, "maxfee_total_discount",	((double)tikra_discount	/ (double)100)	);
		cJSON_AddAnyNumberToObject (JSON_OutputData, "vouchers_total_discount",	((double)subsidy_amount	/ (double)100)	);

		// Write drug lines to items_list array.
		JSON_OutputItemsArray	= cJSON_AddArrayToObject	(JSON_OutputData,	"items_list");
		for (ListCounter = 0; ListCounter < NumProcessed; ListCounter++)
		{
			DL = &SPres[ListCounter].DL;
			Rx = &SPres[ListCounter].Rx;

			JSON_OutputItem = cJSON_AddNewObjectToArray (JSON_OutputItemsArray);

			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "orig_largo",				Rx->largo_prescribed										);
			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "dispense_largo",			DL->largo_code												);
			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "prescription_id",		Rx->doctor_presc_id											);
//			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "member_discount_pct",	((double)SPres[ListCounter].AdditionToPrice	/ (double)100)	);	// Just for testing.
//			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "member_discount_amt",	((double)SPres[ListCounter].DiscountApplied	/ (double)100)	);	// Just for testing.
			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "participation_amount",	((double)SPres[ListCounter].TotalMemberPtn	/ (double)100)	);
//			cJSON_AddAnyNumberToObject	(JSON_OutputItem, "HEALTH_BASKET",			SPres[ListCounter].InHealthBasket	);
		}


		// Retry if we hit a DB problem.
		if (reStart != MAC_FALS)	// DB errors - do a retry.
		{
			// DonR 26Jul2011: Suppress log message until the fourth attempt fails.
			if (tries > 2)
				GerrLogReturn (GerrId, "Trn. 6103: Table is locked for the <%d> time", tries);
			
			sleep (ACCESS_CONFLICT_SLEEP_TIME);
		}	// DB error occurred.

	}	// End of Database Retries loop.
	
	
	// See if we've exceeded the maximum retry count.
	if (reStart == MAC_TRUE)
	{
		GerrLogReturn (GerrId, "Trn. 6103: Locked for <%d> times", SQL_UPDATE_RETRIES);
		SetErrorVar (&v_ErrorCode, ERR_DATABASE_ERROR);
	}


	// Send the output JSON hierarchy to file and delete it from memory.
	cJSON_PrintPreallocated (JSON_OutputObject, OBuffer, 65535, 1);
// GerrLogMini (GerrId, "Trn 6103 output:\n%s\n    ", OBuffer);
	cJSON_Delete (JSON_OutputObject);

	// Return the size in Bytes of response message.
	*p_outputWritten			= strlen (OBuffer);
	*output_type_flg			= ANSWER_IN_BUFFER;


	// DonR 27Jun2018: Up to now, we weren't saving the error code for this transaction. Now we are!
	ssmd_data_ptr->error_code	= v_ErrorCode;

	// DonR 23Nov2017: Store numberbar of prescription rows read from DB in audit variable;
	// leave "extra" largos out of the picture.
	if (NumProcessed_out != NULL)
		*NumProcessed_out = NumProcessed;

	RESTORE_ISOLATION;

	return  RC_SUCCESS;
}	// End of 6103 handler.


short rx_source_found (TPresDrugs *DrugLine, short DrugCount, short SourceTest, short SecondSourceTest, short Mode)
{
	int		i;
	short	retn;

	// Modes for testing:
	// 1: Test for at least one occurrence of SourceTest in the sale request.
	// 2: Test for at least one occurrence of something *other* than SourceTest in the sale request.
	//
	// DonR 09Oct2016: Added new second source test. If this has a real value, we will test for
	// either of two prescription sources rather than for only one.
	switch (Mode)
	{
	case 1:
				for (i = retn = 0; i < DrugCount; i++, DrugLine++)
				{
					if (retn = ((DrugLine->PrescSource == SourceTest) || (DrugLine->PrescSource == SecondSourceTest)))
						break;
				}
				break;

	case 2:
				for (i = retn = 0; i < DrugCount; i++, DrugLine++)
				{
//					if (retn = (((SecondSourceTest >= 0) && (DrugLine->PrescSource != SourceTest) && (DrugLine->PrescSource != SecondSourceTest))	||
//								((SecondSourceTest <  0) && (DrugLine->PrescSource != SourceTest))))
					if (retn = ((DrugLine->PrescSource != SourceTest)	&&
								((SecondSourceTest < 0) || ((SecondSourceTest >= 0) && (DrugLine->PrescSource != SecondSourceTest)))))
						break;
				}
				break;

	default:	retn = 0;
				break;
	}

	return (retn);
}

/*				   -- EOF --				     */
