/*============================================================================
||																			||
||				MacODBC.h													||
||																			||
||==========================================================================||
||																			||
||  PURPOSE:																||
||																			||
||  Header file for Maccabi ODBC "infrastructure" functions.				||
||																			||
||--------------------------------------------------------------------------||
|| PROJECT:	ODBC database conversion										||
||--------------------------------------------------------------------------||
|| PROGRAMMER:	Don Radlauer.												||
|| DATE:		December 2019.												||
||--------------------------------------------------------------------------||
||																			||
|| This file should be in the standard include directory.					||
||																			||
 ===========================================================================*/


#pragma once

// Having both "#pragma once" and "ifndef" should be redundant, but harmless.
#ifndef MacODBC_H
#define MacODBC_H


// ODBC includes.
#include "/usr/local/include/sql.h"
#include "/usr/local/include/sqlext.h"
#include <errno.h>
#include <locale.h>
#include <string.h>
#include <setjmp.h>

#include "GenSql.h"		//Marianna 26052020

extern int	caught_signal;

// DonR 23Feb2020: "Missing" #defines for setting preserve-cursor behavior for MS-SQL.
#define SQL_COPT_SS_PRESERVE_CURSORS 1204
#define SQL_PC_ON 1L
#define SQL_PC_OFF 0L

#if 0				//Marianna		26052020

// This shouldn't be necessary for code that already uses embedded SQL;
// but once that's eliminated and we want to get rid of the associated
// include files, we'll need these declarations.
#ifndef sqlca
#ifndef SQLCA_INCL
typedef struct sqlca_s
{
	int		sqlcode;
	char	sqlerrm		[601]; // error message parameters
	char	sqlerrp		[8];
	int		sqlerrd		[6];
	// 0 - estimated number of rows returned
	// 1 - serial value after insert or  ISAM error code
	// 2 - number of rows processed
	// 3 - estimated cost
	// 4 - offset of the error into the SQL statement
	// 5 - rowid after insert
	char	sqlawarn	[8];
//	char sqlwarn0; /* = W if any of sqlwarn[1-7] = W */
//	char sqlwarn1; /* = W if any truncation occurred or
//				database has transactions or
//			        no privileges revoked */
//	char sqlwarn2; /* = W if a null value returned or
//				ANSI database */
//	char sqlwarn3; /* = W if no. in select list != no. in into list or
//				turbo backend or no privileges granted */
//	char sqlwarn4; /* = W if no where clause on prepared update, delete or
//				incompatible float format */
//	char sqlwarn5; /* = W if non-ANSI statement */
//	char sqlwarn6; /* = W if server is in data replication secondary mode */
//	char sqlwarn7; /* = W if database locale is different from proc_locale
//                         = W if backend XPS and if explain avoid_execute is set
//                             (for select, insert, delete and update only)
//			*/
}	sqlca_t;

// Global database "communications area" structure.
sqlca_t	sqlca;
int		SQLCODE;
#endif
#endif

#endif			//Marianna		26052020

#define ODBC_MAX_STICKY_STATEMENTS	100


// "Custom" includes for each program's collection of SQL commands.
#include <MacODBC_MyOperatorIDs.h>

enum ODBC_DatabaseProvider
{
	ODBC_NoProvider,	// Just so the first real provider is non-zero.
	ODBC_Informix,
	ODBC_DB2,
	ODBC_MS_SqlServer,
	ODBC_Oracle
};

// Define macros for various types of SQL commands.
enum ODBC_CommandType
{
	DECLARE_CURSOR,
	DECLARE_CURSOR_INTO,
	DEFERRED_INPUT_CURSOR,
	DEFERRED_INPUT_CURSOR_INTO,
	OPEN_CURSOR,
	OPEN_CURSOR_USING,
	FETCH_CURSOR,
	FETCH_CURSOR_INTO,
	CLOSE_CURSOR,
	FREE_STATEMENT,
	SINGLETON_SQL_CALL,
	COMMIT_WORK,
	ROLLBACK_WORK,
	GET_LENGTHS_READ,
	SET_DIRTY_READ,
	SET_COMMITTED_READ,
	SET_REPEATABLE_READ
};

enum ODBC_ErrorCategory
{
	ODBC_ENVIRONMENT_ERR,
	ODBC_DB_HANDLE_ERR,
	ODBC_STATEMENT_ERR
};

// DonR 22Jan2020: For some reason, something was getting screwed up when we
// needed a retry for the ODBC connect to Informix. Moving the HDBC part of
// the ODBC_DB_HEADER structure to the end seemed to help. Just in case some
// ODBC driver function is overflowing the bounds of HDBC, I've added an
// overflow buffer - it really shouldn't be needed, and I should play with
// this stuff later to make sure I've got a proper fix!
typedef struct ODBC_DB_HEADER		{int Provider; int Connected; SQLHDBC HDBC; char HDBC_OverflowBuffer[1000];}	ODBC_DB_HEADER;
typedef struct ODBC_ColumnParams	{int type; int length;}							ODBC_ColumnParams;

// The ODBC environment is used only at connect-time and exit-time.
#ifdef MAIN
	static SQLHENV		ODBC_henv;
	ODBC_DB_HEADER		MS_DB;
	ODBC_DB_HEADER		INF_DB;
	int					NUM_ODBC_DBS_CONNECTED		= 0;
	int					ODBC_SQLCODE				= 0;	// So error routines can see if SQLCODE came from ODBC.
	short				ODBC_PRESERVE_CURSORS		= 0;	// Set TRUE *BEFORE* connecting to database if we want cursors to behave as if they were declared
															// "WITH HOLD" - otherwise, by default ODBC closes all cursors when there is a COMMIT.
	char				ODBC_ErrorBuffer		[5000];

	short				ODBC_AvoidRecursion			= 0;	// So logging routines know not to call ODBC functions if they're called *from* an ODBC function.

	short				ODBC_ValidatingPointers		= 0;	// Global indicator that we're validating pointers sent to ODBC routine; this lets us know
															// that if we hit a segmentation fault, that's the reason why - and we'll handle the error
															// gracefully.
	short				ODBC_PointerIsValid;				// Global indicator for pointer validity; it will be set TRUE before read/write checking a
															// column/parameter pointer, and will be set FALSE by the segmentation-fault trapping routine.
	short				Connect_ODBC_Only			= 0;	// Global indicator so a given mainline can suppress all calls to embedded SQL.

	struct sigaction	sig_act_ODBC_SegFault;
	sigjmp_buf			BeforePointerTest;



	// Useful little global variables so we can do INSERT's without
	// hard-coded VALUES.
	int				IntZero						= 0;
	int				IntOne						= 1;
	int				IntTwo						= 2;
	short			ShortZero					= 0;
	short			ShortOne					= 1;
	short			ShortTwo					= 2;
	long			LongZero					= 0L;

	SQLLEN			*ColumnOutputLengths;
	char			*ODBC_LastSQLStatementText	= NULL;
	char			*END_OF_ARG_LIST			= "End of argument list!";

	// DonR 24May2020: Moved some static status variables from function scope to module scope,
	// since sometimes it seems like function-scope static variables are less static than one
	// would want them to be.
	static int			ODBC_Exec_FirstTimeCalled	= 1;
	static int			NumStickyHandlesUsed		= 0;

#else	// External declarations for other source modules.
	extern ODBC_DB_HEADER	MS_DB;
	extern ODBC_DB_HEADER	INF_DB;
	extern int				NUM_ODBC_DBS_CONNECTED;
	extern int				ODBC_SQLCODE;			// So error routines can see if SQLCODE came from ODBC.
	extern short			ODBC_PRESERVE_CURSORS;	// Set TRUE *BEFORE* connecting to database if we want cursors to behave as if they were declared "WITH HOLD".
	extern char				ODBC_ErrorBuffer [];
	extern int				IntZero;
	extern int				IntOne;
	extern int				IntTwo;
	extern short			ShortZero;
	extern short			ShortOne;
	extern short			ShortTwo;
	extern long				LongZero;
	extern SQLLEN			*ColumnOutputLengths;
	extern char				*ODBC_LastSQLStatementText;
	extern char				*END_OF_ARG_LIST;
	extern short			ODBC_AvoidRecursion;
	extern short			ODBC_ValidatingPointers;
	extern short			ODBC_PointerIsValid;
	extern short			Connect_ODBC_Only;
	extern struct sigaction	sig_act_ODBC_SegFault;
	extern sigjmp_buf		BeforePointerTest;
#endif


#define SQL_WORKED(R)	((R == SQL_SUCCESS) || (R == SQL_SUCCESS_WITH_INFO))
#define SQL_FAILED(R)	((R != SQL_SUCCESS) && (R != SQL_SUCCESS_WITH_INFO))


// OpenCursor, CloseCursor, and FetchCursor don't need any variable arguments; in GNU C,
// the ## token eliminates the preceding comma in macro expansion and thus avoids having
// to decide between compiler errors and adding a meaningless NULL parameter at the end
// of each macro call. Note that I tried using __VA_OPT__ instead, but the compiler
// didn't seem to like it. (I added this token to ExecSQL as well, for statements like
// CREATE TABLE that have neither input nor output columns.)
// NOTE: I gave two different spellings of the singleton command: ExecSQL and ExecSql. It
// seemed easier to have both recognized than to stop myself from typing it the wrong way!
// ...And I did the same for the Rollback commands - they'll work for Rollback... and RollBack.
//
// The order of arguments to the macros is as follows:
// 1) Pointer to the database header structure (type ODBC_DB_HEADER).
// 2) The SQL Operation ID (defined as enum in each program's local copy of MacODBC_MyOperatorIDs.h).
// (Everything from here on is part of the variable-arguments list - always supplied as pointers.)
// 3) IF the SQL Operation is defined in the local copy of MacODBC_MyOperators.c as NULL,
//    the address of the SQL command text to PREPARE (for Declare and ExecSQL commands).
// 4) IF the SQL Operation requires a custom WHERE clause, the WHERE clause identifier.
//    (This is relevant only for Declare and ExecSQL commands.)
// 5) IF there is a custom WHERE clause and its WhereClauseText is defined as NULL,
//    the address of the WHERE clause text to PREPARE (for Declare and ExecSQL commands).
// 6) Output variable pointers, where relevant.
// 7) Input variable pointers, where relevant.
//
// DonR 25Dec2019: Added a new safety feature: If you add the optional parameter END_OF_ARG_LIST
// to any of these ODBC_Exec calls (as the last argument, obviously) you'll get an error message
// if your parameter list is shorter than it should be. The error message will tell you what the
// next argument was supposed to be, so it should be easy to diagnose what went wrong.
#define DeclareCursor(DB,OP_ID,...)					ODBC_Exec (DB,		DECLARE_CURSOR,				OP_ID,	NULL,		##__VA_ARGS__)
#define DeclareCursorInto(DB,OP_ID,...)				ODBC_Exec (DB,		DECLARE_CURSOR_INTO,		OP_ID,	NULL,		  __VA_ARGS__)
#define DeclareDeferredCursor(DB,OP_ID,...)			ODBC_Exec (DB,		DEFERRED_INPUT_CURSOR,		OP_ID,	NULL,		##__VA_ARGS__)
#define DeclareDeferredCursorInto(DB,OP_ID,...)		ODBC_Exec (DB,		DEFERRED_INPUT_CURSOR_INTO,	OP_ID,	NULL,		  __VA_ARGS__)
#define OpenCursor(DB,OP_ID,...)					ODBC_Exec (DB,		OPEN_CURSOR,				OP_ID,	NULL,		##__VA_ARGS__)
#define OpenCursorUsing(DB,OP_ID,...)				ODBC_Exec (DB,		OPEN_CURSOR_USING,			OP_ID,	NULL,		##__VA_ARGS__)
#define FetchCursor(DB,OP_ID,...)					ODBC_Exec (DB,		FETCH_CURSOR,				OP_ID,	NULL,		##__VA_ARGS__)
#define FetchCursorInto(DB,OP_ID,...)				ODBC_Exec (DB,		FETCH_CURSOR_INTO,			OP_ID,	NULL,		  __VA_ARGS__)
#define CloseCursor(DB,OP_ID,...)					ODBC_Exec (DB,		CLOSE_CURSOR,				OP_ID,	NULL,		##__VA_ARGS__)
#define FreeStatement(DB,OP_ID,...)					ODBC_Exec (DB,		FREE_STATEMENT,				OP_ID,	NULL,		##__VA_ARGS__)
#define ExecSQL(DB,OP_ID,...)						ODBC_Exec (DB,		SINGLETON_SQL_CALL,			OP_ID,	NULL,		##__VA_ARGS__)
#define ExecSql(DB,OP_ID,...)						ODBC_Exec (DB,		SINGLETON_SQL_CALL,			OP_ID,	NULL,		##__VA_ARGS__)
#define CommitWork(DB,...)							ODBC_Exec (DB,		COMMIT_WORK,				0,		NULL,		##__VA_ARGS__)
#define RollbackWork(DB,...)						ODBC_Exec (DB,		ROLLBACK_WORK,				0,		NULL,		##__VA_ARGS__)
#define RollBackWork(DB,...)						ODBC_Exec (DB,		ROLLBACK_WORK,				0,		NULL,		##__VA_ARGS__)
#define CommitAllWork(...)							ODBC_Exec (NULL,	COMMIT_WORK,				0,		NULL,		##__VA_ARGS__)
#define RollbackAllWork(...)						ODBC_Exec (NULL,	ROLLBACK_WORK,				0,		NULL,		##__VA_ARGS__)
#define RollBackAllWork(...)						ODBC_Exec (NULL,	ROLLBACK_WORK,				0,		NULL,		##__VA_ARGS__)
#define SetDirtyRead(DB,...)						ODBC_Exec (DB,		SET_DIRTY_READ,				0,		NULL,		##__VA_ARGS__)
#define SetCommittedRead(DB,...)					ODBC_Exec (DB,		SET_COMMITTED_READ,			0,		NULL,		##__VA_ARGS__)
#define SetRepeatableRead(DB,...)					ODBC_Exec (DB,		SET_REPEATABLE_READ,		0,		NULL,		##__VA_ARGS__)
#define GetLengthsRead(LEN_OUT,...)					ODBC_Exec (NULL,	GET_LENGTHS_READ,			0,		LEN_OUT,	##__VA_ARGS__)


// Macros for "generic" ODBC error-handling function.
#define ODBC_EnvironmentError(EnvPtr)							ODBC_ErrorHandler(ODBC_ENVIRONMENT_ERR,	EnvPtr,	NULL,	NULL,			0)
#define ODBC_DB_ConnectionError(DB_Ptr)							ODBC_ErrorHandler(ODBC_DB_HANDLE_ERR,	NULL,	DB_Ptr, NULL,			0)
#define ODBC_StatementError(StatementPtr,OperationIdentifier)	ODBC_ErrorHandler(ODBC_STATEMENT_ERR,	NULL,	NULL,	StatementPtr,	OperationIdentifier)


// Function declarations.
int ODBC_Exec						(	ODBC_DB_HEADER		*Database,
										int					CommandType_in,
										int					OperationIdentifier_in,
										SQLLEN				**LengthReadArrayPtr_in,
										...											);

int SQL_GetMainOperationParameters	(	int					OperationIdentifier_in,
										char				**SQL_CommandText_out,
										int					*NumOutputColumns_out,
										short				*NumSingleCharOutputColumns_out,
										ODBC_ColumnParams	**OutputColumns_out,
										int					*NumInputColumns_out,
										ODBC_ColumnParams	**InputColumns_out,
										int					*NeedsWhereClauseIdentifier_out,
										int					*GenerateVALUES_out,
										short				*StatementIsSticky_out,
										char				**CursorName_out,
										char				**ErrorDescription_out	);

int SQL_GetWhereClauseParameters	(	long				WhereClauseIdentifier_in,
										char				**WhereClauseText_out,
										int					*NumInputColumns_out,
										ODBC_ColumnParams	**InputColumns_out,
										char				**ErrorDescription_out	);


int SQL_CustomizePerDB				(	ODBC_DB_HEADER		*Database,
										char				*SQL_Command_in,
										int					*CommandLength_out		);

int ParseColumnList					(	char				*SpecStringIn,
										int					NumColumnsIn,
										ODBC_ColumnParams	*ParamsOut,
										short				*NumSingleCharOutputColumns_out	);

int find_FOR_UPDATE_or_GEN_VALUES	(	int		OperationIdentifier,
										char	*SQL_command_in,
										int		*FoundForUpdate_out,
										int		*FoundInsert_out,
										int		*FoundSelect_out,
										int		*FoundCustomWhereInsertionPoint_out	);

int ODBC_CONNECT					 (	ODBC_DB_HEADER	*Database,
										char			*DSN,
										char			*username,
										char			*password,
										char			*dbname						);

int CleanupODBC						(	ODBC_DB_HEADER	*Database					);

int ODBC_ErrorHandler				(	int			ErrorCategory,
										SQLHENV		*Environment,
										SQLHDBC		*Database,
										SQLHSTMT	*Statement,
										int			OperationIdentifier				);

int ODBC_IsValidPointer				(	void *Pointer_in	);

void ODBC_SegmentationFaultCatcher (int signo);


// The actual function code should compile only once, in the mainline source module.
#ifdef MAIN
// ODBC infrastructure functions.



// C type identifier	ODBC C typedef			C type
//
// SQL_C_CHAR			SQL_CHAR				unsigned char *
// SQL_C_CHAR			SQL_VARCHAR				unsigned char *
// SQL_C_UTINYINT		SQL_C_UTINYINT			char			(For single-character variables - NOT TESTED AS OF 11DEC2019)
// SQL_C_WCHAR			SQL_WCHAR *				wchar_t *		(NOT SET UP YET)
// SQL_C_SSHORT			SQL_SMALLINT			short int
// SQL_C_USHORT			SQL_USMALLINT			unsigned short int
// SQL_C_SLONG			SQL_INTEGER				int
// SQL_C_ULONG			SQL_UINTEGER			unsigned int
// SQL_C_FLOAT			SQL_REAL				float
// SQL_C_DOUBLE			SQL_DOUBLE, SQL_FLOAT	double
// SQL_C_BIT			SQLCHAR					unsigned char
// SQL_C_STINYINT		SQLSCHAR				signed char
// SQL_C_UTINYINT		SQLCHAR					unsigned char
// SQL_C_SBIGINT		SQLBIGINT				long
// SQL_C_UBIGINT		SQLUBIGINT				unsigned long	(NOT SET UP YET)
// SQL_C_BINARY			SQLCHAR *				unsigned char *	(NOT SET UP YET)


int ODBC_Exec (	ODBC_DB_HEADER	*Database,
				int				CommandType_in,
				int				OperationIdentifier_in,
				SQLLEN			**LengthReadArrayPtr_in,
				...	)
{
	va_list				ArgList;
	static char			ErrorBuffer			[ 500];
	static char			SQL_CmdBuffer		[6000];
	static SQLLEN		FieldLengthsRead	[ 300];
	static SQLHSTMT		*StatementCache;
	static short		*Statement_DB_Provider;
	static short		*StatementPrepared;
	static short		*StatementOpened;
	static short		*StatementIsSticky;
	static short		*Statement_SC_OutCols;
	static char			**SavedCommandTextPtr;
	static char			**SingleCharFetchBuffer;
	static char			***SingleCharDestinationPointers;

	void				*ColumnParameterPointers	[300];
	short				ColumnParameterCount		= 0;
	short				CaughtParameterProblem		= 0;

	int					ReturnCode					= 0;
	int					result;
	int					i;
	int					CmdLen;
	char				*CurrentMacroName			= "";
	SQLLEN				RowsAffected;
	SQLHSTMT			*ThisStatementPtr;

	// Flags to indicate which operations are necessary for a particular command type.
	// By default, everything is turned off.
	short				NeedToInterpretOp		= 0;
	short				InterpretOutputOnly		= 0;
	short				NeedToPrepare			= 0;
	short				NeedToBindInput			= 0;
	short				NeedToBindOutput		= 0;
	short				NeedToExecute			= 0;
	short				NeedToFetch				= 0;
	short				NeedToCheckCardinality	= 0;
	short				NeedToClose				= 0;
	short				NeedToFreeStatement		= 0;
	short				NeedToCommit			= 0;
	short				NeedToRollBack			= 0;
	short				NeedToSetDirty			= 0;
	short				NeedToSetCommitted		= 0;
	short				NeedToSetRepeatable		= 0;
	short				NeedValidOperationId	= 0;


	// Variables to store output of SQL_GetMainOperationParameters() and SQL_GetWhereClauseParameters().
	char				*SQL_CommandText;
	long				WhereClauseIdentifier_in;
	int					NumOutputColumns				= 0;
	int					NumInputColumns					= 0;
	int					NumWhereClauseInputColumns		= 0;
	int					NeedsWhereClauseID				= 0;
	int					GenerateVALUES					= 0;
	int					FoundForUpdate					= 0;
	int					FoundInsert						= 0;
	int					FoundSelect						= 0;
	int					FoundCustomWhereInsertionPoint	= 0;
	short				NumSingleCharOutputColumns		= 0;
	short				NumSingleCharOutputColumnsBound	= 0;
	ODBC_ColumnParams	*OutputColumns;
	ODBC_ColumnParams	*InputColumns;
	ODBC_ColumnParams	*WhereClauseInputColumns;
	char				*WhereClauseText;
	char				*CursorName;
	char				*ErrorDescription;

	void				*VoidStar;			// Pointer variable to be loaded from va_args and used for binding.
	void				*BindStar;			// Pointer variable to be used for binding - set equal to VoidStar except for single-character output columns.
	SQLLEN				BindLength;			// Length for binding output columns - forced to 1 for "CHAR(0)"-type single-character output columns.
	int					SQL_ParamType;		// For binding input parameters; set based on parameter's C type.
	short				NumParams;			// Used to validate that a sticky statement is in fact still in PREPAREd state.

//	// Testing/diagnostics only.
//	int					TestStatement;


	// The first time this function is called, do some initialization.
	if (ODBC_Exec_FirstTimeCalled)
	{
		// Allocate statement cache and statement-prepared array based on the total
		// number of SQL statements we know about - even though most of them aren't
		// "sticky" and thus most of these array elements won't really be used. This
		// way we avoid having to search through an array of "sticky" statements to
		// find the one we're looking to (re-)use.
		StatementCache					= malloc (ODBC_MAXIMUM_OPERATION * sizeof(SQLHSTMT));
		Statement_DB_Provider			= malloc (ODBC_MAXIMUM_OPERATION * sizeof(short));
		StatementPrepared				= malloc (ODBC_MAXIMUM_OPERATION * sizeof(short));
		StatementOpened					= malloc (ODBC_MAXIMUM_OPERATION * sizeof(short));
		StatementIsSticky				= malloc (ODBC_MAXIMUM_OPERATION * sizeof(short));
		Statement_SC_OutCols			= malloc (ODBC_MAXIMUM_OPERATION * sizeof(short));
		SingleCharFetchBuffer			= malloc (ODBC_MAXIMUM_OPERATION * sizeof(char *));
		SavedCommandTextPtr				= malloc (ODBC_MAXIMUM_OPERATION * sizeof(char *));
		SingleCharDestinationPointers	= malloc (ODBC_MAXIMUM_OPERATION * sizeof(char **));

		memset ((char *)StatementCache,					(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(SQLHSTMT)));
		memset ((char *)Statement_DB_Provider,			(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(short)));
		memset ((char *)StatementPrepared,				(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(short)));
		memset ((char *)StatementOpened,				(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(short)));
		memset ((char *)StatementIsSticky,				(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(short)));
		memset ((char *)Statement_SC_OutCols,			(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(short)));
		memset ((char *)SingleCharFetchBuffer,			(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(char *)));
		memset ((char *)SavedCommandTextPtr,			(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(char *)));
		memset ((char *)SingleCharDestinationPointers,	(char)0, (ODBC_MAXIMUM_OPERATION * sizeof(char **)));
		memset ((char *)ErrorBuffer,					(char)0, sizeof(ErrorBuffer));
		memset ((char *)SQL_CmdBuffer,					(char)0, sizeof(SQL_CmdBuffer));
		memset ((char *)FieldLengthsRead,				(char)0, sizeof(FieldLengthsRead));
		memset ((char *)ColumnParameterPointers,		(char)0, sizeof(ColumnParameterPointers));

		NumStickyHandlesUsed				= 0;	// Redundant, but I'm feeling paranoid.
		ODBC_Exec_FirstTimeCalled			= 0;	// So next time we don't initialize this stuff.

		strcpy (ODBC_ErrorBuffer, "");
	}

	// Initialize the variable argument list.
	va_start (ArgList, LengthReadArrayPtr_in);

	// Determine what operations we need to perform based on what
	// type of SQL operation type was requested. Just to be paranoid,
	// re-initialize the operation flags to FALSE.
	NeedToInterpretOp		= 0;
	InterpretOutputOnly		= 0;
	NeedToPrepare			= 0;
	NeedToBindInput			= 0;
	NeedToBindOutput		= 0;
	NeedToExecute			= 0;
	NeedToFetch				= 0;
	NeedToCheckCardinality	= 0;
	NeedToClose				= 0;
	NeedToFreeStatement		= 0;
	NeedToCommit			= 0;
	NeedToRollBack			= 0;
	NeedToSetDirty			= 0;
	NeedToSetCommitted		= 0;
	NeedToSetRepeatable		= 0;
	NeedValidOperationId	= 0;
	ReturnCode				= 0;	// Paranoid re-initialization.

	// Set the global last-statement-text pointer NULL. It will be set
	// to a real value by the ODBC error-handling routine.
	ODBC_LastSQLStatementText = NULL;

	// Set the "Avoid Recursion" flag TRUE - so any calls to error-logging routines made from *within*
	// ODBC_Exec will not result in further (recursive) calls to ODBC_Exec.
	ODBC_AvoidRecursion = 1;

	// DonR 24May2020: In order to simplify code - and possibly improve reliability - always
	// use the StatementCache element corresponding to OperationIdentifier_in, instead of the
	// previous logic where we used subscript 0 for non-sticky singleton SQL operations. This
	// means that ThisStatementPtr is set only here, unconditionally.
	ThisStatementPtr = &StatementCache [OperationIdentifier_in];
//
//	// DonR 25May2020: Add unconditional initialization of StickyStatement. For non-sticky
//	// statements, the StatementIsSticky array will always have a zero value, so this won't
//	// change the default from the variable's declaration.
//	StickyStatement = StatementIsSticky	[OperationIdentifier_in];


	// Decide what we're going to have to do in this function call.
	// DonR 18Dec2019: Added three new variations:
	//    A) DeclareDeferredCursor (DEFERRED_INPUT_CURSOR): PREPAREs the
	//       cursor but does *not* bind input parameters.
	//    B) DeclareDeferredCursorInto (DEFERRED_INPUT_CURSOR_INTO):
	//       PREPAREs the cursor and binds output, but does *not* bind
	//       input parameters.
	//    C) OpenCursorUsing (OPEN_CURSOR_USING) *must* be used after
	//       DeclareDeferredCursor or DeclareDeferredCursorInto (assuming
	//       there are input parameters); it binds input parameters before
	//       executing the SELECT.
	// Note that as of 18Dec2019, these variations have *not* been tested.
	switch (CommandType_in)
	{
		case	DECLARE_CURSOR:				NeedToInterpretOp		= 1;
											NeedToPrepare			= 1;
											NeedToBindInput			= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "DeclareCursor";
											break;

		case	DECLARE_CURSOR_INTO:		NeedToInterpretOp		= 1;
											NeedToPrepare			= 1;
											NeedToBindInput			= 1;
											NeedToBindOutput		= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "DeclareCursorInto";
											break;

		case	DEFERRED_INPUT_CURSOR:		NeedToInterpretOp		= 1;
											NeedToPrepare			= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "DeclareDeferredCursor";
											break;

		case	DEFERRED_INPUT_CURSOR_INTO:	NeedToInterpretOp		= 1;
											NeedToPrepare			= 1;
											NeedToBindOutput		= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "DeclareDeferredCursorInto";
											break;

		case	OPEN_CURSOR:				NeedToExecute			= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "OpenCursor";
											break;

		case	OPEN_CURSOR_USING:			NeedToInterpretOp		= 1;
											NeedToBindInput			= 1;
											NeedToExecute			= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "OpenCursorUsing";
											break;

		case	FETCH_CURSOR:				NeedToFetch				= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "FetchCursor";
											break;

		case	FETCH_CURSOR_INTO:			NeedToInterpretOp		= 1;
											InterpretOutputOnly		= 1;
											NeedToBindOutput		= 1;
											NeedToFetch				= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "FetchCursorInto";
											break;

		case	CLOSE_CURSOR:				NeedToClose				= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "CloseCursor";
											break;

		case	FREE_STATEMENT:				NeedToFreeStatement		= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "FreeStatement";
											break;

		case	SINGLETON_SQL_CALL:			NeedToInterpretOp		= 1;
											NeedToPrepare			= 1;
											NeedToBindInput			= 1;
											NeedToBindOutput		= 1;
											NeedToExecute			= 1;
											NeedToFetch				= 1;
											NeedToCheckCardinality	= 1;
											NeedToClose				= 1;
											NeedValidOperationId	= 1;
											CurrentMacroName		= "ExecSQL";
											break;

		case	COMMIT_WORK:				NeedToCommit			= 1;
											CurrentMacroName		= "CommitWork";
											break;

		case	ROLLBACK_WORK:				NeedToRollBack			= 1;
											CurrentMacroName		= "RollbackWork";
											break;

		case	GET_LENGTHS_READ:			// All GET_LENGTHS_READ does is return the address of the internal lengths-read array.
											CurrentMacroName		= "GetLengthsRead";
											break;

		case	SET_DIRTY_READ:				NeedToSetDirty			= 1;
											CurrentMacroName		= "SetDirtyRead";
											break;

		case	SET_COMMITTED_READ:			NeedToSetCommitted		= 1;
											CurrentMacroName		= "SetCommittedRead";
											break;

		case	SET_REPEATABLE_READ:		NeedToSetRepeatable		= 1;
											CurrentMacroName		= "SetRepeatableRead";
											break;



											// Add standard error logging!
		default:							GerrLogMini (GerrId,
														 "ODBC_Exec got unrecognized operation type %d for operation %d!",
														 CommandType_in, OperationIdentifier_in);
											CurrentMacroName		= "Unrecognized operation!";
											ODBC_AvoidRecursion = 0;
											return (-1);

	}


	// DonR 25May2020: Add a sanity check for OperationIdentifier_in - it shouldn't really
	// be necessary, but a little paranoia is a good thing!
	if (((OperationIdentifier_in < 1) || (OperationIdentifier_in >= ODBC_MAXIMUM_OPERATION)) && (NeedValidOperationId))
	{
		GerrLogMini (GerrId, "ODBC_Exec got invalid Operation Identifier %d for %s.", OperationIdentifier_in, CurrentMacroName);
		ODBC_AvoidRecursion = 0;
		return (-1);
	}


	// Master dummy loop to facilitate error reporting - once we've hit a fatal
	// error, we don't want to keep processing.
	do
	{

		// If we're dealing with something simple like a Fetch (with INTO predefined)
		// ora Close, there's no need to look at the operation parameters.
		if (NeedToInterpretOp)
		{
			// Interpret the SQL operation requested.
			// Note that even if this is a "sticky" statement that we've already
			// prepared, we still have to go through this to get to the right
			// place in our variable argument list and get the right input/output
			// variables properly bound!
			result = SQL_GetMainOperationParameters (	OperationIdentifier_in,
														&SQL_CommandText,
														&NumOutputColumns,
														&NumSingleCharOutputColumns,
														&OutputColumns,
														&NumInputColumns,
														&InputColumns,
														&NeedsWhereClauseID,
														&GenerateVALUES,
														&StatementIsSticky [OperationIdentifier_in],
														&CursorName,
														&ErrorDescription	);

			// DonR 27Jan2020: Save the SQL command-text pointer. This is needed only because
			// we give the option for a calling routine to supply the SQL command text if it
			// needs to be built dynamically. Subsequent calls (like FetchCursorInto) may or
			// may not include the "extra" argument with this command text; if they do, we
			// need to be able to recognize it so we can automatically skip past it.
			if (SQL_CommandText != NULL)
				SavedCommandTextPtr [OperationIdentifier_in] = SQL_CommandText;

			// For now, no sophisticated error handling. A negative return code should mean
			// something like an invalid Operation Identifier - i.e. a program bug, not a
			// database issue.
			if (result < 0)
			{
				// Add standard error logging!
				GerrLogMini (GerrId, "SQL_GetMainOperationParameters returned error %d, err text\n%s\n", result, ErrorDescription);
				ODBC_AvoidRecursion = 0;
				return (result);
			}

			// If the operation specification in MacODBC_MyOperators.c gives SQL_CommandText ==  NULL,
			// take the SQL command text from the variable-argument list. This is used when a complex
			// SQL command has to be defined dynamically - e.g. where WHERE...IN() lists require a
			// number of possible values that cannot be known in advance.
			// DonR 27Jan2020: If the current operation is a FETCH or some other operation performed
			// *after* an initial PREPARE, don't worry about retrieving the SQL command text again.
			// (Of course, this means that if you *do* provide the SQL command text again, it'll be
			// interpreted as a parameter to BIND!)
			// DonR 27Jan2020: As noted above, we also need to save the externally-prepared SQL command
			// buffer "on the side", so we can skip past it if it's included in later calls like
			// FetchCursorInto (which may or may not include it).
			if ((SQL_CommandText == NULL) && (NeedToPrepare))
			{
				SavedCommandTextPtr [OperationIdentifier_in] = SQL_CommandText = va_arg (ArgList, void *);
//GerrLogMini (GerrId, "Default SQL command is NULL - using \n%s\n supplied by calling routine.", SQL_CommandText);

				if (SQL_CommandText == END_OF_ARG_LIST)
				{
					GerrLogMini (GerrId, "Premature end of argument list for operation %d - expected SQL command text.", OperationIdentifier_in);
					ODBC_AvoidRecursion = 0;
					return (ODBC_SQLCODE = SQLCODE = -1);
				}
			}

			// DonR 02Feb2020: Before automatically adding VALUES or FOR UPDATE clauses
			// to the SQL command string, make sure they're actually appropriate. Also
			// check to see if there's a "%s" in the command - if not, we'll force
			// NeedsWhereClauseID false.
			find_FOR_UPDATE_or_GEN_VALUES (OperationIdentifier_in, SQL_CommandText, &FoundForUpdate, &FoundInsert, &FoundSelect, &FoundCustomWhereInsertionPoint);
			if ((!FoundCustomWhereInsertionPoint) && (NeedsWhereClauseID))
			{
				GerrLogMini(GerrId, "Suppressed erroneous NeedsWhereClauseID for SQL command %d - there's no insertion point!", OperationIdentifier_in);
				NeedsWhereClauseID = 0;
			}

			// If the request specified requires a "custom" WHERE clause, that should be
			// the first argument on the variable-argument list.
			// DonR 25Dec2019: Added InterpretOutputOnly control variable, set TRUE for
			// FetchCursorInto commands. This is intended to let this function work
			// properly for SQL operations with a "custom" WHERE clause whether or not
			// the FetchCursorInto command included the WHERE clause identifier. The
			// idea is that in this case we skip reading the WHERE clause identifier,
			// and then when we read the first pointer to bind an output variable, we'll
			// check whether what we got was really a pointer, or just an integer that
			// would be a valid WHERE clause ID. If the latter, we'll just pull the next
			// value off the va_arg list. Simple, assuming that we don't have problems
			// dealing with va_arg values of different sizes!
			// NOTE: At least for now, do NOT assume that custom WHERE clauses and
			// externally-built dynamic SQL commands will work perfectly together!
			if ((NeedsWhereClauseID) && (!InterpretOutputOnly))
			{
				WhereClauseIdentifier_in = va_arg (ArgList, long);
				if (WhereClauseIdentifier_in == (long)END_OF_ARG_LIST)
				{
					GerrLogMini (GerrId, "Premature end of argument list for operation %d - expected custom WHERE clause identifier.", OperationIdentifier_in);
					ODBC_AvoidRecursion = 0;
					return (ODBC_SQLCODE = SQLCODE = -1);
				}

				result = SQL_GetWhereClauseParameters	(	WhereClauseIdentifier_in,
															&WhereClauseText,
															&NumWhereClauseInputColumns,
															&WhereClauseInputColumns,
															&ErrorDescription				);

				// For now, no sophisticated error handling. A negative return code should mean
				// something like an invalid Operation Identifier - i.e. a program bug, not a
				// database issue.
				if (result < 0)
				{
					GerrLogMini (GerrId, "SQL_GetWhereClauseParameters returned error %d for %s (%s...", result, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);
					ODBC_AvoidRecursion = 0;
					return (result);
				}


				// If the custom WHERE clause in MacODBC_MyCustomWhereClauses.c gives
				// SQL_CommandText ==  NULL, take the WHERE clause text from the variable-argument
				// list. This can be used when a complex SQL command has to be defined dynamically -
				// e.g. where WHERE...IN() lists require a number of possible values that cannot be
				// known in advance.
				if (WhereClauseText == NULL)
				{
					WhereClauseText = va_arg (ArgList, void *);
//GerrLogMini (GerrId, "Default WHERE clause text is NULL - using \n%s\n supplied by calling routine.", WhereClauseText);
					if (WhereClauseText == END_OF_ARG_LIST)
					{
						GerrLogMini (GerrId, "Premature end of argument list for operation %d - expected WHERE clause text.", OperationIdentifier_in);
						ODBC_AvoidRecursion = 0;
						return (ODBC_SQLCODE = SQLCODE = -1);
					}
				}

			}	// SQL command requires a "custom" WHERE clause.
			else
			{
				NumWhereClauseInputColumns = 0;	// Pure paranoia.
			}

			// If there are single-character (NON-pointer) output fields, see if the required
			// special buffers to handle them have already been created; if not, allocate them
			// and initialize them to all NULLs.
			// DonR 28Apr2020 BUG FIX (I think): SingleCharFetchBuffer and SingleCharDestinationPointers
			// were being malloc'ed every time a given command with single-character output columns was
			// executed, when in fact this should be done only the first time. The solution is to make the
			// malloc's conditional.
			if (NumSingleCharOutputColumns > 0)
			{
				// The buffer to receive single-character output columns needs to be allocated with *2* characters
				// for every column - one for the "payload" character, and one for the trailing NULL that we don't
				// want to return to the calling routine.
				// DonR 28Apr2020 BUG FIX: Make the malloc's conditional so they happen only once for any given SQL operation.
				if (Statement_SC_OutCols [OperationIdentifier_in] < 1)
				{
					Statement_SC_OutCols			[OperationIdentifier_in] = NumSingleCharOutputColumns;
					SingleCharFetchBuffer			[OperationIdentifier_in] = malloc (NumSingleCharOutputColumns * 2);
					SingleCharDestinationPointers	[OperationIdentifier_in] = malloc (NumSingleCharOutputColumns * sizeof(char *));
				}

				memset ((char *)SingleCharFetchBuffer			[OperationIdentifier_in],	0, (NumSingleCharOutputColumns * 2));
				memset ((char *)SingleCharDestinationPointers	[OperationIdentifier_in],	0, (NumSingleCharOutputColumns * sizeof(char *)));
			}

		}	// We need to interpret the operation requested.
//
//		// If we don't need to interpret the operation, set up any necessary variables based on
//		// what we learned when we *did* interpret it.
//		else
//		{
//			StickyStatement = StatementIsSticky [OperationIdentifier_in];
//		}
//


		// If this statement was designated as "sticky", we want to prepare it only
		// the first time, to minimize network traffic and work for the DB server.
		// Input/output binding is still done "on the fly", since (A) it doesn't
		// involve network traffic or the DB server, and (B) it's dangerous to
		// assume old bindings are still valid. For the moment, I've defined
		// ODBC_MAX_STICKY_STATEMENTS as 100; I have no idea if any particular
		// database driver supports that many open statements. We could probably
		// survive quite happily with far fewer.
		// Note that if we already know we don't need to prepare the statement
		// (e.g. for a Fetch or a Close), we need to find the correct statement
		// handle to use but other than that no statement-preparation is necessary.
		if (NeedToPrepare)
		{
			do
			{
				// In real situations, it's unlikely that anyone would want to perform
				// the same SQL operation against two different databases - although
				// it might come up as part of a switchover from one database to
				// another. In any case, it's a good idea to provide automatic support
				// for this even if it'll seldom be used.
				if (Database->Provider != Statement_DB_Provider[OperationIdentifier_in])
				{
					// If this statement was already used for another provider, free it
					// and clear up all associated flags so we start fresh.
					if (Statement_DB_Provider[OperationIdentifier_in] > ODBC_NoProvider)
					{
						// This SQLFreeHandle call may well fail - it's not especially important if it does.
						// DonR 03May2020: Stop using UseStatementSubscript[] - just do the Free Handle for
						// the non-zero array element, since an extra Free Handle won't (or shouldn't) do any
						// damage. If the statement was a non-sticky singleton call, it should already have
						// been freed after the last time it execute.
						result = SQLFreeHandle (SQL_HANDLE_STMT, StatementCache [OperationIdentifier_in]);
GerrLogMini(GerrId, "Switch DB Provider for %s %s from %d to %d: SQLFreeHandle returns %d.", CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], Statement_DB_Provider[OperationIdentifier_in], Database->Provider, result);

						// Reset StatementPrepared so we know we need to set this statement up again next time.
						// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
						StatementPrepared	[OperationIdentifier_in] = 0;
						StatementOpened		[OperationIdentifier_in] = 0;
//
//						if (StatementIsSticky [OperationIdentifier_in])
//						{
//							StatementIsSticky	[OperationIdentifier_in] = 0;
//							NumStickyHandlesUsed--;
//						}
					}	// The previous DB provider for this statement is an actual database.

					// And now we store the new DB provider.
					Statement_DB_Provider[OperationIdentifier_in] = Database->Provider;
				}	// The current DB provider for this statement is not the same as the
					// previous one (which may be a real provider or no provider).


				// The current statement is one that normally requires preparation -
				// but it may be a "sticky" statement that has already been prepared.

				// There is finite capacity to keep open statements; so if a statement
				// has been designated "sticky" but the maximum number of "sticky"
				// statements has already been reached, turn off its "stickiness" and
				// create a diagnostic.
				if ((StatementIsSticky [OperationIdentifier_in]) && (!StatementPrepared [OperationIdentifier_in]))
				{
					if (NumStickyHandlesUsed >= ODBC_MAX_STICKY_STATEMENTS)
					{
						StatementIsSticky [OperationIdentifier_in] = 0;

						// This should probably be replaced by some more sophisticated error handling.
						// Add standard error logging (although this is NOT fatal)!
						GerrLogMini (GerrId, "Rejected sticky statement %d because %d statements are already sticky.\n",
									 OperationIdentifier_in, NumStickyHandlesUsed);
					}
					else
					{
						NumStickyHandlesUsed++;
					}
				}	// "Sticky" statement hasn't yet been prepared, so check if we've reached Peak Stickiness.


//				// Save "sticky" status for later. If the subscript is zero, "sticky" will also be zero.
//				// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
//				StatementIsSticky [OperationIdentifier_in] = StickyStatement;
//
//
				// If the statement is sticky and has already been prepared, we're done
				// with the preparation section - it's already prepared and ready for use.
				if ((StatementIsSticky [OperationIdentifier_in]) && (StatementPrepared [OperationIdentifier_in]))
				{
					// DonR 07May2020: At times, we've seen sticky statements fail the second time around -
					// somehow they got either freed or corrupted. Until and unless I can figure out what
					// causes this and prevent it from happening, add a validation step to ensure that we
					// will re-do the PREPARE if a sticky statement is not in fact still accessible.
					result = SQLNumParams (*ThisStatementPtr, &NumParams);

					if (SQL_FAILED (result))
					{
						GerrLogMini (GerrId, "PID %d: SQLNumParams for %s %s failed with result %d; free and re-PREPARE the statement.",
									 (int)getpid (), CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], result);
						result = SQLFreeHandle (SQL_HANDLE_STMT, *ThisStatementPtr);

						StatementPrepared	[OperationIdentifier_in] = 0;
						StatementOpened		[OperationIdentifier_in] = 0;
					}
					else	// SQLNumParams succeeded, so we can go ahead and re-use the sticky statement.
					{
						break;	// Skip the rest of the PREPARation steps.
					}
				}	// "Sticky" statement should already be prepared and ready for binding.

				// Finally, it's time to actually do something! First, allocate the statement.
				result = SQLAllocStmt (Database->HDBC, ThisStatementPtr);
				if (SQL_FAILED (result))
				{
					GerrLogMini (GerrId, "SQLAllocStmt for SQL op %d failed, returning %d.\n", OperationIdentifier_in, result);
					break;
				}

				// Now build the SQL command string. This should consist of 1-3 elements:
				//
				// 1) The basic command.
				//
				// 2) Optionally, a variable WHERE clause, in cases where we want to perform
				//    the same SELECT, UPDATE, or DELETE with different sets of WHERE criteria.
				//    In this case, there must be a " %s " in the basic command where the WHERE
				//    clause should go; it's best if the keyword "WHERE" itself is part of the
				//    main command, and the variable portion is just the actual criteria. The
				//    code, however, does not enforce this - the variable WHERE stuff can include
				//    the "WHERE" keyword, and alternatively constitute only a subset of the
				//    desired selection criteria, with the rest left in the basic command.
				//
				// 3) Optionally, a constructed VALUES clause - since this is basically just
				//    a bunch of question marks and commas, it's easier to have the function
				//    build it based on the number of input parameters needed and not have to
				//    worry about counting  question marks. Since VALUES always goes at the
				//    end of an INSERT, there's no need for a "%s" in this case.
				if (NeedsWhereClauseID)
				{
					CmdLen = sprintf (SQL_CmdBuffer, SQL_CommandText, WhereClauseText);
				}
				else
				{
					strcpy (SQL_CmdBuffer, SQL_CommandText);
					CmdLen = strlen (SQL_CmdBuffer);
				}

				// Note that at least for now, VALUES generation assumes that there is at least
				// one input parameter - an INSERT with Generate Values set TRUE and no input
				// parameters doesn't make a whole hell of a lot of sense. It would be easy
				// enough to add the condition "NumInputColumns > 0" to the "if" below...
				// DonR 02Feb2020: Generate a VALUES clause only if this is really an INSERT!
				if ((GenerateVALUES) && (FoundInsert))
				{
					CmdLen += sprintf (SQL_CmdBuffer + CmdLen, " VALUES ( ");

					for (i = 0; i < NumInputColumns; i++)
					{
						// Print a leading comma for everything after the first iteration.
						CmdLen += sprintf (SQL_CmdBuffer + CmdLen, "%s?", (i > 0) ? "," : " ");
					}

					CmdLen += sprintf (SQL_CmdBuffer + CmdLen, " ) ");
				}

				// Before preparing the statement, insert any required provider-specific terms.
				// So far, the only ones I know we're using are Informix FIRST = MS-SQL TOP.
				// The SQL_CustomizePerDB routine will look for either %FIRST% or %TOP% (case
				// insensitive) and replace the token with the DB-appropriate term.
				SQL_CustomizePerDB (Database, SQL_CmdBuffer, &CmdLen);

				// At this point, we should have a well-formed SQL command string ready for
				// preparation and binding - kind of a software akeidah.

				// If we need a cursor in "FOR UPDATE" mode, this is where to set it updatable.
				// We don't need a separate indicator variable for this, since the only reason
				// to give a cursor a name is to make it updatable (and making it updatable
				// without assigning a name wouldn't work anyway).
				// DonR 02Feb2020: Cursor Name is relevant only for SELECT statements.
				if ((CursorName != NULL) && (FoundSelect))
				{
					result = SQLSetStmtAttr (*ThisStatementPtr, SQL_ATTR_CONCURRENCY, (SQLPOINTER)SQL_CONCUR_LOCK, SQL_IS_INTEGER);
//GerrLogMini (GerrId, "Set cursor updatable - result = %d.", result);
					if (SQL_FAILED (result))
					{
						ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);
						GerrLogMini (GerrId, "SQLSetStmtAttr failed for operation %d, result = %d.", OperationIdentifier_in, result);
						break;
					}

					// DonR 26Jan2020: At least in Informix, the DB server wants a "FOR UPDATE"
					// even if we've run a SQLSetStmtAttr call. Rather than (God forbid) go
					// through all my SQL commands and add "FOR UPDATE" where necessary, let's
					// make it automatic!
					// DonR 02Feb2020: The call to check for a FOR UPDATE clause has been moved
					// up a bit, since it now also checks whether the SQL command is an INSERT.
					if (!FoundForUpdate)
					{
						CmdLen += sprintf (SQL_CmdBuffer + CmdLen, " FOR UPDATE ");
					}
				}	// CursorName != NULL

				// WORKINGPOINT: Any other SQLSetStmtAttr() commands should go here.


				// Now go ahead and PREPARE the SQL statement.
				// DonR 12Feb2020: Since error-logging routines use READ_GetCurrentDatabaseTime to get a common
				// timestamp, don't copy it into ODBC_LastSQLStatementText.
				if (OperationIdentifier_in != READ_GetCurrentDatabaseTime)
					ODBC_LastSQLStatementText = SQL_CmdBuffer;

				// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
				result = SQLPrepare (*ThisStatementPtr, SQL_CmdBuffer, CmdLen);

				if (SQL_FAILED (result))
				{
					GerrLogMini (GerrId, "PREPARE %s for SQL op %d failed, result = %d!", SQL_CmdBuffer, OperationIdentifier_in, result);
					ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);
					break;
				}
				else
				{
					StatementPrepared [OperationIdentifier_in] = 1;	// Success!
				}

				// If this operation specifies a non-NULL cursor name (which is needed for
				// UPDATE/DELETE operations with WHERE CURRENT OF xxx), set the name now.
				if (CursorName != NULL)
				{
					result = SQLSetCursorName (*ThisStatementPtr, CursorName, SQL_NTS);
//GerrLogMini (GerrId, "Set cursor name to %s - result = %d.", CursorName, result);
					if (SQL_FAILED (result))
					{
						ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);;
						GerrLogMini (GerrId, "SQLSetCursorName failed for operation %d, result = %d.", OperationIdentifier_in, result);
						break;
					}
				}

			} while (0);

//			// TEMPORARY: Check whether any prepared sticky statements have somehow become un-prepared.
//			for (TestStatement = 1; TestStatement < ODBC_MAXIMUM_OPERATION; TestStatement++)
//			{
//				if ((StatementIsSticky[TestStatement]) && (StatementPrepared [TestStatement]) && (TestStatement != OperationIdentifier_in))
//				{
//					result = SQLNumParams (&StatementCache [TestStatement], &NumParams);
//
//					if (SQL_FAILED (result))
//					{
//						GerrLogMini (GerrId, "PID %d: After PREPARE of %s %s, %s is no longer PREPARE'd.",
//									 (int)getpid (), CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], ODBC_Operation_Name [TestStatement]);
//
//						// Clear StatementPrepared so we don't keep generating the same message.
//						StatementPrepared [TestStatement] = 0;
//					}
//				}
//			}

		}	// NeedToPrepare is TRUE.

//		else	// NeedToPrepare is FALSE.
//		{
//			// The current operation does not require preparation.
//			// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[] for the StickyStatement array.
//			// Only the Statement CaChe array should use the variable subscript stored in UseStatementSubscript[].
//			// DonR 03May2020: Get rid of UseStatementSubscript array.
//			StickyStatement = StatementIsSticky	[OperationIdentifier_in];
//
//			if ((!StickyStatement) && (CommandType_in == SINGLETON_SQL_CALL))
//			{
//				ThisStatementPtr = &StatementCache [0];
//			}
//			else
//			{
//				ThisStatementPtr = &StatementCache [OperationIdentifier_in];
//			}
//		}	// NeedToPrepare is FALSE.

		// since the NeedtoPrepare stuff is within its own do-while "loop", we need extra
		// logic to break out of the main "loop" if we hit an error.
		if (ReturnCode)
		{
			GerrLogMini (GerrId, "After PREPARE section, ReturnCode = %d - breaking out of do-loop.", ReturnCode);
			break;
		}


		// DonR 12Feb2020: Instead of pulling arguments directly from va_args and immediately binding
		// them, load them all into a buffer first. This way we can make at least some attempt to
		// ensure that the pointers are valid (e.g. no missing ampersands) *before* we do anything
		// with them - and thus avoid segmentation errors.
		ColumnParameterCount	= 0;	// Paranoid re-initialization.
		CaughtParameterProblem	= 0;	// Yet more paranoia.
		ODBC_ValidatingPointers	= 1;	// Until we turn this OFF, segmentation faults will be caught and
										// used to detect bad column/parameter pointers - but will *not*
										// crash the program.

		if (NeedToBindOutput)
		{
			for (i = 0; i < NumOutputColumns; i++)
			{
				VoidStar = va_arg (ArgList, void *);

				if (VoidStar == END_OF_ARG_LIST)
				{
					sprintf (sqlca.sqlerrm, "Premature end of argument list for %s (%s... - expected output column %d.",
							 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], i + 1);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// Skip past optional parameters like Custom WHERE Clause ID and dynamically-created
				// SQL command text. We want to do this only at the beginning of the column list, and
				// only when these parameters were not in fact required. (If they were, we should have
				// already taken them from va_args!)
				if ((i == 0) && (InterpretOutputOnly))
				{
					// DonR 25Dec2019: If the first "pointer" we pulled off the va_arg list looks like a
					// custom WHERE clause ID, *and* we're performing an operation (i.e. FetchCursorInto)
					// where that parameter is optional, skip past it and pull the next argument off the
					// va_arg list.
					if (((long)VoidStar > 0) && ((long)VoidStar < ODBC_MAXIMUM_WHERE_CLAUSE))
					{
						WhereClauseIdentifier_in = (long)VoidStar;	// Just for nicer diagnostic messages.
// GerrLogMini (GerrId, "Skipping past apparent custom WHERE clause ID %ld.", WhereClauseIdentifier_in);
						VoidStar = va_arg (ArgList, void *);
						if (VoidStar == END_OF_ARG_LIST)
						{
							sprintf (sqlca.sqlerrm, "Premature end of argument list for %s (%s... - expected output column %d after WHERE clause ID %ld.",
									 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], i + 1, WhereClauseIdentifier_in);
							ReturnCode = result = -1;	// Force "syntax" error.
							CaughtParameterProblem = 1;
							break;
						}
//GerrLogMini (GerrId, "Replacement first output pointer = %ld.", (long)VoidStar);
					}

					// DonR 27Jan2020: Another similar gimmick: When the calling routine has supplied
					// a dynamically-created SQL command instead of using a "canned" one, subsequent
					// calls (like FetchCursorInto) may or may not include the custom SQL command as
					// a parameter. If it was supplied, we want to skip past it automatically.
					// NOT YET TESTED!!!
					if ((char *)VoidStar == SavedCommandTextPtr [OperationIdentifier_in])
					{
GerrLogMini (GerrId, "Skipping past apparent custom dynamic SQL command text.");
						VoidStar = va_arg (ArgList, void *);
						if (VoidStar == END_OF_ARG_LIST)
						{
							sprintf (sqlca.sqlerrm, "Premature end of argument list for %s (%s... - expected output column %d after dynamic SQL command text.",
									 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], i + 1);
							ReturnCode = result = -1;	// Force "syntax" error.
							CaughtParameterProblem = 1;
							break;
						}
//GerrLogMini (GerrId, "Replacement first output pointer = %ld.", (long)VoidStar);
					}
				}	// First column parameter and we're in interpret-output-only mode.

				// Check that the output pointer is actually valid, to avoid program
				// hang-ups and crashes.
				if (!ODBC_IsValidPointer (VoidStar))
				{
					sprintf (sqlca.sqlerrm, "Output parameter %d for %s (%s... is invalid!",
							 i + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// If we get here, we expect to have a valid output column pointer - so store it.
				ColumnParameterPointers [ColumnParameterCount++] = VoidStar;

			}	// Loop through output columns and store them in ColumnParameterPointers array.

			if (CaughtParameterProblem)
			{
				GerrLogMini (GerrId, "%s", sqlca.sqlerrm);
			}
		}	// This operation type normally requires binding output columns.


		if ((NeedToBindInput) && (!CaughtParameterProblem))
		{
			for (i = 0; i < NumInputColumns; i++)
			{
				VoidStar = va_arg (ArgList, void *);
				if (VoidStar == END_OF_ARG_LIST)
				{
					sprintf (sqlca.sqlerrm, "Premature end of argument list for %s (%s... - expected input column %d.",
							 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], i + 1);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// Test pointer for validity by reading a byte and writing it back.
				if (!ODBC_IsValidPointer (VoidStar))
				{
					sprintf (sqlca.sqlerrm, "Input parameter %d for %s (%s... is invalid!",
							 i + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// If we get here, we expect to have a valid input column pointer - so store it.
				ColumnParameterPointers [ColumnParameterCount++] = VoidStar;
			}	// Loop through input parameters and store them in ColumnParameterPointers array.

			if (CaughtParameterProblem)
			{
				GerrLogMini (GerrId, "%s", sqlca.sqlerrm);
			}
		}	// This operation type normally requires binding input parameters.


		if ((NeedsWhereClauseID) && (NeedToBindInput) && (NumWhereClauseInputColumns > 0) && (!CaughtParameterProblem))
		{
			for (i = 0; i < NumWhereClauseInputColumns; i++)
			{
				VoidStar = va_arg (ArgList, void *);
				if (VoidStar == END_OF_ARG_LIST)
				{
					sprintf (sqlca.sqlerrm, "Premature end of argument list for %s (%s... - expected custom WHERE clause %ld column %d.",
							 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], (long)WhereClauseIdentifier_in, i + 1);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// Test pointer for validity by reading a byte and writing it back.
				if (!ODBC_IsValidPointer (VoidStar))
				{
					sprintf (sqlca.sqlerrm, "Custom WHERE clause parameter %d for %s (%s... WHERE clause ID %d is invalid!",
							 i + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], WhereClauseIdentifier_in);
					ReturnCode = result = -1;	// Force "syntax" error.
					CaughtParameterProblem = 1;
					break;
				}

				// If we get here, we expect to have a valid input column pointer - so store it.
				ColumnParameterPointers [ColumnParameterCount++] = VoidStar;
			}	// Loop through custom WHERE clause input parameters and store them in ColumnParameterPointers array.

			if (CaughtParameterProblem)
			{
				GerrLogMini (GerrId, "%s", sqlca.sqlerrm);
			}
		}	// This operation type requires binding custom WHERE clause parameters.

		// Reset the switch so that any further segmentation-fault errors will crash the program, as
		// we would normally expect them to do.
		ODBC_ValidatingPointers = 0;

		// DonR 12Feb2020: If the current command involves input OR output columns, the programmer
		// should put END_OF_ARG_LIST at the end of the argument list. By checking for this special
		// argument, we should be able to reduce bugs caused by programmer sloppiness. Since some
		// of these bugs can be show-stoppers, I'm going to make this a fatal error even though
		// END_OF_ARG_LIST was optional until now.
		if ((ColumnParameterCount > 0) && (!CaughtParameterProblem))
		{
			VoidStar = va_arg (ArgList, void *);

			if (VoidStar != END_OF_ARG_LIST)
			{
				sprintf (sqlca.sqlerrm, "Missing END_OF_ARG_LIST for %s (%s... - check parameter list!",
						 CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);
				ReturnCode = result = -1;	// Force "syntax" error.
				CaughtParameterProblem = 1;
				GerrLogMini (GerrId, "%s", sqlca.sqlerrm);
				break;
			}
		}	// Current command has at least one input or output column parameter.
//GerrLogMini(GerrId, "CaughtParameterProblem = %d for %s (%s...", CaughtParameterProblem, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);

		// If we caught any parameter problems (which may have happened inside a loop), it's time to give up now!
		if (CaughtParameterProblem)
		{
//GerrLogMini(GerrId, "CaughtParameterProblem = %d for %s (%s...", CaughtParameterProblem, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in]);
			break;
		}


		// If we get here, we should have exactly the right number of (valid, we hope!) input and output parameters.
		// Since we've already checked this, we don't have to check again in the binding routines below.

		// DonR 28Apr2020: Instead of using a separate pointer variable and incrementing it, just re-use
		// the subscript variable ColumnParameterCount.
		// We'll pull values out of this array the same as if we were pulling them from va_args.
		ColumnParameterCount = 0;	// Rewind to the beginning of the list of stored column pointers.


		// Now that the SQL statement has been prepared, it's time to bind columns to it.
		// First bind output columns, then input columns. (Why output before input? Just
		// so it's easier to convert embedded-SQL code to the new format.)
		if (NeedToBindOutput)
		{
			// Before binding output parameters, re-initialize the lengths-read array to all zeroes.
			memset ((char *)FieldLengthsRead, 0, sizeof(FieldLengthsRead));
			for (i = NumSingleCharOutputColumnsBound = 0; i < NumOutputColumns; i++)
			{
				// Diagnostic only - will be removed later, and we'll rely on the ODBC driver to throw
				// an error if the type is bad. (Of course, we'll need to check that it does so...)
				switch (OutputColumns[i].type)
				{
					// For output columns, VARCHAR is the same as CHAR - the only difference is
					// how the database stores the data internally.
					case		SQL_VARCHAR:		OutputColumns[i].type = SQL_C_CHAR;
					case		SQL_C_UTINYINT:
					case		SQL_C_SSHORT:
					case		SQL_C_USHORT:
					case		SQL_C_SLONG:
					case		SQL_C_ULONG:
					case		SQL_C_SBIGINT:
					case		SQL_C_DOUBLE:
					case		SQL_C_FLOAT:
					case		SQL_C_CHAR:			break;

					default:						// Add normal error logging!
													GerrLogMini (GerrId, "Unrecognized output parameter type %d for column #%d of SQL operation %d!",
															OutputColumns[i].type, (i + 1), OperationIdentifier_in);
													break;
				}

				// By default, BindStar is simply the next pointer we pull off the variable-argument
				// list. The only exception is when we need to SELECT a database CHAR(1) column into
				// a simple character variable; in that case we need to BIND to an internal buffer,
				// save the address of the output variable, and later copy the single "payload"
				// character from the internal buffer to the output addess.
				// NOTE that for now, we're assuming that the only variable-length output field type
				// is CHAR/VARCHAR - we're not worrying about other variable-length types.
				BindStar = VoidStar = ColumnParameterPointers [ColumnParameterCount++];

				if (OutputColumns[i].type == SQL_C_CHAR)
				{
					// The minimum length for a character output column is 2 - one character "payload"
					// and one character for the trailing NULL. If this is a single-character NON-pointer
					// output column, OutputColumns[i].length will be zero - so we have to force in a
					// bind length of 2. In this case we also need to save the "real" output address and
					// substitute the address of our internal buffer, since otherwise the trailing NULL
					// from the database variable would overwrite something in the calling routine.
					if (OutputColumns[i].length < 1)
					{
						BindLength	= 2;
						BindStar	= &SingleCharFetchBuffer [OperationIdentifier_in] [NumSingleCharOutputColumnsBound * 2];
						SingleCharDestinationPointers [OperationIdentifier_in] [NumSingleCharOutputColumnsBound] = VoidStar;
						NumSingleCharOutputColumnsBound++;
					}
					else
					{
						BindLength	= OutputColumns[i].length + 1;
					}
				}	// Output column type is CHAR.
				else
				{
					// For everything other than CHAR output types (i.e. various numeric types),
					// Bind Length is zero.
					BindLength = 0;
				}

				// NOTE: The Field Length Read is stored according to the column number passed
				// to ODBC - in other words, we start counting at 1, *not* zero!
				result = SQLBindCol (	*ThisStatementPtr,
										(unsigned short)(i + 1),	// DonR 02Apr2020: Typecast should be unnecessary, but it's harmless at worst.
										OutputColumns[i].type,
										BindStar,
										BindLength,
										&FieldLengthsRead[i + 1]	);

				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);;
					GerrLogMini(GerrId, "BIND failed for output column %d of SQL operation %s (%s...! Result = %d, ODBC error = %s.",
								i + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], result, ODBC_ErrorBuffer);
					break;
				}

			}	// Loop through output columns and SQLBindCol them.
		}	// This operation type normally requires binding output columns.


		// Now bind input columns.
		if (NeedToBindInput)
		{
			for (i = 0; i < NumInputColumns; i++)
			{
				// Note that SQL_VARCHAR is permitted as an input column type, but not for output columns.
				// We need to make sure the ODBC BindODBCParam() function returns an error of some sort
				// when it's given an invalid parameter type.
				switch (InputColumns[i].type)
				{
					case		SQL_C_SSHORT:		SQL_ParamType = SQL_SMALLINT;	break;
					case		SQL_C_USHORT:		SQL_ParamType = SQL_SMALLINT;	break;
					case		SQL_C_SLONG:		SQL_ParamType = SQL_INTEGER;	break;
					case		SQL_C_ULONG:		SQL_ParamType = SQL_INTEGER;	break;
					case		SQL_C_SBIGINT:		SQL_ParamType = SQL_BIGINT;		break;
					case		SQL_C_FLOAT:
					case		SQL_C_DOUBLE:		SQL_ParamType = SQL_FLOAT;		break;
					case		SQL_C_CHAR:			SQL_ParamType = SQL_CHAR;		break;
					case		SQL_C_UTINYINT:		SQL_ParamType = SQL_CHAR;		break;	// NOT TESTED AS OF 11DEC2019!
					case		SQL_VARCHAR:		SQL_ParamType = SQL_VARCHAR;	InputColumns[i].type = SQL_C_CHAR;		break;

					default:						// Add normal error logging!
													SQL_ParamType = 0;
													GerrLogMini (GerrId, "Unrecognized input parameter type %d!\n", InputColumns[i].type);
													break;
				}

				VoidStar = ColumnParameterPointers [ColumnParameterCount++];

				result = SQLBindParameter (	*ThisStatementPtr,
											(unsigned short)(i + 1),	// DonR 02Apr2020: Typecast should be unnecessary, but it's harmless at worst.
											SQL_PARAM_INPUT,
											InputColumns[i].type,
											SQL_ParamType,
											((SQL_ParamType == SQL_CHAR) || (SQL_ParamType == SQL_VARCHAR)) ? InputColumns[i].length : 0,
											0,
											VoidStar,
											0,
											NULL	);
				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);
					GerrLogMini (GerrId, "Error binding input parameter #%d for %s (%s..., type = %d, result = %d, ptr = %ld, ODBC error = %s.",
								 i + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], InputColumns[i].type, result, (long)VoidStar, ODBC_ErrorBuffer);
					break;
				}
			}	// Loop through input parameters and SQLBindParameter them.


			// If there are any additional parameters in a "custom" WHERE clause, bind those as well.
			// (Note that we're assuming that these always come after "normal" input parameters -
			// I *think* that's correct!)
			if ((NeedsWhereClauseID) && (NumWhereClauseInputColumns > 0))
			{
				for (i = 0; i < NumWhereClauseInputColumns; i++)
				{
					// Note that SQL_VARCHAR is permitted as an input column type, but not for output columns.
					// We need to make sure the ODBC BindODBCParam() function returns an error of some sort
					// when it's given an invalid parameter type.
					switch (WhereClauseInputColumns[i].type)
					{
						case		SQL_C_SSHORT:		SQL_ParamType = SQL_SMALLINT;	break;
						case		SQL_C_USHORT:		SQL_ParamType = SQL_SMALLINT;	break;
						case		SQL_C_SLONG:		SQL_ParamType = SQL_INTEGER;	break;
						case		SQL_C_ULONG:		SQL_ParamType = SQL_INTEGER;	break;
						case		SQL_C_SBIGINT:		SQL_ParamType = SQL_BIGINT;		break;
						case		SQL_C_FLOAT:
						case		SQL_C_DOUBLE:		SQL_ParamType = SQL_FLOAT;		break;
						case		SQL_C_CHAR:			SQL_ParamType = SQL_CHAR;		break;
						case		SQL_C_UTINYINT:		SQL_ParamType = SQL_CHAR;		break;	// NOT TESTED AS OF 11DEC2019!
						case		SQL_VARCHAR:		SQL_ParamType = SQL_VARCHAR;	WhereClauseInputColumns[i].type = SQL_C_CHAR;		break;

						default:						// Add normal error logging!
														SQL_ParamType = 0;
														printf ("Unrecognized custom WHERE clause parameter type %d!\n", WhereClauseInputColumns[i].type);
														break;
					}

					VoidStar = ColumnParameterPointers [ColumnParameterCount++];

					// Note that we add NumInputColumns to the parameter number, since this list comes
					// after the "normal" input parameter list.
					result = SQLBindParameter (	*ThisStatementPtr,
												(unsigned short)(i + NumInputColumns + 1),	// DonR 02Apr2020: Typecast should be unnecessary, but it's harmless at worst.
												SQL_PARAM_INPUT,
												WhereClauseInputColumns[i].type,
												SQL_ParamType,
												((SQL_ParamType == SQL_CHAR) || (SQL_ParamType == SQL_VARCHAR)) ? WhereClauseInputColumns[i].length : 0,
												0,
												VoidStar,
												0,
												NULL	);
					if (SQL_FAILED (result))
					{
						ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);
						GerrLogMini (GerrId, "Error binding custom WHERE clause parameter #%d for %s (%s..., type = %d, result = %d.\n",
									 i + NumInputColumns + 1, CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], WhereClauseInputColumns[i].type, result);
						break;
					}
				}	// Loop through "custom" WHERE clause input parameters and SQLBindParameter them.
			}	// There is a "custom" WHERE clause with at least one input parameter.
		}	// This operation type normally requires binding input columns.


		// Now that we're all bound up, try to execute the SQL statement. (This is done
		// for open-cursor commands and for singleton operations.)
		if (NeedToExecute)
		{
			// If we haven't done a PREPARE (e.g. if we do an OpenCursor without DeclareCursor),
			// throw an error and don't even try to perform the SQLExecute.
			// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
			if (!StatementPrepared [OperationIdentifier_in])
			{
				ReturnCode = result = -400;	// Invalid Cursor State.
				strcpy (sqlca.sqlerrm, "Attempted to EXECUTE/OPEN before SQL statement was PREPARED/DECLARED.");
GerrLogMini (GerrId, "Attempted to EXECUTE/OPEN %s %s before SQL statement was PREPARED/DECLARED - returning ReturnCode %d.", CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], ReturnCode);
				break;
			}

			ReturnCode = result = SQLExecute (*ThisStatementPtr);

			if (SQL_FAILED (result))
			{
				ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);;
//if (strcmp(ODBC_Operation_Name [OperationIdentifier_in], "process_spools_UPD_gadget_spool_timer")) GerrLogMini (GerrId, "SQLExecute %s %s failed with result %d - returning ReturnCode %d.", CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], result, ReturnCode);
				break;
			}
			else
			{
				// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
				StatementOpened [OperationIdentifier_in] = 1;
				result = SQLRowCount (*ThisStatementPtr, (SQLLEN *)&sqlca.sqlerrd[2]);
				// printf ("AFter SQLExecute of %d, SQLRowCount returned %d, %d rows.\n", OperationIdentifier_in, result, sqlca.sqlerrd[2]);
			}

//			// TEMPORARY: Check whether any prepared sticky statements have somehow become un-prepared.
//			for (TestStatement = 1; TestStatement < ODBC_MAXIMUM_OPERATION; TestStatement++)
//			{
//				if ((StatementIsSticky[TestStatement]) && (StatementPrepared [TestStatement]) && (TestStatement != OperationIdentifier_in))
//				{
//					result = SQLNumParams (&StatementCache [TestStatement], &NumParams);
//
//					if (SQL_FAILED (result))
//					{
//						GerrLogMini (GerrId, "PID %d: After EXECUTE of %s %s, %s is no longer PREPARE'd.",
//									 (int)getpid (), CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], ODBC_Operation_Name [TestStatement]);
//
//						// Clear StatementPrepared so we don't keep generating the same message.
//						StatementPrepared [TestStatement] = 0;
//					}
//				}
//			}


		}	// This operation type requires executing an SQL statement.


		// ...And fetch the results!
		// If there are no output columns, we force NeedToFetch FALSE even if this is an
		// operation type that otherwise would require a Fetch. This will happen all the
		// time for singleton operations like INSERT or UPDATE. (But for any kind of FETCH,
		// we obviously want to fetch - NumOutputColumns will be zero for a FETCH after
		// a SELECT INTO.)
		if ((CommandType_in == SINGLETON_SQL_CALL) && (NumOutputColumns < 1))
			NeedToFetch = 0;

		if (NeedToFetch)
		{
			// If we haven't done an OPEN (e.g. if we forgot to perform an OpenCursor),
			// throw an error and don't even try to perform the FETCH.
			// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
			if (!StatementOpened [OperationIdentifier_in])
			{
				ReturnCode = result = -400;	// Invalid Cursor State.
				strcpy (sqlca.sqlerrm, "Attempted to FETCH before SQL statement was EXECUTED/OPENED.");
//GerrLogMini (GerrId, "Attempted to FETCH before SQL statement was EXECUTED/OPENED - returning ReturnCode %d.\n", ReturnCode);
				break;
			}
			// ReturnCode = result = SQLFetch (*Statement);
			ReturnCode = result = SQLFetchScroll (*ThisStatementPtr, SQL_FETCH_NEXT, 0);

			if ((result != 100) && (SQL_FAILED (result)))
			{
				ReturnCode = ODBC_StatementError (ThisStatementPtr, OperationIdentifier_in);;
				break;
			}

			// Database servers are not required to return the number of rows SELECTed, either
			// after an EXECUTE or after a FETCH. It appears that MS-SQL does return a value,
			// but Informix does not. Thus for Informix there's no point in even calling
			// SQLRowCount.
			if ((NeedToCheckCardinality) && ((ReturnCode == 0) || (ReturnCode == 1)))
			{
				if (Database->Provider == ODBC_Informix)
				{
					result = SQLFetchScroll (*ThisStatementPtr, SQL_FETCH_NEXT, 0);
					if (result == 0)
						ReturnCode = -284;
				}
				else
				{
					result = SQLRowCount (*ThisStatementPtr, &RowsAffected);
					if (RowsAffected > 1)
					{
						ReturnCode = -284;
					}
				}	// Database is NOT Informix.
			}	// Need to check cardinality.

			// If this SQL statement includes CHAR(1) columns that need to be returned
			// as "simple" character values (NOT pointers), the SELECTed output will have
			// been bound to an internal buffer - so we need to copy from there to the
			// saved output addresses.
			if (Statement_SC_OutCols [OperationIdentifier_in] > 0)
			{
				for (i = 0; i < Statement_SC_OutCols [OperationIdentifier_in]; i++)
				{
					*SingleCharDestinationPointers [OperationIdentifier_in] [i] = SingleCharFetchBuffer [OperationIdentifier_in] [i * 2];
				}
			}	// We need to copy single-character values to NON-pointer output variables.

		}	// There is at least one output field, so we need to fetch something.


		if (NeedToCommit)
		{
			// If the incoming database pointer is NULL, the calling function wants to commit
			// ALL databases - so we execute the SQLEndTran() at the environment level.
			if (Database == NULL)
			{
				// Commit all databases we've connected to.
				result = SQLEndTran (SQL_HANDLE_ENV, ODBC_henv, SQL_COMMIT);
				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_EnvironmentError (&ODBC_henv);
					break;
				}
			}
			else
			{
				// Commit the database handle passed in by the calling function.
				result = SQLEndTran (SQL_HANDLE_DBC, Database->HDBC, SQL_COMMIT);
				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_DB_ConnectionError (&Database->HDBC);
					break;
				}
			}
		}	// NeedToCommit.


		if (NeedToRollBack)
		{
//GerrLogMini (GerrId, "SQL_ROLLBACK was called - Database %s NULL.", (Database == NULL) ? "is" : "is not");
			// If the incoming database pointer is NULL, the calling function wants to roll
			// back ALL databases - so we execute the SQLEndTran() at the environment level.
			if (Database == NULL)
			{
				// Roll back all databases we've connected to.
				result = SQLEndTran (SQL_HANDLE_ENV, ODBC_henv, SQL_ROLLBACK);
				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_EnvironmentError (&ODBC_henv);
					break;
				}
			}
			else
			{
				// Roll back the database handle passed in by the calling function.
				result = SQLEndTran (SQL_HANDLE_DBC, Database->HDBC, SQL_ROLLBACK);
				if (SQL_FAILED (result))
				{
					ReturnCode = ODBC_DB_ConnectionError (&Database->HDBC);
					break;
				}
			}
		}	// NeedToRollBack.


		if (NeedToSetDirty)
		{
			result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_TXN_ISOLATION, (SQLPOINTER)SQL_TXN_READ_UNCOMMITTED, SQL_IS_UINTEGER);
			if (SQL_FAILED (result))
			{
				printf ("Set isolation DIRTY failed (result = %d).\n", result);
				ReturnCode = ODBC_DB_ConnectionError (&Database->HDBC);
			}
		}


		if (NeedToSetCommitted)
		{
			result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_TXN_ISOLATION, (SQLPOINTER)SQL_TXN_READ_COMMITTED, SQL_IS_UINTEGER);
			if (SQL_FAILED (result))
			{
				printf ("Set isolation COMMITTED failed (result = %d).\n", result);
				ReturnCode = ODBC_DB_ConnectionError (&Database->HDBC);
			}
		}


		if (NeedToSetRepeatable)
		{
			result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_TXN_ISOLATION, (SQLPOINTER)SQL_TXN_REPEATABLE_READ, SQL_IS_UINTEGER);
			if (SQL_FAILED (result))
			{
				printf ("Set isolation REPEATABLE failed (result = %d).\n", result);
				ReturnCode = ODBC_DB_ConnectionError (&Database->HDBC);
			}
		}

	} while (0);	// End of big dummy loop.



	// If ReturnCode = 1 (OK with info), just return 0 (OK) in SQLCODE.
	sqlca.sqlcode = SQLCODE = ODBC_SQLCODE = (ReturnCode == 1) ? 0 : ReturnCode;


	// NeedToClose will be true if the current command is CLOSE_CURSOR
	// or SINGLETON_SQL_CALL. If the command is set up as non-"sticky",
	// we need to do a "hard close" by calling SQLFreeHandle. If the
	// command is "sticky", we want to do a "soft close", closing the
	// cursor and losing any pending results, but keeping all our
	// preparation and binding. And if the command was a singleton
	// statement with no output columns, we can skip even this step,
	// since any SELECT command will have output columns and other
	// commands don't create a cursor. (This may have to be revisited
	// if someone starts using INSERT cursors, but I don't think there
	// are any of those in the system at present and I don't see any
	// likely need for one.)
	//
	// It's worth noting that the model implemented here is one that
	// has good "hygiene", in that it doesn't leave PREPARED statements
	// sitting around unless they're "sticky". On the other hand, we
	// may see reduced performance from this - I'm not certain, but it's
	// possible that embedded SQL was doing the PREPARE only once for
	// each statement (or perhaps only once for each cursor), and forcing
	// the system to perform a lot more PREPARE's would gum up the works.
	// If we see this happening, the first point of attack is to be more
	// aggressive in designating statements as "sticky", and *not*
	// executing FreeStatement on them in high-volume transactions. We
	// may even want to increase ODBC_MAX_STICKY_STATEMENTS to give
	// ourselves room for more "sticky" statements.
	if (NeedToClose)
	{
		if (StatementIsSticky [OperationIdentifier_in])
		{
			// If this is a singleton command and it's something that doesn't involve
			// output columns (like an INSERT or an UPDATE, for example) don't bother
			// doing anything. Note that it might be just as sensible to execute the
			// SQLFreeStmt even in those cases - it shouldn't have much overhead.
			if (( CommandType_in == CLOSE_CURSOR) ||
				((CommandType_in == SINGLETON_SQL_CALL) && (NumOutputColumns > 0)))
			{
				result = SQLFreeStmt (*ThisStatementPtr, SQL_CLOSE);
				StatementOpened [OperationIdentifier_in] = 0;
			}

		}	// "Sticky" statements get a "soft" close-cursor, if necessary.
		else
		{
			// "Non-sticky" statements need to be completely freed after use.
			NeedToFreeStatement = 1;
		}

//			// TEMPORARY: Check whether any prepared sticky statements have somehow become un-prepared.
//			for (TestStatement = 1; TestStatement < ODBC_MAXIMUM_OPERATION; TestStatement++)
//			{
//				if ((StatementIsSticky[TestStatement]) && (StatementPrepared [TestStatement]) && (TestStatement != OperationIdentifier_in))
//				{
//					result = SQLNumParams (&StatementCache [TestStatement], &NumParams);
//
//					if (SQL_FAILED (result))
//					{
//						GerrLogMini (GerrId, "PID %d: After CLOSE of %s %s, %s is no longer PREPARE'd.",
//									 (int)getpid (), CurrentMacroName, ODBC_Operation_Name [OperationIdentifier_in], ODBC_Operation_Name [TestStatement]);
//
//						// Clear StatementPrepared so we don't keep generating the same message.
//						StatementPrepared [TestStatement] = 0;
//					}
//				}
//			}

	}	// The current command is one that may require some kind of close - either "hard" or "soft".


	if (NeedToFreeStatement)
	{
		result = SQLFreeHandle (SQL_HANDLE_STMT, *ThisStatementPtr);
		// if (result) printf("Normal SQLFreeHandle for Op %d returns %d.\n", OperationIdentifier_in, result);

		// Reset StatementPrepared (and StatementOpened) so we know we need to set this statement up again next time.
		// DonR 29Mar2020: Use simple subscript rather than UseStatementSubscript[].
		StatementPrepared	[OperationIdentifier_in] = 0;
		StatementOpened		[OperationIdentifier_in] = 0;

		// If the calling routine is forcibly freeing a sticky statement, mark it as un-sticky and
		// (more importantly) decrement the number-of-open-sticky-statements counter.
		if (StatementIsSticky [OperationIdentifier_in])
		{
			StatementIsSticky	[OperationIdentifier_in] = 0;
			NumStickyHandlesUsed--;
		}
//			result = SQLFreeStmt(*Statement, SQL_CLOSE);
//			result = SQLFreeStmt(*Statement, SQL_UNBIND);
//			result = SQLFreeStmt(*Statement, SQL_RESET_PARAMS);
	}	// Statement needs a "hard close", either because it's non-sticky or because the calling routine asked for it.


	va_end (ArgList);

	// If the caller has sent a non-null address to store it, send back
	// the location of the lengths-read array. While we're at it, also
	// copy that location into a global variable, ColumnOutputLengths,
	// so calling functions can be lazy and not bother using GetLengthsRead().
	ColumnOutputLengths = &FieldLengthsRead[0];
	if (LengthReadArrayPtr_in != NULL)
		*LengthReadArrayPtr_in = &FieldLengthsRead[0];

	ODBC_AvoidRecursion = 0;

	return (SQLCODE);
}	// ODBC_Exec() end.


int SQL_GetMainOperationParameters (	int					OperationIdentifier_in,
										char				**SQL_CommandText_out,
										int					*NumOutputColumns_out,
										short				*NumSingleCharOutputColumns_out,
										ODBC_ColumnParams	**OutputColumns_out,
										int					*NumInputColumns_out,
										ODBC_ColumnParams	**InputColumns_out,
										int					*NeedsWhereClauseIdentifier_out,
										int					*GenerateVALUES_out,
										short				*StatementIsSticky_out,
										char				**CursorName_out,
										char				**ErrorDescription_out	)
{
	// Output variables.
	static char					*SQL_CommandText;
	static short				NumSingleCharOutputColumns	= 0;
	static int					NumOutputColumns			= 0;
	static int					NumInputColumns				= 0;
	static int					NeedsWhereClauseID			= 0;
	static int					GenerateVALUES				= 0;
	static int					StatementIsSticky			= 0;
	static int					LastOperationID				= -1;
	static char					*CursorName					= NULL;
	static ODBC_ColumnParams	OutputColumns	[300];
	static ODBC_ColumnParams	InputColumns	[300];
	static char					ErrorBuffer		[500];
	char						*OutputColumnSpec;
	char						*InputColumnSpec;
	int							RetVal						= 0;
	int							SameOpAsLastTime;


	// Before we do anything, assume we have no error to report.
	RetVal	= 0;
	strcpy (ErrorBuffer, "");

	// Check whether this is the same operation as the last one requested. If so,
	// we don't have to re-parse the input/output column specifications.
//	SameOpAsLastTime = (OperationIdentifier_in == LastOperationID);
	SameOpAsLastTime = 0;	// TEMPORARY FOR TESTING


	// If this function is called multiple times for the same operation ID (which happens,
	// for example, with cursor-reading loops that use FETCH INTO), there's no need to
	// repeat the analysis - everything relevant is stored in static variables, so we
	// don't have to re-assign anything. This should give us a little performance boost.
	if (!SameOpAsLastTime)
	{
		LastOperationID = OperationIdentifier_in;

		// Set some additional default values.
		// By default, the Cursor Name output variable gets a value of NULL.
		// Only cursors that will have FOR CURRENT OF operations performed
		// on them need an explicitly defined cursor name.
		NumOutputColumns			=	0;
		NumSingleCharOutputColumns	=	0;
		NumInputColumns				=	0;
		NeedsWhereClauseID			=	0;
		GenerateVALUES				=	0;
		StatementIsSticky			=	0;
		OutputColumnSpec			=	NULL;
		InputColumnSpec				=	NULL;
		CursorName					=	NULL;
		memset ((char *)OutputColumns, 0, sizeof(OutputColumns));
		memset ((char *)InputColumns,  0, sizeof(InputColumns));

		// Set variables based on the SQL operation specified.
		switch (OperationIdentifier_in)
		{
		#include "MacODBC_MyOperators.c"

		default:
					RetVal	= -1;
					GerrLogMini (GerrId, "SQL_GetMainOperationParameters: Unrecognized SQL operation %d (max = %d).",
								 OperationIdentifier_in, (ODBC_MAXIMUM_OPERATION - 1));
					break;

		}	// Switch (OperationIdentifier_in)

		// Interpret input/output column specifications.
		if ((RetVal == 0) && (NumOutputColumns > 0) && (!SameOpAsLastTime))
		{
			RetVal = ParseColumnList (OutputColumnSpec, NumOutputColumns, OutputColumns, &NumSingleCharOutputColumns);
		}

		if ((RetVal == 0) && (NumInputColumns > 0) && (!SameOpAsLastTime))
		{
			RetVal = ParseColumnList (InputColumnSpec, NumInputColumns, InputColumns, NULL);
		}

	}	// The current operation is NOT the same as the last one.


	// Move results to output variables.
	if (RetVal == 0)
	{
		*SQL_CommandText_out			= SQL_CommandText;
		*NumOutputColumns_out			= NumOutputColumns;
		*NumSingleCharOutputColumns_out	= NumSingleCharOutputColumns;
		*NumInputColumns_out			= NumInputColumns;
		*NeedsWhereClauseIdentifier_out	= NeedsWhereClauseID;
		*GenerateVALUES_out				= GenerateVALUES;
		*StatementIsSticky_out			= StatementIsSticky;
		*CursorName_out					= CursorName;
		*ErrorDescription_out			= ErrorBuffer;
		*OutputColumns_out				= (NumOutputColumns	> 0) ? OutputColumns	: NULL;
		*InputColumns_out				= (NumInputColumns	> 0) ? InputColumns		: NULL;
	}
	else
	{
		*SQL_CommandText_out			= "";
		*NumOutputColumns_out			= 0;
		*NumInputColumns_out			= 0;
		*NumSingleCharOutputColumns_out	= NumSingleCharOutputColumns;
		*NeedsWhereClauseIdentifier_out	= 0;
		*GenerateVALUES_out				= 0;
		*StatementIsSticky_out			= 0;
		*CursorName_out					= NULL;
		*ErrorDescription_out			= ErrorBuffer;
		*OutputColumns_out				= NULL;
		*InputColumns_out				= NULL;
	}


	return (RetVal);
}	// SQL_GetMainOperationParameters() end.



int SQL_GetWhereClauseParameters	(	long				WhereClauseIdentifier_in,
										char				**WhereClauseText_out,
										int					*NumInputColumns_out,
										ODBC_ColumnParams	**InputColumns_out,
										char				**ErrorDescription_out	)
{
	// Output variables.
	static char					*WhereClauseText;
	static int					NumInputColumns			= 0;
	static int					LastOperationID			= -1;
	static ODBC_ColumnParams	InputColumns	[100];
	static char					ErrorBuffer		[500];
	char						*InputColumnSpec;
	int							RetVal;
	int							SameOpAsLastTime;

	// Before we do anything, assume we have no error to report.
	RetVal	= 0;
	strcpy (ErrorBuffer, "");

	// Check whether this is the same operation as the last one requested. If so,
	// we don't have to re-parse the input/output column specifications.
	SameOpAsLastTime = (WhereClauseIdentifier_in == LastOperationID);


	// If this function is called multiple times for the same operation ID (which happens,
	// for example, with cursor-reading loops that use FETCH INTO), there's no need to
	// repeat the analysis - everything relevant is stored in static variables, so we
	// don't have to re-assign anything. This should give us a little performance boost.
	if (!SameOpAsLastTime)
	{
		LastOperationID = WhereClauseIdentifier_in;

		// Set some additional default values.
		NumInputColumns				=	0;
		InputColumnSpec				=	NULL;
		memset ((char *)InputColumns,  0, sizeof(InputColumns));

		// WORKINGPOINT: Would it be a nice idea to count question marks in the SQL command
		// text, so NumInputColumns could be set automatically? Or would it just slow things
		// down for no really good reason?

		// Set variables based on the SQL operation specified.
		switch (WhereClauseIdentifier_in)
		{
		#include "MacODBC_MyCustomWhereClauses.c"

		default:
					RetVal	= -1;
					GerrLogMini (GerrId, "Unrecognized WHERE clause identifier %d (max = %d).", WhereClauseIdentifier_in, (ODBC_MAXIMUM_WHERE_CLAUSE - 1));
					break;

		}	// Switch (OperationIdentifier_in)


		// Interpret input column specifications.
		if ((RetVal == 0) && (NumInputColumns > 0) && (!SameOpAsLastTime))
		{
			RetVal = ParseColumnList (InputColumnSpec, NumInputColumns, InputColumns, NULL);
		}

	}	// The current operation is NOT the same as the last one.


	// Move results to output variables.
	if (RetVal == 0)
	{
		*WhereClauseText_out			= WhereClauseText;
		*NumInputColumns_out			= NumInputColumns;
		*InputColumns_out				= (NumInputColumns	> 0) ? InputColumns		: NULL;
		*ErrorDescription_out			= ErrorBuffer;
	}
	else
	{
		*WhereClauseText_out			= "";
		*NumInputColumns_out			= 0;
		*InputColumns_out				= NULL;
		*ErrorDescription_out			= ErrorBuffer;
	}

	return (RetVal);
}	// SQL_GetWhereClauseParameters() end.



int SQL_CustomizePerDB (ODBC_DB_HEADER	*Database, char *SQL_Command_in, int *CommandLength_out)
{
	char	MyBuffer	[6000];
	char	*FirstSearchTerms[]		= {"{FIRST}", "{TOP}"};
	int		NumFirstSearchTerms		= 2;
	int		SearchTerm;
	int		len;
	int		MadeSubstitution		= 0;
	char	*FoundSearchTerm;

	// COMPILATION NOTE: strcasestr() is not part of standard C, so for this to
	// compile properly we need to add -D_GNU_SOURCE to the compile command.
	// (Alternatively, "#define _GNU_SOURCE" could be added to the source code.
	// Or both.

	for (SearchTerm = 0; SearchTerm < NumFirstSearchTerms; SearchTerm++)
	{
//		while ((FoundSearchTerm = strcasestr (SQL_Command_in, FirstSearchTerms[SearchTerm])) != NULL)
		while ((FoundSearchTerm = strstr (SQL_Command_in, FirstSearchTerms[SearchTerm])) != NULL)
		{
			memset	(MyBuffer, (char)0, sizeof (MyBuffer));
			len = FoundSearchTerm - SQL_Command_in;
			strncpy	(MyBuffer, SQL_Command_in, len);

			switch (Database->Provider)
			{
				case	ODBC_Informix:		strcpy (MyBuffer + len, "FIRST");
											len += 5;
											break;

				case	ODBC_MS_SqlServer:	strcpy (MyBuffer + len, "TOP");
											len += 3;
											break;

				default:					strcpy (MyBuffer + len, "TOP");
											len += 3;
											break;
			}

			strcpy (MyBuffer + len, FoundSearchTerm + strlen (FirstSearchTerms[SearchTerm]));

			strcpy (SQL_Command_in, MyBuffer);

			MadeSubstitution++;
		}
	}

	// If and only if we actually did something, update the command length.
	if ((MadeSubstitution > 0) && (CommandLength_out != NULL))
	{
		*CommandLength_out = strlen (SQL_Command_in);
	}

	return (0);
}	// SQL_CustomizePerDB() end.



int ParseColumnList (	char				*SpecStringIn,
						int					NumColumnsIn,
						ODBC_ColumnParams	*ParamsOut,
						short				*NumSingleCharOutputColumns_out		)
{
	static char	buffer [4000];
	char		*BufPtr;
	char		*Token;
	char		*Delim = " \t,[]()";
	int			ParametersDefined		= 0;
	short		NumSingleCharColumns	= 0;

	// Start the tokenizing and get the first token.
	strcpy (buffer, SpecStringIn);
	BufPtr = &buffer[0];
	Token = strtok (BufPtr, Delim);
	BufPtr = NULL;

	while (ParametersDefined < NumColumnsIn)
	{
		if (Token != NULL)
		{
			do
			{
				// NOTE: I've put these strcasecmp's in order more or less by how frequently
				// they're likely to be used - with the idea that the fewer string comparisons
				// we have to do, the faster this thing will run.

				if ((!strcasecmp (Token, "INT")) || (!strcasecmp (Token, "INTEGER")))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_SLONG;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if ((!strcasecmp (Token, "SHORT")) || (!strcasecmp (Token, "SMALLINT")))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_SSHORT;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if (!strcasecmp (Token, "CHAR"))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_CHAR;

					Token = strtok (BufPtr, Delim);
					if (Token != NULL)
					{
						ParamsOut [ParametersDefined].length = atoi (Token);

						// For single-character SELECTed fields that are to be mapped to a simple character
						// variable (i.e. "char VARNAME" as opposed to "char VARNAME[2]"), specify the field
						// as CHAR(0). (Alternately, use "SINGLE_CHAR" or "ONECHAR".) In this case, we'll
						// bind the output to an internal buffer, and then copy just the "payload" character
						// to the actual output variable.
						if (ParamsOut [ParametersDefined].length == 0)
						{
							NumSingleCharColumns++;
						}

						ParametersDefined++;
					}
					break;
				}

				// Note: VarChar is necessary only for input parameters (and I'm
				// not sure it's really all that necessary even then).
				if (!strcasecmp (Token, "VARCHAR"))
				{
					ParamsOut [ParametersDefined].type		= SQL_VARCHAR;

					Token = strtok (BufPtr, Delim);
					if (Token != NULL)
					{
						ParamsOut [ParametersDefined].length = atoi (Token);
						ParametersDefined++;
					}
					break;
				}

				// Almost all our decimal numbers are double-precision - so SQL FLOAT
				// gets mapped to SQL_C_DOUBLE. For those few cases where we have a
				// non-double decimal number, use REAL, which maps to SQL_C_FLOAT.
				if ((!strcasecmp (Token, "DOUBLE")) ||(!strcasecmp (Token, "FLOAT")))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_DOUBLE;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if ((!strcasecmp (Token, "LONG")) || (!strcasecmp (Token, "BIGINT")))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_SBIGINT;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if (!strcasecmp (Token, "UNSIGNED"))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_ULONG;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if (!strcasecmp (Token, "USHORT"))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_USHORT;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				// NOTE: Because a database "float" is normally a double-precision number
				// in our C code, use "REAL" to designate an ordinary float number. (There
				// are hardly any in our code.)
				if (!strcasecmp (Token, "REAL"))
				{
					ParamsOut [ParametersDefined].type		= SQL_C_FLOAT;
					ParamsOut [ParametersDefined].length	= 0;
					ParametersDefined++;
					break;
				}

				if ((!strcasecmp (Token, "SINGLE-CHAR"))	|| (!strcasecmp (Token, "SINGLE_CHAR")) || (!strcasecmp (Token, "SINGLECHAR"))		||
					(!strcasecmp (Token, "ONE-CHAR"))		|| (!strcasecmp (Token, "ONE_CHAR"))	|| (!strcasecmp (Token, "ONECHAR")))
				{
					// For single-character SELECTed fields that are to be mapped to a simple character
					// variable (i.e. "char VARNAME" as opposed to "char VARNAME[2]"), specify the field
					// as CHAR(0). (Alternately, use "SINGLE-CHAR" or "ONECHAR", with some punctuation
					// variations permitted.) In this case, we'll bind the output to an internal buffer,
					// and then copy just the "payload" character to the actual output variable.
					ParamsOut [ParametersDefined].type		= SQL_C_CHAR;
					ParamsOut [ParametersDefined].length	= 0;
					NumSingleCharColumns++;
					ParametersDefined++;
					break;
				}


				// SQL_C_WCHAR			SQL_WCHAR *				wchar_t *		(NOT SET UP YET)
				// SQL_C_BIT			SQLCHAR					unsigned char
				// SQL_C_STINYINT		SQLSCHAR				signed char
				// SQL_C_UTINYINT		SQLCHAR					unsigned char
				// SQL_C_UBIGINT		SQLUBIGINT				unsigned long	(NOT SET UP YET)
				// SQL_C_BINARY			SQLCHAR *				unsigned char *	(NOT SET UP YET)
				//
				// DATETIME / INTERVAL

				GerrLogMini (GerrId, "Unrecognized field-spec token {%s} for parameter %d!\n", Token, ParametersDefined + 1);
				break;
			}
			while (0);

			if (Token == NULL)
			{
				GerrLogMini (GerrId, "Field specification missing string length for parameter %d.\n", ParametersDefined + 1);
				break;
			}

		}	// Token != NULL

		else
		{
			GerrLogMini (GerrId, "Unexpected end of field specification - expected %d params, got only %d.\n", NumColumnsIn, ParametersDefined);
			break;
		}

		// Get next token.
		Token = strtok (BufPtr, Delim);

	}	// while (ParametersDefined < NumColumnsIn)

	// If we passed in an address to store the number of single-character (non-pointer)
	// output columns, copy the number to that address.
	if (NumSingleCharOutputColumns_out != NULL)
		*NumSingleCharOutputColumns_out = NumSingleCharColumns;

	if (ParametersDefined != NumColumnsIn)
		GerrLogMini (GerrId, "ParseColumnList: ParametersDefined = %d, NumColumnsIn = %d - mismatch!", ParametersDefined, NumColumnsIn);

	return (ParametersDefined != NumColumnsIn);
}	// ParseColumnList() end.


int find_FOR_UPDATE_or_GEN_VALUES	(	int		OperationIdentifier,
										char	*SQL_command_in,
										int		*FoundForUpdate_out,
										int		*FoundInsert_out,
										int		*FoundSelect_out,
										int		*FoundCustomWhereInsertionPoint_out	)
{
	static char	buffer [4000];
	char		*BufPtr;
	char		*Token;
	char		*Delim = " \t)";	// DonR 05Apr2020: Added close-paren to the delimiter list; it should be relevant only
									// for the custom WHERE insertion point, which can sometimes look like "... %s)".
	int			FirstToken						= 1;
	int			FoundForUpdate					= 0;
	int			FoundInsert						= 0;
	int			FoundSelect						= 0;
	int			FoundFor						= 0;
	int			FoundCustomWhereInsertionPoint	= 0;


	// DonR 16Mar2020: In some cases (like a FETCH INTO when the cursor was
	// DECLARED using a mainline-created SQL string) the SQL command string
	// passed to this function was NULL. That, needless to say, caused
	// problems! The solution is simply to make most of find_FOR_UPDATE_or_GEN_VALUES
	// operate only on a string that is non-NULL.
	if (SQL_command_in != NULL)
	{
		// Start the tokenizing and get the first token.
		strcpy (buffer, SQL_command_in);
		BufPtr = &buffer[0];
		Token = strtok (BufPtr, Delim);
		BufPtr = NULL;

		// We perform a break when (and if) we find the "FOR" - so we don't
		// need an additional condition for the while-loop.
		while (Token != NULL)
		{
			// If this is an INSERT statement, INSERT must be the first token in
			// the command string; if we're past that point, don't bother looking.
			if (FirstToken)
			{
				FirstToken = 0;

				if (!strcasecmp (Token, "INSERT"))
				{
					FoundInsert = 1;
				}

				if (!strcasecmp (Token, "SELECT"))
				{
					FoundSelect = 1;
				}
			}	// First token.


			// Check for custom WHERE clause insertion point - if there isn't one, we'll force
			// NeedsWhereClauseID false. (Note that this test *is* case-sensitive, since %S
			// isn't valid.)
			if (!strcmp (Token, "%s"))
				FoundCustomWhereInsertionPoint = 1;
//if ((OperationIdentifier == 110) && (!strcmp (Token, "%s"))) GerrLogMini(GerrId, "Found percent-s in SQL command string for Operation %d!", OperationIdentifier);

			// If we're past the first token and this is *not* a SELECT statement, there's
			// no point in looking for a FOR UPDATE clause - it's irrelevant and shouldn't
			// be there at all. (Really, if this routine is going to clean up after all
			// possible programmer sloppiness, it should automatically *delete* an erroneous
			// FOR UPDATE clause - but I don't think we need to get that fancy.)
			// DonR 05Apr2020: Because I added ")" to the delimiter list, in theory this routine
			// could get fooled if someone wrote "FOR) UPDATE"; but in that case we'd get a syntax
			// error at execution time, so the bug would be discovered pretty easily.
			if ((FoundSelect) && (!FoundFor))
			{
				if (!strcasecmp (Token, "FOR"))
				{
					FoundFor = 1;	// So multiple "FOR" tokens won't be accepted - only the first one will work.

					// We found the "FOR" - now check if the next token is "UPDATE".
					Token = strtok (BufPtr, Delim);
					if (Token != NULL)
					{
						if (!strcasecmp (Token, "UPDATE"))
							FoundForUpdate = 1;
					}

//					// Once we've found the "FOR", the next token is supposed to be
//					// "UPDATE" - there's no valid alternative, so we stop looking
//					// even if the "UPDATE" wasn't there.
//					continue;
				}	// We found a "FOR" token.
			}	// This is a SELECT statement.

			// The current token is not "FOR", so keep looking.
			Token = strtok (BufPtr, Delim);
		}	// While there are still more tokens to parse through.
//GerrLogMini(GerrId, "Found UPDATE %d, found INSERT %d, found SELECT %d.", FoundForUpdate, FoundInsert, FoundSelect);

	}	// if (SQL_command_in != NULL)

	if (FoundForUpdate_out != NULL)
		*FoundForUpdate_out = FoundForUpdate;

	if (FoundInsert_out != NULL)
		*FoundInsert_out = FoundInsert;

	if (FoundSelect_out != NULL)
		*FoundSelect_out = FoundSelect;

	if (FoundCustomWhereInsertionPoint_out != NULL)
		*FoundCustomWhereInsertionPoint_out = FoundCustomWhereInsertionPoint;

	return (0);
}


int ODBC_CONNECT (	ODBC_DB_HEADER	*Database,
					char			*DSN,
					char			*username,
					char			*password,
					char			*dbname)
{
	static int	FirstTimeCalled	= 1;
	int			result;
	long		ConnectTimeout	= 300;	// Seconds.
	char		StatementBuffer	[200];

	char		*ConnectResult;
	SQLHSTMT	ConnectToODBC_hstmt;	// Local statement handle for "USE" command.

	// Variables for use when and if we use SQLDriverConnect().
	//char		LoginInfo		[100];
	//char		ConnectInfoOut	[4096];
	//short		OutBufLength;



	if (FirstTimeCalled)
	{
		FirstTimeCalled			= 0;

		MS_DB.Connected			= 0;
		MS_DB.Provider			= ODBC_MS_SqlServer;

		INF_DB.Provider			= ODBC_Informix;
		INF_DB.Connected		= 0;

		NUM_ODBC_DBS_CONNECTED	= 0;

		// Make sure this program uses the system locale - otherwise
		// Hebrew text doesn't work.
		setlocale (LC_ALL, "");

		// Allocate the global ODBC environment handle.
		// NOTE: I've made a couple of attempts to use SQLAllocHandle instead of SQLAllocEnv
		// and SQLAllocConnect - but allocating the connection always fails, even though
		// allocating the environment returns no errors.
		result = SQLAllocEnv (&ODBC_henv);
//		result = SQLAllocHandle (SQL_HANDLE_ENV, SQL_NULL_HANDLE, &ODBC_henv);
		if (SQL_FAILED (result))
		{
			ODBC_EnvironmentError (&ODBC_henv);
			GerrLogMini (GerrId, "Unable to allocate environment handle (result = %d).\n", result);
			return (-1);
		}
	}	// First time called initializations.


	do
	{
//GerrLogMini (GerrId, "ODBC_CONNECT called for %s.", (Database->Provider == ODBC_MS_SqlServer) ? "MS-SQL" : "Informix");
		// Allocate a connection handle.
		result = SQLAllocConnect (ODBC_henv, &Database->HDBC);
//		result = SQLAllocHandle (SQL_HANDLE_DBC, ODBC_henv, &Database->HDBC);
		if (SQL_FAILED (result))
		{
			ODBC_DB_ConnectionError (&Database->HDBC);
			GerrLogMini (GerrId, "Unable to allocate connection handle (result = %d).\n", result);
			CleanupODBC (Database);
			break;
		}


		// Try to connect to the database server.
		// Specify a ridiculously long timeout interval, since the QA Informix database
		// seems to have a problem that causes it to respond very slowly to connection
		// requests.
		result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_LOGIN_TIMEOUT,			(SQLPOINTER)ConnectTimeout,				SQL_IS_UINTEGER);
		result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_CONNECTION_TIMEOUT,	(SQLPOINTER)ConnectTimeout,				SQL_IS_UINTEGER);
		result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_TXN_ISOLATION,			(SQLPOINTER)SQL_TXN_READ_UNCOMMITTED,	SQL_IS_UINTEGER);

		// DonR 23Feb2020: Try setting the connection to keep cursors open after a COMMIT - the equivalent of
		// having all cursors set to WITH HOLD. This setting is conditional, since it's needed only for situations
		// where we may have update cursors with lots of rows and periodic COMMIT's; the only place where this
		// normally happens is As400UnixClient. NOTE that Informix does not appear to have this capability.
		if ((Database->Provider == ODBC_MS_SqlServer) && (ODBC_PRESERVE_CURSORS))
		{
			result = SQLSetConnectAttr (Database->HDBC, SQL_COPT_SS_PRESERVE_CURSORS,	(SQLPOINTER)SQL_PC_ON,					SQL_IS_UINTEGER);
GerrLogMini (GerrId, "SQLSetConnectAttr SQL_COPT_SS_PRESERVE_CURSORS to SQL_PC_ON returns %d.", result);
		}

GerrLogMini (GerrId, "Calling SQLConnect...");
		result = SQLConnect (Database->HDBC, DSN, SQL_NTS, username, SQL_NTS, password, SQL_NTS);
//GerrLogMini(GerrId, "SQLConnect returned %d.", result);

		// Log connection parameters and result.
		switch (result)
		{
			case SQL_SUCCESS:			ConnectResult = "OK";			break;
			case SQL_SUCCESS_WITH_INFO:	ConnectResult = "OK w/info";	break;
			default:					ConnectResult = "FAILED";		break;
		}
//GerrLogMini (GerrId, "ConnectResult = %s, SQL_FAILED (result) = %d.", ConnectResult, SQL_FAILED (result));

		if (SQL_FAILED (result))
		{
//			GerrLogMini (GerrId, "Connect to DSN %s as %s/%s: %s (result = %d).", DSN, username, password, ConnectResult, result);
GerrLogMini(GerrId, "Connection to %s failed with result %d; &Database->Connected = %ld.", (Database->Provider == ODBC_MS_SqlServer) ? "MS-SQL" : "Informix",
			result, (long)(&Database->Connected));
			ODBC_DB_ConnectionError (&Database->HDBC);
GerrLogMini(GerrId, "ODBC error: %s", ODBC_ErrorBuffer);
			Database->Connected = 0;


//			// Second chance: try SQLDriverConnect().
//			sprintf (LoginInfo, "DSN=%s;UID=%s;PWD=%s;DRIVER=/opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.3.so.1.1;", DB, USER, PASS);
//			sprintf (LoginInfo, "DSN=%s;UID=%s;PWD=%s;DRIVER=SQL Server;", DB, USER, PASS);
//			result = SQLDriverConnect (	hdbc,		// Connection handle.
//										NULL,		// Dialogue window (none).
//										LoginInfo,
//										strlen (LoginInfo),
//										ConnectInfoOut,
//										4000,
//										&OutBufLength,
//										SQL_DRIVER_NOPROMPT);
//
//
//			result = SQLConnect (hdbc, DSN, SQL_NTS, DSN_userid, SQL_NTS, DSN_password, SQL_NTS);
//
//			// Log connection parameters and result.
//			switch (result)
//			{
//				case SQL_SUCCESS:			ConnectResult = "OK";			break;
//				case SQL_SUCCESS_WITH_INFO:	ConnectResult = "OK w/info";	break;
//				default:					ConnectResult = "FAILED";		break;
//			}
//
//			printf ("Second-chance connect to %s: %s (result = %d).\n", LoginInfo, ConnectResult, result);
//			ODBC_DB_ConnectionError (&Database->HDBC);
		}
		else
		{
GerrLogMini(GerrId, "ODBC Connect to %s succeeded; &Database->Connected = %ld.", (Database->Provider == ODBC_MS_SqlServer) ? "MS-SQL" : "Informix",	(long)(&Database->Connected));
			Database->Connected = 1;
//GerrLogMini(GerrId, "Marked database as connected.");
			NUM_ODBC_DBS_CONNECTED++;
//GerrLogMini (GerrId, "DB connected. Num connected = %d.", NUM_ODBC_DBS_CONNECTED);
		}

		if (SQL_FAILED (result))
		{
			CleanupODBC (Database);
			break;
		}

		// If we get here, we *should* be connected and ready to do stuff.


		// MS-SQL requires a "USE" to select the specific database we'll be working with;
		// Informix does not.
		if (Database->Provider == ODBC_MS_SqlServer)
		{
			// Allocate a statement handle - works only after connecting to database.
			result = SQLAllocStmt (Database->HDBC, &ConnectToODBC_hstmt);
			if (SQL_FAILED (result))
			{
				GerrLogMini (GerrId, "Unable to allocate statement handle (result = %d).\n", result);
				CleanupODBC (Database);
				break;
			}

			// Select the specific database.
			sprintf (StatementBuffer, "USE %s", dbname);
			result = SQLPrepare (ConnectToODBC_hstmt, (unsigned char *)StatementBuffer, strlen (StatementBuffer));
			if (SQL_FAILED (result))
			{
				GerrLogMini (GerrId, "Unable to prepare %s (result = %d).\n", StatementBuffer, result);
				CleanupODBC (Database);
				break;
			}

			result = SQLExecute (ConnectToODBC_hstmt);	// USE command.

			if (SQL_FAILED (result))
			{
				ODBC_StatementError (&ConnectToODBC_hstmt, 0);
				break;
			}

			SQLFreeStmt (ConnectToODBC_hstmt, SQL_CLOSE);
		}	// Database->Provider == ODBC_MS_SqlServer
//else GerrLogMini (GerrId, "Connected database is NOT MS-SQL.");


		// We want all our database connections to be in "transaction" mode so they
		// can be rolled back if we hit a major error - so turn AUTOCOMMIT off.
//GerrLogMini (GerrId, "Calling SQLSetConnectAttr for SQL_AUTOCOMMIT_OFF...");
		result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_AUTOCOMMIT, (SQLPOINTER)SQL_AUTOCOMMIT_OFF, SQL_IS_UINTEGER);
		if (SQL_FAILED (result))
		{
			GerrLogMini (GerrId, "Set AUTOCOMMIT off failed (result = %d).", result);
			ODBC_DB_ConnectionError (&Database->HDBC);
		}
//else GerrLogMini (GerrId, "Set SQL_AUTOCOMMIT_OFF succeeded.");

		// We also want to default our DB isolation level to "dirty read" to avoid
		// deadlocks. Note that ODBC does *not* allow us to change the isolation
		// level once a transaction has begun - so any SET_ISOLATION_COMMITTED
		// calls have to be executed before there's any uncommitted data.
//GerrLogMini (GerrId, "Calling SQLSetConnectAttr for SQL_TXN_READ_UNCOMMITTED...");
		result = SQLSetConnectAttr (Database->HDBC, SQL_ATTR_TXN_ISOLATION, (SQLPOINTER)SQL_TXN_READ_UNCOMMITTED, SQL_IS_UINTEGER);
		if (SQL_FAILED (result))
		{
			GerrLogMini (GerrId, "Set initial DIRTY READ failed (result = %d).", result);
			ODBC_DB_ConnectionError (&Database->HDBC);
		}
//else GerrLogMini (GerrId, "Set SQL_TXN_READ_UNCOMMITTED succeeded.");

//		// DonR 02Apr2020: Turn off Informix ODBC parsing for better performance.
		// (Disabled, since I can't find SQL_INFX_ATTR_SKIP_PARSING anywhere.)
//		if (Database->Provider == ODBC_Informix)
//		{
//			result = SQLSetConnectAttr (Database->HDBC, SQL_INFX_ATTR_SKIP_PARSING, (SQLPOINTER)SQL_TRUE, SQL_IS_USMALLINT);
//			if (SQL_FAILED (result))
//			{
//				GerrLogMini (GerrId, "Disable Informix ODBC parsing failed (result = %d).", result);
//				ODBC_DB_ConnectionError (&Database->HDBC);
//			}
//			else GerrLogMini (GerrId, "Disable Informix ODBC parsing succeeded.");
//		}	// Disable Informix ODBC parsing.

//		// Temporary - get some driver information.
//		SQLGetInfo (hdbc, SQL_MAX_ASYNC_CONCURRENT_STATEMENTS, &result, 4, &ErrorLength);
//		printf ("ODBC max concurrent statements = %d.\n", result);
//		SQLGetInfo (hdbc, SQL_MAX_CONCURRENT_ACTIVITIES, &result, 4, &ErrorLength);
//		printf ("ODBC max concurrent activities = %d.\n", result);
//		SQLGetInfo (hdbc, SQL_MAX_DRIVER_CONNECTIONS, &result, 4, &ErrorLength);
//		printf ("ODBC max driver connections = %d.\n", result);

	} while (0);

	return (result);
}	// ODBC_CONNECT() end.


int CleanupODBC (ODBC_DB_HEADER	*Database)
{
	// Disconnect from the database and free all handles
	if (Database->Connected)
	{
		SQLDisconnect	(Database->HDBC);
		SQLFreeConnect	(Database->HDBC);
		Database->Connected = 0;

		if (--NUM_ODBC_DBS_CONNECTED < 1)
		{
			SQLFreeEnv		(ODBC_henv);
		}
	}

	return;
}	// CleanupODBC() end.


int ODBC_ErrorHandler				(	int			ErrorCategory,
										SQLHENV		*Environment,
										SQLHDBC		*Database,
										SQLHSTMT	*Statement,
										int			OperationIdentifier		)
{
	char		*OriginalSQLCommand = NULL;
	char		ODBC_StateBuffer	[100];
	char		ODBC_ErrorText		[4096];
	char		*ErrCategoryDesc;
	int			ODBC_NativeError;
	short		ODBC_ErrorLength;
	int			errm_len;

	// Dummy parameters for retrieving original SQL command text.
	int					DummyInteger;
	short				DummyShort;
	ODBC_ColumnParams	*DummyColumnPointer;
	char				*DummyString;

	switch (ErrorCategory)
	{
	case ODBC_ENVIRONMENT_ERR:
				ErrCategoryDesc = "Environment error";
				SQLGetDiagRec (SQL_HANDLE_ENV, *Environment, 1, ODBC_StateBuffer, &ODBC_NativeError, ODBC_ErrorText, 4095, &ODBC_ErrorLength);
				break;


	case ODBC_DB_HANDLE_ERR:
				ErrCategoryDesc = "Database handle error";
				SQLGetDiagRec (SQL_HANDLE_DBC, *Database, 1, ODBC_StateBuffer, &ODBC_NativeError, ODBC_ErrorText, 4095, &ODBC_ErrorLength);
				break;


	case ODBC_STATEMENT_ERR:
				ErrCategoryDesc = "Statement error";
				if (OperationIdentifier > 0)
				{
					SQL_GetMainOperationParameters (	OperationIdentifier,	// SQL Operation ID.
														&OriginalSQLCommand,	// Original SQL command text - the only output we're interested in!
														&DummyInteger,			// Number of output columns.
														&DummyShort,			// Number of single-character output columns.
														&DummyColumnPointer,	// Output column pointer.
														&DummyInteger,			// Number of input columns.
														&DummyColumnPointer,	// Input column pointer.
														&DummyInteger,			// Needs custom WHERE clause.
														&DummyInteger,			// Auto-build VALUES.
														&DummyShort,			// Statement is "sticky".
														&DummyString,			// Cursor Name.
														&DummyString	);		// Error string.
				}

				SQLGetDiagRec (SQL_HANDLE_STMT, *Statement, 1, ODBC_StateBuffer, &ODBC_NativeError, ODBC_ErrorText, 4095, &ODBC_ErrorLength);
				break;

	default:	strcpy	(ODBC_StateBuffer, "");
				ErrCategoryDesc = "Unrecognized error category";
				sprintf	(ODBC_ErrorText, "Unrecognized error category %d.", ErrorCategory);
				ODBC_NativeError = 0;
				break;
	}

	// Set up "legacy" error reporting fields.
	if (strlen (ODBC_ErrorText) > ODBC_ErrorLength)
		ODBC_ErrorText [ODBC_ErrorLength] = (char)0;

	errm_len = sprintf (ODBC_ErrorBuffer, "SQL %s: SQL state %s, native err %d, error text {%s}",
						ErrCategoryDesc, ODBC_StateBuffer, ODBC_NativeError, ODBC_ErrorText);
//GerrLogMini(GerrId, ODBC_ErrorBuffer);
//	errm_len = strlen (ODBC_ErrorBuffer);
	if (errm_len >= sizeof(sqlca.sqlerrm))
		errm_len = sizeof(sqlca.sqlerrm) - 1;
	strncpy (sqlca.sqlerrm, ODBC_ErrorBuffer, errm_len);
	sqlca.sqlerrm [errm_len] = (char)0;

//GerrLogMini (GerrId, "Error category %d: SQL state %s, native err %d, error text {%s}\nOriginal SQL command:\n%s\n",
//			 ErrorCategory, ODBC_StateBuffer, ODBC_NativeError, ODBC_ErrorText,
//			 (OriginalSQLCommand == NULL) ? "N/A" : OriginalSQLCommand);

	// Set the global last-SQL-statement-text pointer to the SQL we just retrieved.
	// DonR 16Mar2020: If the SQL statement uses an SQL command generated by the calling
	// code, set ODBC_LastSQLStatementText to a blank string rather than NULL. This may
	// prevent a segmentation fault (I hope!) when we produce an error diagnostic.
	ODBC_LastSQLStatementText = (OriginalSQLCommand == NULL) ? "" : OriginalSQLCommand;

	// For now, return the ODBC SQL Native Error - but we should probably do some
	// translation here, to return familiar error codes to calling functions.
	return (ODBC_NativeError);
}	// ODBC_ErrorHandler() end.


int ODBC_IsValidPointer (void *Pointer_in)
{
	char	PointerTestChar;

	ODBC_PointerIsValid = 1;	// Default = pointer is OK.

	if (!sigsetjmp (BeforePointerTest, 1))
	{
		// Try reading one byte from the pointer, and then writing the same byte back again. If
		// the address is both readable and writeable without a segmentation fault, we can pretty
		// much assume that it's valid.
		PointerTestChar = *(char *)Pointer_in;
		*(char *)Pointer_in = PointerTestChar;
	}
	else
	{
		// If we get here, sigsetjmp "returned" a non-zero value - which
		// means there was a siglongjmp from ODBC_SegmentationFaultCatcher,
		// and ODBC_PointerIsValid has been set FALSE. We don't have to do
		// anything special in this case - just return from the function.
	}

	return (ODBC_PointerIsValid);
}


void ODBC_SegmentationFaultCatcher (int signo)
{
	caught_signal = signo;


	// ODBC_ValidatingPointers indicates that we are in fact checking ODBC column/parameter
	// pointers, so we want to recover gracefully from a segmentation fault. At any other
	// point, a segmentation fault is a fatal error and should terminate the program as it
	// normally does.
	if (ODBC_ValidatingPointers)
	{
		// Segmentation fault means that the pointer we're checking is *not* OK.
		ODBC_PointerIsValid = 0;

		// Reset signal handling for the segmentation fault signal.
		sigaction (SIGSEGV, &sig_act_ODBC_SegFault, NULL);

		// Go back to the point just before we forced the segmentation-fault error.
		siglongjmp (BeforePointerTest, 1);
	}
	else
	{
		// "Ordinary" fatal segmentation fault - exit program.
		GerrLogMini (GerrId, "Segmentation fault - terminating program!");
		RollbackAllWork ();
		SQLMD_disconnect ();

		// Exit child process.
		ExitSonProcess ((signo == 0) ? MAC_SERV_SHUT_DOWN : MAC_EXIT_SIGNAL);
	}

}

#endif	// MAIN
#endif	// MacODBC_H defined
